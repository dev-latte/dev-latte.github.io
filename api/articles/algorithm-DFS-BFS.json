{"title":"5. DFS/BFS","uid":"9823f8c5a18f804c1c6c693243f76046","slug":"algorithm-DFS-BFS","date":"2021-08-09T06:53:40.000Z","updated":"2021-08-09T13:54:04.215Z","comments":true,"path":"api/articles/algorithm-DFS-BFS.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/algorithm.jpeg","content":"<p>CS에서 탐색(Search)이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 의미합니다.<br>프로그래밍에서는 주로 자료구조 안에서 탐색하는 경우가 많습니다.<br><em>(자료구조에 대한 자세한 설명은 <a href=\"https://dev-latte.github.io/post/cs-data-structure\">여기</a>에서 확인해주세요)</em></p>\n<h3 id=\"5-DFS-깊이-우선-탐색-BFS-너비-우선-탐색\"><a href=\"#5-DFS-깊이-우선-탐색-BFS-너비-우선-탐색\" class=\"headerlink\" title=\"5. DFS(깊이 우선 탐색) / BFS(너비 우선 탐색)\"></a>5. DFS(깊이 우선 탐색) / BFS(너비 우선 탐색)</h3><h4 id=\"5-1-1-DFS-Depth-First-Search-깊이-우선-탐색\"><a href=\"#5-1-1-DFS-Depth-First-Search-깊이-우선-탐색\" class=\"headerlink\" title=\"5-1-1 DFS(Depth-First Search) - 깊이 우선 탐색\"></a>5-1-1 DFS(Depth-First Search) - 깊이 우선 탐색</h4><p>DFS(Depth-First Search)는 깊이 우선 탐색이라고도 부르며, <strong>그래프</strong>에서 깊은 부분을 우선적으로 탐색하는 알고리즘입니다.<br>DFS를 설명하기 위해서는 그래프의 기본 구조부터 알아야합니다.<br>(그래프의 자세한 설명은 <a href=\"https://dev-latte.github.io/post/cs-graph\">이 포스트</a>를 참고해주세요)</p>\n<p>이 알고리즘을 설명하기 위해 필요한 그래프의 개념은 <strong>노드(Node)</strong> 와 <strong>간선(Edge)</strong> 입니다.(노드를 <strong>정점_Vertex</strong>이라고도 합니다.)</p>\n<p><strong>그래프 탐색</strong>이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말하며, 여기서 두 노드가 간선으로 연결되어 있다면 <strong>‘두 노드는 인접하다(Adjacent)’</strong> 라고 표현합니다.</p>\n<h4 id=\"5-1-2-그래프의-표현방식\"><a href=\"#5-1-2-그래프의-표현방식\" class=\"headerlink\" title=\"5-1-2 그래프의 표현방식\"></a>5-1-2 그래프의 표현방식</h4><p>프로그래밍에서 그래프는  <strong>인접 행렬(Adjacency Matrix)</strong> 과 <strong>인접 리스트(Adjacency List)</strong> 두 가지 방식으로 표현할 수 있습니다.<br>코딩테스트에서는 이 두 방식 모두 필요하니 두 개념에 대해 바르게 알고가도록 합시다.<br>(자세한 내용은 <a href=\"https://dev-latte.github.io/post/cs-graph\">그래프 관련 포스팅</a>을 참고해주세요)</p>\n<h4 id=\"5-1-3-DFS의-동작-방식\"><a href=\"#5-1-3-DFS의-동작-방식\" class=\"headerlink\" title=\"5-1-3 DFS의 동작 방식\"></a>5-1-3 DFS의 동작 방식</h4><p>이 알고리즘은 특정한 경로로 탐색하다가 특정한 상황에서 <strong>최대한 깊숙</strong>하게 들어가서 노드를 방문한 후, 다시 돌아가 경로를 탐색하는 <strong>탐색 알고리즘</strong>입니다.<br>DFS는 스택 자료구조를 이용하며, 구체적인 동작 과정은 다음과 같습니다.</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\"><strong>DFS 과정</strong></p>\n<ol>\n<li>탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.</li>\n<li>스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면, 그 인접 노드를 스택에 넣고 방문처리를 한다.<br> 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.</li>\n<li>2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.</li>\n</ol>\n\n</div>\n<p>그럼, 이 과정을 그래프를 통해서 살펴봅시다. 아래에 다음과 같은 그래프가 있습니다.</p>\n<p>[그림5-1] 그래프 예시<br><img src=\"./algorithm-DFS-BFS/1-exam_graph.png\"></p>\n<p>[노드 1]을 <strong>시작 노드로 설정</strong>하여 DFS를 진행해봅시다!</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\"><strong>DFS의 탐색 순서</strong></p>\n<p><p><em>(일반적으로 인접한 노드 중에서 방문하지 않은 노드가 여러 개 존재할 경우 번호가 낮은 순서부터 처리합니다)</em></p>\n<ol>\n<li>시작 <strong>[노드 1]</strong> 을 스택에 삽입하고 방문 처리를 합니다.</li>\n<li>[노드 1]의 인접 노드인 [노드 2]와 [노드 3], [노드 8] 중에 가장 작은 <strong>[노드 2]</strong> 를 스택에 넣고 방문 처리합니다.</li>\n<li>[노드 2]의 인접 노드인 <strong>[노드 7]</strong> 을 스택에 넣고 방문 처리합니다.</li>\n<li>[노드 7]의 인접 노드인 [노드 6]과 [노드 8] 중에 가장 작은 <strong>[노드 6]</strong> 을 스택에 넣고 방문 처리합니다.</li>\n<li>[노드 6]은 인접 노드가 없으므로 스택에서 <strong>[노드 6]</strong> 을 꺼냅니다.</li>\n<li>다시 [노드 7]로 돌아가 방문하지 않은 <strong>[노드 8]</strong> 을 스택에 넣고 방문 처리합니다.</li>\n<li>[노드 8]은 인접 노드가 없으므로 스택에서 <strong>[노드 8]</strong> 을 꺼냅니다.</li>\n<li>다시 [노드 7]로 돌아갑니다. [노드 7]에서 방문하지 않은 인접 노드가 없으므로 스택에서 <strong>[노드 7]</strong> 을 꺼냅니다.</li>\n<li>다시 [노드 2]로 돌아갑니다. [노드 2]에서 방문하지 않은 인접 노드가 없으므로 스택에서 <strong>[노드 2]</strong> 를 꺼냅니다.</li>\n<li>시작 노드인 [노드 1]로 돌아갑니다.</li>\n<li>[노드 1]의 인접 노드인 <strong>[노드 3]</strong> 을 스택에 넣고 방문 처리합니다.</li>\n<li>[노드 3]의 인접 노드인 [노드 4]와 [노드 5]중에 숫자가 더 작은 <strong>[노드 4]</strong> 를 스택에 넣고 방문 처리합니다.</li>\n<li>[노드 4]의 인접 노드인 <strong>[노드 5]</strong> 를 스택에 넣고 방문 처리합니다.</li>\n<li>[노드 5]는 인접 노드가 없으므로 스택에서 <strong>[노드 5]</strong> 를 꺼냅니다.</li>\n<li><strong>이제 방문하지 않은 노드가 없습니다.</strong> 스택에서 남은 노드를 하나씩 꺼내주면 탐색이 종료됩니다.</li>\n</ol>\n</p>\n</div>\n<p>결과적으로 노드의 탐색 순서는 다음과 같습니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>노드 1 → 노드 2 → 노드 7 → 노드 6 → 노드 8 → 노드 3 → 노드 4 → 노드 5</p></blockquote>\n<p>또한, DFS는 스택을 이용하는 알고리즘이기 때문에 실제 구현은 재귀함수를 이용했을 때 매우 간결하게 구현할 수 있습니다.</p>\n<h4 id=\"5-2-1-BFS-Breadth-First-Search-너비-우선-탐색\"><a href=\"#5-2-1-BFS-Breadth-First-Search-너비-우선-탐색\" class=\"headerlink\" title=\"5-2-1 BFS(Breadth-First Search) - 너비 우선 탐색\"></a>5-2-1 BFS(Breadth-First Search) - 너비 우선 탐색</h4><p>BFS(Breadth-First Search) 알고리즘은 ‘너비 우선 탐색’ 알고리즘 입니다. 쉽게 말해서 <strong>가까운 노드부터 탐색</strong>하는 알고리즘입니다. DFS랑 비교해보자면, DFS는 최대한 멀리 있는 노드(가장 깊은 노드)를 우선으로 탐색하는 방식이지만, BFS는 그 반대입니다. </p>\n<p>이러한 BFS의 탐색은 <strong>큐 자료구조</strong>를 이용하여 구현하게 됩니다. 동작 방식은 아래와 같습니다.</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\"><strong>BFS 과정</strong></p>\n<ol>\n<li>탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다.</li>\n<li>큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 합니다.</li>\n<li>2번의 과정을 더 이상 수행할 수 없을 때까지 반복합니다.</li>\n</ol>\n\n</div>\n<p>그럼, 이 과정을 위의 <strong>[그림5-1]</strong> 그래프를 통해서 살펴봅시다.</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\"><strong>BFS의 탐색 순서</strong></p>\n<p><ol>\n<li>[노드 1]과 가까운 <strong>[노드 2]</strong>, <strong>[노드 3]</strong>, <strong>[노드 8]</strong> 을 순차적으로 큐에 삽입하고 방문 처리 합니다. </li>\n<li>번호가 빠른 [노드 2]를 큐에서 꺼내고, 방문하지 않은 인접 노드 <strong>[노드 7]</strong> 을 큐에 삽입, 방문 처리 합니다.</li>\n<li>그 다음인 [노드 3]을 큐에서 꺼내고, 방문하지 않은 인접 노드 <strong>[노드 4]</strong> 와 <strong>[노드 5]</strong> 큐에 삽입, 방문 처리합니다.</li>\n<li>큐에서 그 다음인 [노드 8]을 꺼내고, 방문하지 않은 인접 노드가 없으므로 다음 노드로 넘어갑니다.</li>\n<li>그 다음 번호인 [노드 7]을 큐에서 꺼내고 방문하지 않은 인접 노드 <strong>[노드 6]</strong> 을 큐에 삽입하고 방문 처리합니다.</li>\n<li> 남아있는 노드가 없고, 방문하지 않은 노드도 없으므로 <strong>큐에서 모든 노드를 차례대로 꺼내고 탐색을 종료</strong>합니다. </li>\n</ol>\n</p>\n</div>\n<p>결과적으로 노드의 탐색 순서는 다음과 같습니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>노드 1 → 노드 2 → 노드 3 → 노드 8 → 노드 7 → 노드 4 → 노드 5 → 노드 6</p></blockquote>\n<p>BFS(너비 탐색) 알고리즘은 큐 자료구조를 이용한다는 점에서 <strong>구현이 간편</strong>합니다.<br>큐 자체보다는 deque 라이브러리를 사용하는 것이 좋고, O(n)의 시간이 소요됩니다.<br>일반적인 경우, <strong>실제 수행 시간이 DFS보다 좋은 편</strong>이라는 점을 기억해둡시다!</p>\n<h3 id=\"5-3-DFS-vs-BFS\"><a href=\"#5-3-DFS-vs-BFS\" class=\"headerlink\" title=\"5-3 DFS vs BFS\"></a>5-3 DFS vs BFS</h3><table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"><strong>DFS</strong></th>\n<th align=\"left\"><strong>BFS</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">동작 원리</td>\n<td align=\"left\">스택</td>\n<td align=\"left\">큐</td>\n</tr>\n<tr>\n<td align=\"left\">구현 방법</td>\n<td align=\"left\">재귀 함수 이용</td>\n<td align=\"left\">큐 자료구조 이용(deque 추천)</td>\n</tr>\n</tbody></table>\n<p>앞에서 이 둘을 설명하는 데에 전형적인 그래프를 이용했는데, <strong>1차원 배열</strong>이나 <strong>2차원 배열</strong>도 그래프 형태로 생각하면 수월하게 문제를 풀 수 있습니다.</p>\n<p>예를 들어, 게임 맵이 3x3 형태의 2차원 배열이고 각 데이터를 좌표라고 생각해봅시다.<br>게임 캐릭터의 시작점은 좌표 (1, 1)이며, 캐릭터의 이동은 상하좌우로만 가능합니다.<br>이 경우, 좌표를 그래프 형태로 바꿔서 생각할 수 있습니다.</p>\n<p>즉, 코딩테스트에서 <strong>2차원 배열에서의 탐색 문제</strong>를 만나면 이렇게 <strong>그래프 형태</strong>로 바꿔서 생각하면 풀이 방법을 떠올리는 것이 더 쉽습니다!<br>그러므로, 코딩테스트에서 탐색 문제를 보면 그래프 형태로 표현한 풀이법을 고민해 보도록 합시다!</p>\n","feature":true,"text":"CS에서 탐색(Search)이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 의미합니다.프로그래밍에서는 주로 자료구조 안에서 탐색하는 경우가 많습니다.(자료구조에 대한 자세한 설명은 여기에서 확인해주세요) 5. DFS(깊이 우선 탐색) / B...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"알고리즘","slug":"알고리즘","count":5,"path":"api/categories/알고리즘.json"}],"tags":[{"name":"algorithm","slug":"algorithm","count":6,"path":"api/tags/algorithm.json"},{"name":"DFS","slug":"DFS","count":1,"path":"api/tags/DFS.json"},{"name":"BFS","slug":"BFS","count":1,"path":"api/tags/BFS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-DFS-%EA%B9%8A%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89-BFS-%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89\"><span class=\"toc-text\">5. DFS(깊이 우선 탐색) &#x2F; BFS(너비 우선 탐색)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-1-DFS-Depth-First-Search-%EA%B9%8A%EC%9D%B4-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89\"><span class=\"toc-text\">5-1-1 DFS(Depth-First Search) - 깊이 우선 탐색</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-2-%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%ED%91%9C%ED%98%84%EB%B0%A9%EC%8B%9D\"><span class=\"toc-text\">5-1-2 그래프의 표현방식</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-1-3-DFS%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\"><span class=\"toc-text\">5-1-3 DFS의 동작 방식</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-2-1-BFS-Breadth-First-Search-%EB%84%88%EB%B9%84-%EC%9A%B0%EC%84%A0-%ED%83%90%EC%83%89\"><span class=\"toc-text\">5-2-1 BFS(Breadth-First Search) - 너비 우선 탐색</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-DFS-vs-BFS\"><span class=\"toc-text\">5-3 DFS vs BFS</span></a></li></ol>","author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"mapped":true,"prev_post":{},"next_post":{"title":"10. 머스테치(mustache)로 화면 구성하기","uid":"6cbdd4fd25742628092b5aa717b3e98a","slug":"springboot-web-11","date":"2021-07-21T07:37:52.000Z","updated":"2021-07-21T08:41:05.304Z","comments":true,"path":"api/articles/springboot-web-11.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/main.png","text":"이번 포스트는 머스테치를 이용한 프론트 엔드 개발을 설명하겠습니다. 머스테치(mustache)로 화면 구성하기10-1 템플릿 엔진(Template Engine)이란?템플릿 엔진(Template Engine)이란, 지정된 템플릿 양식과 특정 데이터 모델...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","slug":"스프링-부트와-AWS로-혼자-구현하는-웹-서비스","count":11,"path":"api/categories/스프링-부트와-AWS로-혼자-구현하는-웹-서비스.json"}],"tags":[{"name":"springBoot","slug":"springBoot","count":11,"path":"api/tags/springBoot.json"},{"name":"Java","slug":"Java","count":9,"path":"api/tags/Java.json"},{"name":"JPA Auditing","slug":"JPA-Auditing","count":2,"path":"api/tags/JPA-Auditing.json"}],"author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"feature":true}}