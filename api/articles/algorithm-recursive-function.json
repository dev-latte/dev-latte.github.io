{"title":"4. 재귀 함수(Recursive Function)","uid":"9ed3a98723cc8a223c9fd2c456508919","slug":"algorithm-recursive-function","date":"2021-07-15T02:00:06.000Z","updated":"2021-07-15T04:23:37.944Z","comments":true,"path":"api/articles/algorithm-recursive-function.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/algorithm.jpeg","content":"<p>DFS(Depth-First Srarch) 및 BFS(Breadth First Search)에 대해 정리하다보니, 이를 이해하기 위해서는 그래프, 스택, 재귀 함수에 대한 이해가 필요하다는 것을 알게 되었습니다. <a href=\"https://dev-latte.github.io/post/cs-graph\">그래프</a>와 <a href=\"https://dev-latte.github.io/post/cs-stack-and-queue\">스택</a>은 이전에 정리해두었으니, 이 포스트에서는 나머지 하나인 재귀 함수에 대해 정리해보려 합니다.<br>(이 포스트는 <code>이것이 취업을위한 코딩테스트다 with 파이썬</code>을 기준으로 정리한 글입니다.)</p>\n<h3 id=\"재귀-함수-Recursive-Function\"><a href=\"#재귀-함수-Recursive-Function\" class=\"headerlink\" title=\"재귀 함수(Recursive Function)\"></a>재귀 함수(Recursive Function)</h3><h4 id=\"1-정의\"><a href=\"#1-정의\" class=\"headerlink\" title=\"1. 정의\"></a>1. 정의</h4><p>재귀 함수(Recursive Function)란 자기 자신을 다시 호출하는 함수를 말합니다.<br>가장 간단한 재귀함수의 예는 다음과 같습니다.</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"재귀함수를 호출합니다.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">recursive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>recursive() 메서드 안에 recursive()메서드가 포함된 것이 보이시나요? 재귀 함수는 이런식으로 자기 자신을 다시 호출합니다.  </p>\n<p>참고로 위의 코드를 실행하면 <code>재귀함수를 호출합니다</code>라는 문자열을 무한히 출력하다가 에러가 발생합니다. 컴퓨터의 사정상 무한대로 재귀 호출을 진행하기는 어렵기 때문입니다. 때문에 재귀 함수에서는 반드시 <strong>종료 조건을 명시</strong>하여 원하는 시점에 종료를 할 수 있도록 작성해야 합니다. </p>\n<h4 id=\"2-재귀함수의-동작-방식\"><a href=\"#2-재귀함수의-동작-방식\" class=\"headerlink\" title=\"2. 재귀함수의 동작 방식\"></a>2. 재귀함수의 동작 방식</h4><p>컴퓨터 내부에서 재귀 함수의 수행은 <strong>스택 자료 구조</strong>를 이용합니다. 함수를 계속 호출했을 때 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 때문입니다.</p>\n<p>그럼, 구체적으로 어떻게 스택 자료 구조를 이용하는지 팩토리얼을 예시로 설명해보겠습니다.</p>\n<p>[그림4-1] 재귀 함수의 동작 방식 1<br><img src=\"./algorithm-recursive-function/1.png\" alt=\"재귀 함수의 동작 방식-1\"><br>[그림4-2] 재귀 함수의 동작 방식 2<br><img src=\"./algorithm-recursive-function/2.png\" alt=\"재귀 함수의 동작 방식-2\"><br>[그림4-3] 재귀 함수의 동작 방식 3<br><img src=\"./algorithm-recursive-function/3.png\" alt=\"재귀 함수의 동작 방식-3\"></p>\n<p>재귀 함수의 동작 방식이 이해 되셨나요? 중요한 것만 이야기하자면, </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>재귀 함수는 <strong>내부적으로 스택 자료구조와 동일하다!</strong></li>\n<li>따라서, <strong>스택 자료구조를 활용해야하는 상당수 알고리즘은 재귀함수를 이용해서 간편하게 구현할 수 있다!</strong> </li>\n</ul></blockquote>\n<p>라는 것입니다.</p>\n<p>다음은 예시로 들었던 팩토리얼에 대해 가볍게 설명하고 지나가겠습니다.</p>\n<h4 id=\"3-예시-팩토리얼-Factorial\"><a href=\"#3-예시-팩토리얼-Factorial\" class=\"headerlink\" title=\"3. 예시 - 팩토리얼(Factorial)\"></a>3. 예시 - 팩토리얼(Factorial)</h4><p>재귀 함수를 이용하는 대표적인 예제로는 <code>팩토리얼(Factorial)</code> 문제가 있습니다. <strong>팩토리얼은 1부터 어떤 양의 정수 n까지의 정수를 모두 곱한 것</strong>을 말하며 n! 로 표현합니다. 여기서 <code>n!은 1 × 2 × 3 × …… × (n-1) × n</code> 를 의미합니다. 팩토리얼 함수는 수학적으로 0! 과 1! 의 값이 1로 같다는 성질을 이용하여 n이 1 이하가 되었을때에 함수를 종료하는 재귀함수의 형태로 구현할 수 있습니다.  </p>\n<p>이를 코드로 구현하면 아래와 같습니다.</p>\n<p><a href=\"https://www.acmicpc.net/problem/10872\">백준 온라인 저지 10872번 문제 - 팩토리얼</a></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">IOException</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*\n    백준 10872 문제 - 팩토리얼\n*/</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">IOException</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">BufferedReader</span> br <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>br<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> n <span class=\"token operator\">*</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>사실, 팩토리얼 문제는 대표적인 재귀 함수의 예시지만 반복문으로도 구현이 가능합니다.</p>\n<p>그렇다면 반복문 대신에 재귀 함수를 사용했을 때의 장점은 무엇일까요?</p>\n<h4 id=\"4-재귀-함수의-장단점\"><a href=\"#4-재귀-함수의-장단점\" class=\"headerlink\" title=\"4. 재귀 함수의 장단점\"></a>4. 재귀 함수의 장단점</h4><h5 id=\"4-1-장점\"><a href=\"#4-1-장점\" class=\"headerlink\" title=\"4-1 장점\"></a>4-1 장점</h5><p>재귀 함수의 가장 큰 장점은 <strong>코드가 더 간결해진다</strong>라는 것입니다.</p>\n<p>코드가 간결해지는 이유는 재귀 함수가 수학의 <strong>점화식(재귀식)</strong> 을 그대로 코드로 변경한 것이기 때문입니다.</p>\n<p>수열의 일반항으로서 수열을 정의하는 것이 아니라 이웃하는 항들과의 관계식으로서 수열을 정의하는 것을 수열의 귀납적 정의라 하며 수학에서 <strong>점화식(재귀식)은 수열에서 이웃하는 두개의 항 사이에 성립하는 관계를 나타난 관계식</strong>을 의미합니다.<br>(이 개념은 후에 배울 다이나믹 프로그래밍으로 이어집니다.)</p>\n<p>팩토리얼을 수학적 점화식으로 표현해보면 다음과 같습니다</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>n이 0이거나 1일 때 : factorial(n) = 1</li>\n<li>n이 1보다 클 경우 : factorial(n) = n * factorial(n-1)</li>\n</ul></blockquote>\n<p>이런 식으로 점화식을 정리해두면, 종료 조건을 쉽게 찾을 수 있습니다. 여기에서 종료조건은 n이 0이거나 1일 때 입니다.<br>이 경우를 고려하지 않으면, 재귀함수는 무한히 반복되고 결과를 출력할 수 없을 것입니다.<br>또한 n이 음수가 들어왔을 때에는 입력 범위 오류이므로, 오류 메시지를 띄워야합니다. </p>\n<p>이러한 속성 때문에 재귀 함수의 구현은 반복문보다 쉽습니다. 그러나, 몇 가지 단점 때문에 재귀 함수를 이용하기보다는 반복문의 사용이 권장되고 있는데, 그러한 단점은 다음과 같습니다.</p>\n<h5 id=\"4-2-단점\"><a href=\"#4-2-단점\" class=\"headerlink\" title=\"4-2 단점\"></a>4-2 단점</h5><p>단점은 크게 2가지 입니다.</p>\n<p>첫 번째, 재귀 함수는 호출될 때마다 call stack에 쌓이기 때문에 한계치 이상으로 호출되면 <strong>StackOverflow</strong>가 발생합니다.<br>두 번째, 또한 재귀 함수와 반복문의 실행 시간을 비교해보면, <strong>재귀 함수가 반복문보다 느린 것</strong>을 보실 수 있습니다.</p>\n<p>에러를 발생시킬 수 있다는 점과 속도가 느리다는 점은 매우 큰 단점이므로 반복문의 사용이 훨씬 유용하게 느껴지실겁니다.</p>\n<p>하지만 그럼에도 저희는 재귀 함수를 사용합니다. 그럼 과연 어떨 때에 재귀 함수를 사용해야할까요?</p>\n<h4 id=\"5-재귀-함수를-사용해야하는-경우\"><a href=\"#5-재귀-함수를-사용해야하는-경우\" class=\"headerlink\" title=\"5. 재귀 함수를 사용해야하는 경우\"></a>5. 재귀 함수를 사용해야하는 경우</h4><p>재귀 함수를 사용해야하는 경우는 아래와 같습니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>알고리즘 자체가 재귀적인 표현이 자연스러운 경우</li>\n<li>변수 사용을 줄일 필요가 있을 때</li>\n</ul></blockquote>\n<p>여기서 변수 사용을 줄인다는 것은 변수가 잡아 먹는 메모리에 대한 이야기가 아니라, <strong>mutable state(변경 가능한 상태) 를 제거하여 프로그램 오류가 발생할 수 있는 가능성을 줄이는 것</strong>을 의미합니다. 단순한 경우에는 오히려 재귀호출이 직관적으로 이해하기 어려울 수도 있지만, 프로그램이 복잡해지면 mutable state를 최대한 피하는 것이 오류 없는 프로그램을 짜는 데에 중요한 원칙이 됩니다. mutable state 를 최대한 피하는 것은 변수의 수를 줄이는 것과 변수가 가질 수 있는 값의 종류 또는 범위를 정확히 제한하는 것입니다.</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">Mutable State</p>\n<p>가변적인 전역변수를 의미하며 아래와 같은 단점이 존재합니다.</p>\n<ul>\n<li>상태를 변경할 수 있는 영역이 넓어질수록 특정 시점의 변수 값을 예측하기 어렵습니다.</li>\n<li>위의 이유로 테스트하기 어렵습니다.</li>\n<li>실행 순서에 따라 의도찮은 동작을 하거나, 데드락(Dead Lock)이 걸릴 가능성이 있습니다.</li>\n</ul>\n\n</div>\n<p>때문에, 구현해야하는 코드가 위의 이유에 해당이 된다면 재귀 함수의 사용을 고려해야합니다.</p>\n<hr>\n<p>여기까지, 재귀함수 정의와 동작 방식, 그리고 장점과 단점에 대해서 이야기해보았습니다.<br>다음 시간에는 DFS(Depth-First Srarch) 와 BFS(Breadth First Search)에 대해 정리해보도록 하겠습니다!</p>\n<hr>\n<p><strong>레퍼런스</strong></p>\n<ol>\n<li><a href=\"http://www.yes24.com/Product/Goods/91433923\">이것이 취업을 위한 코딩테스트다 with 파이썬</a>  </li>\n<li><a href=\"https://ko.wikipedia.org/wiki/%EC%A0%90%ED%99%94%EC%8B%9D\">위키피디아:점화식</a>  </li>\n<li><a href=\"https://wonillism.tistory.com/17\">[Algorithm - Theory]반복문과 재귀함수의 차이</a>  </li>\n<li><a href=\"https://blog.naver.com/m1nna/222341390722\">재귀 함수(Recursive Function)</a>  </li>\n<li><a href=\"https://kjwsx23.tistory.com/295\">[JS] state와 mutable, immutable</a></li>\n</ol>\n","feature":true,"text":"DFS(Depth-First Srarch) 및 BFS(Breadth First Search)에 대해 정리하다보니, 이를 이해하기 위해서는 그래프, 스택, 재귀 함수에 대한 이해가 필요하다는 것을 알게 되었습니다. 그래프와 스택은 이전에 정리해두었으니,...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"알고리즘","slug":"알고리즘","count":5,"path":"api/categories/알고리즘.json"}],"tags":[{"name":"algorithm","slug":"algorithm","count":6,"path":"api/tags/algorithm.json"},{"name":"Recursive Function","slug":"Recursive-Function","count":1,"path":"api/tags/Recursive-Function.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%EC%9E%AC%EA%B7%80-%ED%95%A8%EC%88%98-Recursive-Function\"><span class=\"toc-text\">재귀 함수(Recursive Function)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%EC%A0%95%EC%9D%98\"><span class=\"toc-text\">1. 정의</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\"><span class=\"toc-text\">2. 재귀함수의 동작 방식</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%EC%98%88%EC%8B%9C-%ED%8C%A9%ED%86%A0%EB%A6%AC%EC%96%BC-Factorial\"><span class=\"toc-text\">3. 예시 - 팩토리얼(Factorial)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%EC%9E%AC%EA%B7%80-%ED%95%A8%EC%88%98%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\"><span class=\"toc-text\">4. 재귀 함수의 장단점</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-%EC%9E%A5%EC%A0%90\"><span class=\"toc-text\">4-1 장점</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-%EB%8B%A8%EC%A0%90\"><span class=\"toc-text\">4-2 단점</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%EC%9E%AC%EA%B7%80-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\"><span class=\"toc-text\">5. 재귀 함수를 사용해야하는 경우</span></a></li></ol></li></ol>","author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"mapped":true,"prev_post":{"title":"10. 머스테치(mustache)로 화면 구성하기","uid":"6cbdd4fd25742628092b5aa717b3e98a","slug":"springboot-web-11","date":"2021-07-21T07:37:52.000Z","updated":"2021-07-21T08:41:05.304Z","comments":true,"path":"api/articles/springboot-web-11.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/main.png","text":"이번 포스트는 머스테치를 이용한 프론트 엔드 개발을 설명하겠습니다. 머스테치(mustache)로 화면 구성하기10-1 템플릿 엔진(Template Engine)이란?템플릿 엔진(Template Engine)이란, 지정된 템플릿 양식과 특정 데이터 모델...","link":"","photos":[],"count_time":{"symbolsCount":"4.8k","symbolsTime":"4 mins."},"categories":[{"name":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","slug":"스프링-부트와-AWS로-혼자-구현하는-웹-서비스","count":11,"path":"api/categories/스프링-부트와-AWS로-혼자-구현하는-웹-서비스.json"}],"tags":[{"name":"springBoot","slug":"springBoot","count":11,"path":"api/tags/springBoot.json"},{"name":"Java","slug":"Java","count":9,"path":"api/tags/Java.json"},{"name":"JPA Auditing","slug":"JPA-Auditing","count":2,"path":"api/tags/JPA-Auditing.json"}],"author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"feature":true},"next_post":{"title":"3. 비선형구조 - 그래프(Graph)","uid":"20b86973dc8825e5a6ade1bddd196184","slug":"cs-graph","date":"2021-07-11T07:24:05.000Z","updated":"2021-08-09T13:58:07.798Z","comments":true,"path":"api/articles/cs-graph.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/computer_science.jpeg","text":"이번 포스트는 비선형구조 중 하나인 그래프(Graph)에 대해 정리해보도록하겠습니다. 비선형구조 - 그래프(Graph)그래프(Graph)는 정점(vertex)과 간선(edge)으로 이루어진 자료구조이자 연결되어 있는 데이터 간의 관계를 표현하기 위한 ...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Computer Science","slug":"Computer-Science","count":3,"path":"api/categories/Computer-Science.json"}],"tags":[{"name":"Nonlinear structure","slug":"Nonlinear-structure","count":1,"path":"api/tags/Nonlinear-structure.json"},{"name":"Graph","slug":"Graph","count":1,"path":"api/tags/Graph.json"}],"author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"feature":true}}