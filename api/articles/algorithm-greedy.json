{"title":"2. 탐욕 알고리즘(Greedy Algorithm)","uid":"4db30505bd3613ad654d9a53e43df5c4","slug":"algorithm-greedy","date":"2021-06-13T01:27:11.000Z","updated":"2021-06-14T04:27:10.318Z","comments":true,"path":"api/articles/algorithm-greedy.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/algorithm.jpeg","content":"<p>이번 포스트에서는 탐욕 알고리즘(Greedy Algorithm)에 대해서 정리하겠습니다.<br>사실 코딩 테스트에서 탐욕 알고리즘은 출제 빈도가 낮은 편에 속합니다.(프로그래머스 기준)<br>그럼에도 탐욕 알고리즘을 정리하는 이유는 이를 공부하다보면 알고리즘 문제의 원리를 깨닫는 능력을 향상시키는 데에 도움이 될 것이라 생각했기 때문입니다.<br>즉, 탐욕 알고리즘의 정리를 통해 문제가 요구하는 최소한의 원리를 떠올릴 수 있는 능력을 키워보려 합니다.</p>\n<h3 id=\"탐욕-알고리즘-Greedy-Algorithm\"><a href=\"#탐욕-알고리즘-Greedy-Algorithm\" class=\"headerlink\" title=\"탐욕 알고리즘 (Greedy Algorithm)\"></a>탐욕 알고리즘 (Greedy Algorithm)</h3><h4 id=\"1-정의\"><a href=\"#1-정의\" class=\"headerlink\" title=\"1. 정의\"></a>1. 정의</h4><p>탐욕 알고리즘(Greedy Algorithm)은 <strong>매 순간 가장 좋아보이는 최적의 선택</strong>을 하는 방법으로 진행하여 최종적인 해답에 도달하는 방식입니다.<br>Greedy라는 단어는 “탐욕”이라는 뜻을 가지므로 국내에서는 탐욕 알고리즘으로 불립니다. (이하 탐욕 알고리즘)</p>\n<p>그리디 알고리즘은 가장 좋아보이는 것이라는 기준이 존재하므로 문제에서 “가장 큰 순서대로”, “가장 작은 순서대로”와 같은 기준을 알게 모르게 제시해줍니다.<br>때문에 그리디 알고리즘은 정렬 알고리즘과 짝을 이뤄 출제되는 경우가 많습니다.</p>\n<h4 id=\"2-문제\"><a href=\"#2-문제\" class=\"headerlink\" title=\"2. 문제\"></a>2. 문제</h4><p>탐욕 알고리즘의 가장 유명한 예시는 <strong>동전</strong> 문제 입니다.<br>거스름 돈 문제를 예를 들어 탐욕 알고리즘을 설명하겠습니다.<br>(아래의 문제는 나동빈님의 저서 <a href=\"http://www.yes24.com/Product/Goods/91433923\">「이것이 취직을 위한 코딩 테스트다 with 파이썬」</a>에서 발췌한 문제입니다)</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">거스름 돈</p>\n<p>당신은 계산을 도와주는 점원입니다.<br>카운터에는 거스름돈으로 사용할 <em>500원, 100원, 50원, 10원짜리 동전</em>이 무한히 존재합니다.<br>손님에게 <em>거슬러주어야할 돈이 N원</em>일 때, 거슬러 줘야 할 동전의 <em>최소 개수</em>는 몇 개인가요?<br>단, 거슬러 줘야할 돈 N은 항상 10의 배수입니다.</p>\n</div>\n<p>동전의 개수를 최소화 하는 것이 이 알고리즘의 목적입니다.<br>그럼 동전의 개수를 최소화 하기 위해서는 어떻게 해야할까요?<br>생각을 잘 정리해봅시다. 저는 아래와 같이 생각이 흘러갔습니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>동전의 종류를 살펴보면, 500원은 100원을 5개 모아야하고, 50원은 10원을 5개 모아야 한다.  </li>\n<li>동전이 여러 개 모이면 큰 금액의 동전이 된다.  </li>\n<li>동전의 개수를 줄이기 위해서는 큰 금액의 동전을 먼저 사용하는 것이 유리하다.</li>\n</ol></blockquote>\n<p>저는 이런식으로 <strong>“가장 큰 화폐 단위부터 돈을 거슬러주어야 동전의 개수가 최소화된다”</strong> 라는 생각을 유추해냈습니다.<br>그럼 이 생각을 코드로 짜기위해서 어떻게 해야할지 고민해보겠습니다. (자바 기준 서술)</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li>동전 종류를 담는 배열에 동전의 금액이 큰 것부터 내림차순으로 선언한다.</li>\n<li>동전의 개수를 셀 변수를 선언한다.</li>\n<li>동전의 종류를 돌면서 거슬러줄 수 있는 만큼 거슬러주고, 그만큼을 동전의 개수에 추가한다.</li>\n<li>거슬러준 금액을 원래의 금액에서 차감한다.</li>\n</ol></blockquote>\n<p>이것이 제가 생각한 알고리즘의 흐름이고, 이것을 자바로 표현하면 아래와 같습니다.</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> <span class=\"token number\">1260</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> coins <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">500</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> coin_count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> coins<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">int</span> coin <span class=\"token operator\">=</span> n <span class=\"token operator\">/</span> coins<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            coin_count <span class=\"token operator\">+=</span> coin<span class=\"token punctuation\">;</span>\n            n <span class=\"token operator\">-=</span> <span class=\"token punctuation\">(</span>coin <span class=\"token operator\">*</span> coins<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>coin_count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"3-주의점-1-탐욕-알고리즘이-아닐-가능성\"><a href=\"#3-주의점-1-탐욕-알고리즘이-아닐-가능성\" class=\"headerlink\" title=\"3. 주의점-1 : 탐욕 알고리즘이 아닐 가능성\"></a>3. 주의점-1 : 탐욕 알고리즘이 아닐 가능성</h4><p>탐욕 알고리즘은 탐욕적으로 문제에 접근했을 때, 정확한 답을 찾을 수 있다는 보장이 있을 때에는 매우 효과적이고 직관적입니다.<br>위의 문제를 그리디 알고리즘으로 해결할 수 있는 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 <strong>배수</strong>이므로 <strong>작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문</strong>입니다.<br>즉, 큰 단위가 작은 단위의 배수 형태이기에 큰 동전부터 거슬러주고, 작은 동전을 거슬러준다는 말이 성립되는 겁니다. </p>\n<p>예를 들어 만들어야 하는 금액이 800원이고, 화폐의 단위가 100원, 400원, 500원이라면 그리디 알고리즘은 500원 1개과 100원 3개의 조합을 생각해낼 것입니다.<br>그러나 가장 효과적인 조합은 400원짜리 2개입니다.<br>때문에 화폐의 배열이 무작위인 경우, 그리디 알고리즘으로는 해결할 수 없으니 주의할 필요가 있습니다.</p>\n<h4 id=\"4-주의점-2-탐욕-알고리즘은-결과가-전체적으로-최적이-아닐-가능성\"><a href=\"#4-주의점-2-탐욕-알고리즘은-결과가-전체적으로-최적이-아닐-가능성\" class=\"headerlink\" title=\"4. 주의점-2 : 탐욕 알고리즘은 결과가 전체적으로 최적이 아닐 가능성\"></a>4. 주의점-2 : 탐욕 알고리즘은 결과가 전체적으로 최적이 아닐 가능성</h4><p>탐욕 알고리즘은 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않습니다.<br>때문에 선택의 순간마다 하는 선택은 최적이지만, 이것이 전체적으로 최적이라는 보장은 없습니다. </p>\n<p>그러나 어떤 특별한 구조가 있는 문제에 대해서는 탐욕 알고리즘이 언제나 최적해를 찾아낼 수 있는데 이 구조를 <a href=\"https://ko.wikipedia.org/wiki/%EB%A7%A4%ED%8A%B8%EB%A1%9C%EC%9D%B4%EB%93%9C\">매트로이드</a>라고 합니다.</p>\n<hr>\n<p>지금까지 탐욕 알고리즘의 정의와 기본 원리에 대해서 알아보았습니다.<br>탐욕 알고리즘에서 중요한 것은 아래의 두 가지 입니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ul>\n<li>문제가 요구하는 최소한의 원리를 알아낼 수 있는가</li>\n<li>이것이 탐욕 알고리즘이라는 확신이 있는가</li>\n</ul></blockquote>\n<p>이 두 가지를 가슴에 새기고, 다양한 문제를 풀어보며 감을 익혀가도록 합시다.<br>탐욕 알고리즘에 관해서는 여기까지 적도록 하겠습니다.</p>\n","feature":true,"text":"이번 포스트에서는 탐욕 알고리즘(Greedy Algorithm)에 대해서 정리하겠습니다.사실 코딩 테스트에서 탐욕 알고리즘은 출제 빈도가 낮은 편에 속합니다.(프로그래머스 기준)그럼에도 탐욕 알고리즘을 정리하는 이유는 이를 공부하다보면 알고리즘 문제의...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"알고리즘 & 코딩 테스트","slug":"알고리즘-코딩-테스트","count":3,"path":"api/categories/알고리즘-코딩-테스트.json"}],"tags":[{"name":"algorithm","slug":"algorithm","count":3,"path":"api/tags/algorithm.json"},{"name":"Greedy","slug":"Greedy","count":1,"path":"api/tags/Greedy.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%ED%83%90%EC%9A%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Greedy-Algorithm\"><span class=\"toc-text\">탐욕 알고리즘 (Greedy Algorithm)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%EC%A0%95%EC%9D%98\"><span class=\"toc-text\">1. 정의</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%EB%AC%B8%EC%A0%9C\"><span class=\"toc-text\">2. 문제</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%EC%A3%BC%EC%9D%98%EC%A0%90-1-%ED%83%90%EC%9A%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4-%EC%95%84%EB%8B%90-%EA%B0%80%EB%8A%A5%EC%84%B1\"><span class=\"toc-text\">3. 주의점-1 : 탐욕 알고리즘이 아닐 가능성</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%EC%A3%BC%EC%9D%98%EC%A0%90-2-%ED%83%90%EC%9A%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%80-%EA%B2%B0%EA%B3%BC%EA%B0%80-%EC%A0%84%EC%B2%B4%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%B5%9C%EC%A0%81%EC%9D%B4-%EC%95%84%EB%8B%90-%EA%B0%80%EB%8A%A5%EC%84%B1\"><span class=\"toc-text\">4. 주의점-2 : 탐욕 알고리즘은 결과가 전체적으로 최적이 아닐 가능성</span></a></li></ol></li></ol>","author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"mapped":true,"prev_post":{"title":"4. 프로젝트 설정 확인과 롬복(Lombok)","uid":"4f4324f9c57576ee9b59f6532264f460","slug":"springboot-web-5","date":"2021-06-14T03:18:58.000Z","updated":"2021-06-16T14:02:36.053Z","comments":true,"path":"api/articles/springboot-web-5.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/main.png","text":"이 포스트에서는 롬복을 소개하고 프로젝트에 롬복을 추가하여 사용해보도록 하겠습니다. 롬복(Lombok)자바 개발자들의 필수 라이브러리 롬복(Lombok)은 어노테이션 기반으로 코드를 자동완성 해주는 라이브러리입니다.롬복을 이용하면 생성자 및 Gette...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","slug":"스프링-부트와-AWS로-혼자-구현하는-웹-서비스","count":6,"path":"api/categories/스프링-부트와-AWS로-혼자-구현하는-웹-서비스.json"}],"tags":[{"name":"springBoot","slug":"springBoot","count":6,"path":"api/tags/springBoot.json"},{"name":"java","slug":"java","count":2,"path":"api/tags/java.json"},{"name":"Lombok","slug":"Lombok","count":2,"path":"api/tags/Lombok.json"}],"author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"feature":true},"next_post":{"title":"1. 알고리즘의 복잡도","uid":"d6a03e07ef9853873ef42e3c7ea6ee4a","slug":"algorithm-complexity","date":"2021-06-12T12:42:51.000Z","updated":"2021-06-12T15:14:41.339Z","comments":true,"path":"api/articles/algorithm-complexity.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/algorithm.jpeg","text":"프로그래밍 공부를 하는 사람이라면 “복잡도(Complexity)”라는 단어를 한 번 쯤은 들어봤을겁니다.그런데 이게 대~충은 알 것 같은데 막상 누군가에게 복잡도에 대해서 설명하려고 하면 설명하기 어려운 경우가 많습니다.때문에 이 포스트에서는 알고리즘...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"알고리즘 & 코딩 테스트","slug":"알고리즘-코딩-테스트","count":3,"path":"api/categories/알고리즘-코딩-테스트.json"}],"tags":[{"name":"algorithm","slug":"algorithm","count":3,"path":"api/tags/algorithm.json"},{"name":"complexity","slug":"complexity","count":1,"path":"api/tags/complexity.json"}],"author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"feature":true}}