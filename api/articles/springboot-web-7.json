{"title":"6. JPA, Hibernate, Spring Data JPA","uid":"d93904bd8ecb573f2b3f624285e3ea2a","slug":"springboot-web-7","date":"2021-06-23T07:43:58.000Z","updated":"2021-06-25T03:47:49.918Z","comments":true,"path":"api/articles/springboot-web-7.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/main.png","content":"<p>과거에 스프링 프로젝트를 진행할 때에는 오라클 DB에 Mybatis를 사용했었습니다.<br>때문에 이 책에서도 데이터베이스를 다루는 SQL mapper를 Mybatis로 사용할 것이라 추측했습니다.<br>그러나 이 책에서 데이터베이스는 JPA를 통해 관리됩니다.  </p>\n<p>여기서 저자는 Mybatis를 사용하지 않는 이유를 <strong>실제로 개발하는 시간보다 SQL을 다루는 시간이 더 많기 때문</strong>이라고 서술하고 있는데, 생각해보니 저도 예전에 프로젝트를 작업할 때 프로젝트 자체보다는 SQL때문에 고통받던 시간이 길었던 것 같습니다.  </p>\n<p>하지만, JPA가 아무리 좋다고해도 JPA가 무엇이고, 왜 이것을 사용하는지, 어떤 부분에서 Mybatis보다 유용한지 알지 못한채로 사용하는 것은 의미가 없는 일이므로, JPA에 대해 정리해보는 시간을 갖겠습니다.</p>\n<h3 id=\"JPA-Java-Persistence-API\"><a href=\"#JPA-Java-Persistence-API\" class=\"headerlink\" title=\"JPA(Java Persistence API)\"></a>JPA(Java Persistence API)</h3><h4 id=\"1-JPA의-정의\"><a href=\"#1-JPA의-정의\" class=\"headerlink\" title=\"1. JPA의 정의\"></a>1. JPA의 정의</h4><p>현대 웹 애플리케이션에서 <strong>관계형 데이터베이스(RDB;Relational Database)에서 객체를 관리하는 것</strong>은 중요합니다. 때문에 여러가지의 방식이 고려되고 있는데, 최근 많이 이용되는 방식으로 <strong>JPA</strong>가 있습니다. </p>\n<p>JPA는 자바 어플리케이션에서 관계형 데이터베이스를 관리하는 방식을 정의한 <strong>인터페이스</strong>이자 <strong>자바 표준 ORM(Object Relational Mapping)</strong> 기술입니다.</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">SQL mapping <strong>vs</strong> JPA(ORM)</p>\n<ul>\n<li>SQL mapping<br>: <strong>query</strong>를 맵핑하여 직접 DB를 조작합니다.<br>: SQL - mapping - Object</li>\n<li>JPA(ORM; Object Relational Mapping)<br>: <strong>객체</strong>와 DB의 데이터를 맵핑하여 메서드로 데이터를 조작합니다.<br>: DB data - mapping - Object</li>\n</ul>\n\n</div>\n<h4 id=\"2-JPA-사용-이유\"><a href=\"#2-JPA-사용-이유\" class=\"headerlink\" title=\"2. JPA 사용 이유\"></a>2. JPA 사용 이유</h4><p>JPA를 사용하는 이유는 크게 <strong>두 가지</strong>가 있습니다.</p>\n<h5 id=\"2-1-생산성을-높이기-위해\"><a href=\"#2-1-생산성을-높이기-위해\" class=\"headerlink\" title=\"2-1 생산성을 높이기 위해\"></a>2-1 생산성을 높이기 위해</h5><p>관계형 데이터베이스에서 가장 중요한 개념은 SQL인데, 이는 관계형 데이터베이스가 SQL만을 인식할 수 있기 때문입니다. 이러한 이유로 개발자들은 각 테이블마다 기본적인 CRUD(Create/Read/Update/Delete) SQL을 매번 생성해주어야합니다.  </p>\n<p>이러한 특성 탓에 개발자가 아무리 자바 클래스를 아름답게 설계해도, SQL을 통해야만 데이터베이스에 저장하고 조회할 수 있습니다. 문제는 프로젝트에 테이블이 한 개만 존재하지 않는다는 점입니다. 때문에 유사한 SQL이 반복됨에 따라 <code>자바객체를 SQL</code>로 <code>SQL 객체를 자바 객체</code>로 변환하는 과정 또한 반복됩니다. </p>\n<p>또한 프로젝트의 내용을 수정할 때마다 SQL도 수정해야하는 번거로움이 있습니다. 이러한 상황은 <strong>생산성과 유지보수에 나쁜 영향</strong>을 미치게 됩니다.</p>\n<p>JPA는 위의 서술한 것처럼 쿼리를 직접 작성하는 것이 아니라, 만들어진 객체로 데이터 베이스를 다루게 됩니다.<br>때문에 <strong>객체중심의 개발</strong>이 가능하다는 장점이 있습니다.</p>\n<h5 id=\"2-2-패러다임의-불일치를-해소하기-위해\"><a href=\"#2-2-패러다임의-불일치를-해소하기-위해\" class=\"headerlink\" title=\"2-2 패러다임의 불일치를 해소하기 위해\"></a>2-2 패러다임의 불일치를 해소하기 위해</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>- 관계형 데이터베이스</strong>는 어떻게 데이터를 저장할지에 초점이 맞춰진 기술 입니다.<br><strong>- 객체지향 프로그래밍 언어</strong>는 메시지를 기반으로 기능과 속성을 한 곳에서 관리하는 기술입니다.</p></blockquote>\n<p>한 눈에 봐도 목적과 사상이 다른데, 관계형 데이터베이스로 객체지향 언어를 표현할 수 있을까요?</p>\n<p>쉽지 않을겁니다. 관계형 데이터베이스와 객체지향 프로그래밍 언어의 패러다임이 서로 다른데, 객체를 데이터베이스에 저장하려고하니 문제가 발생합니다. 이를 <strong>패러다임의 불일치</strong>라고합니다.</p>\n<p>객체지향 프로그래밍 언어의 상속관계를 예로 들어보겠습니다.</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> <span class=\"token function\">findUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Group</span> group <span class=\"token operator\">=</span> user<span class=\"token punctuation\">.</span><span class=\"token function\">getGroup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>위의 코드를 보면 User와 Group은 부모-자식 관계임을 알 수 있습니다. User가 본인이 속한 Group의 정보를 가져오는 코드이기 때문입니다.<br>그리고 이 코드에 데이터베이스가 추가되면 다음과 같습니다</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">User</span> user <span class=\"token operator\">=</span> userDao<span class=\"token punctuation\">.</span><span class=\"token function\">findUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Group</span> group <span class=\"token operator\">=</span> <span class=\"token class-name\"><span class=\"token namespace\">groupDao<span class=\"token punctuation\">.</span></span>FindGroup</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span><span class=\"token function\">getGroupId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>이렇게되면 User와 Group은 각자 따로 조회하게 됩니다. 즉, 상속이나 1:N등 다양한 객체 모델링을  데이터베이스로 구현할 수 없습니다.<br>이러다보니 결국 Object를 SQL로 작성해야하고, 이 과정에서 <code>Object &gt; SQL 변환 &gt; RDB에 저장</code>하는 과정을 반복하게 됩니다.</p>\n<p>이는 개발자가 개발에 쓰는 시간보다 SQL 매핑작업에 시간을 쓰는 원인이 됩니다.</p>\n<p>결과적으로 JPA는 <strong>서로 지향하는 바가 다른 2개의 영역을 중간에서 조율해주고 패러다임을 일치시켜주기 위한 기술</strong>입니다. 개발자는 객체지향적으로 프로그래밍을 하고, JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성해서 실행합니다. 이로인해 개발자는 SQL에 종속적인 개발을 하지 않아도 됩니다.</p>\n<h4 id=\"3-JPA-구현체-Hibernate\"><a href=\"#3-JPA-구현체-Hibernate\" class=\"headerlink\" title=\"3. JPA 구현체 - Hibernate\"></a>3. JPA 구현체 - Hibernate</h4><p>이 항목에서는 JPA 구현체에 대해 이야기해보겠습니다. 이 카테고리를 적는 이유는, JPA와 Hibernate(JPA의 구현체), Spring Data JPA의 차이점이 뭔지, 왜 사용하는지에 대해 헷갈리기 때문입니다</p>\n<h5 id=\"3-1-Hibernate\"><a href=\"#3-1-Hibernate\" class=\"headerlink\" title=\"3-1 Hibernate\"></a>3-1 Hibernate</h5><p>Hibernate는 JPA의 구현체입니다. 즉, JPA가 가진 인터페이스를 직접 구현한 라이브러리입니다. 이 정의에서 가장 중요한 것은 JPA를 사용하기 위해서 반드시 Hibernate를 사용할 필요가 없다는 것입니다. Hibernate를 사용하지 않더라도 직접 구현해서 사용하면 될테니까요.  </p>\n<p>때문에 Spring에서 JPA를 사용할 때에도 이 구현체들을 직접 다루지는 않습니다. 우리는 구현체들을 좀 더 쉽게 사용하기 위해서 추상화시킨 <strong>Spring Data JPA</strong>라는 모듈을 사용할 것입니다.</p>\n<h4 id=\"4-Spring-Data-JPA\"><a href=\"#4-Spring-Data-JPA\" class=\"headerlink\" title=\"4. Spring Data JPA\"></a>4. Spring Data JPA</h4><p>Spring Data JPA는 JPA를 쓰기 편하게 만들어놓은 <strong>모듈</strong>입니다.<br>JPA와 Hibernate(구현체), 그리고 Spring Data JPA의 관계를 설명하자면 다음과 같습니다.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>[그림7-1] JPA, Hibernate, and Spring Data JPA의 관계<br><img src=\"./springboot-web-7/1-JPA_Hibernate_SpringDataJPA.png\" alt=\"JPA, Hibernate, and Spring Data JPA\"><br>간단하게 이야기하자면 JPA의 구현체가 Hibernate, 이를 한단계 더 감싸놓은것이 Spring Data JPA입니다.</p>\n<ul>\n<li>레퍼런스 : <a href=\"https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html\">Hibernate ORM 5.4.32.Final User Guide</a></li>\n</ul></blockquote>\n<p>사실, Hibernate를 사용하건 Spring Data JPA를 사용하건 기능 상에 유의미한 차이는 없습니다.<br>그럼에도 불구하고 Spring 제작팀은 <strong>Spring Data JPA를 사용하는 것을 권장</strong>하고 있는데 그 이유는 아래와 같습니다  </p>\n<h5 id=\"4-1-구현체-교체의-용이성\"><a href=\"#4-1-구현체-교체의-용이성\" class=\"headerlink\" title=\"4-1 구현체 교체의 용이성\"></a>4-1 구현체 교체의 용이성</h5><p>구현체 교체의 용이성은 <strong>현재 사용중인 구현체 외에 다른 구현체로 쉽게 교체하기 쉬운 특성</strong>을 의미합니다.  </p>\n<p>현재는 Hibernate가 상당히 잘 만들어지고 성숙된 구현체이므로 바꿀 필요가 없지만, 수명을 다해서 새로운 JPA 구현체가 대세로 떠올라 새로운 구현체로 교체해야하는 상황이라 가정해봅시다.  </p>\n<p>이렇게되면 어쩔 수 없이 구현체를 교체해야 할 필요성이 생기는데, Spring Data JPA를 사용한 프로젝트라면 <strong>내부에서 구현체 매핑을 지원</strong>해주기 때문에 아주 쉽게 교체가 가능합니다.</p>\n<h5 id=\"4-2-저장소-교체의-용이성\"><a href=\"#4-2-저장소-교체의-용이성\" class=\"headerlink\" title=\"4-2 저장소 교체의 용이성\"></a>4-2 저장소 교체의 용이성</h5><p>저장소 교체의 용이성은 <strong>관계형 데이터베이스 외에 다른 DB로 쉽게 교체할 수 있는 특성</strong>을 의미합니다.  </p>\n<p>예를 들어, 관계형 데이터베이스로 구성된 하나의 프로젝트를 생각해봅시다.  </p>\n<p>지금은 관계형 데이터베이스로도 충분히 서비스가 가능한 수준이지만, 프로젝트가 성장하고 커져감에 따라 트래픽이 많아져 관계형 데이터베이스로는 도저히 감당이 안될 상황이 생겼습니다. 이에 대한 대책으로 개발자들은 데이터베이스의 변경을 제안했고, MongoDB가 좋겠다는 결론에 도달합니다. 때문에 데이터베이스를 <code>관계형 데이터베이스</code>에서 <code>MongoDB</code>로 교체해야합니다.  </p>\n<p>이런 상황에서 프로젝트가 Spring Data JPA를 사용하여 구성되었다면, <code>Spring Data JPA</code>에서 <code>Spring Data MongoDB</code>로 <strong>의존성 교체</strong>만하면 저장소를 쉽게 교체할 수 있습니다. 게다가 사용하는 메서드나 기능은 대체로 비슷하기때문에 코드를 수정할 필요성도 없습니다.</p>\n<p>이러한 특성 때문에 Spring 제작팀은 구현체를 직접 사용하는 것 보다 Spring Data를 사용하는 것을 권하고 있습니다.</p>\n<hr>\n<p>이번 포스트에서는 JPA를 사용하는 이유. 그리고 hibernate와 Spring Data JPA는 무엇인지 살펴보았습니다.<br>다음 포스트에서는 이를 직접 스프링 프로젝트에 적용해보도록 하겠습니다.</p>\n<hr>\n<p>레퍼런스  </p>\n<ol>\n<li><a href=\"https://suhwan.dev/2019/02/24/jpa-vs-hibernate-vs-spring-data-jpa/\">JPA, Hibernate, 그리고 Spring Data JPA의 차이점</a>  </li>\n<li><a href=\"https://velog.io/@adam2/JPA%EB%8A%94-%EB%8F%84%EB%8D%B0%EC%B2%B4-%EB%AD%98%EA%B9%8C-orm-%EC%98%81%EC%86%8D%EC%84%B1-hibernate-spring-data-jpa\">JPA는 도대체 뭘까? (orm, 영속성, hibernate, spring-data-jpa)</a></li>\n</ol>\n","feature":true,"text":"과거에 스프링 프로젝트를 진행할 때에는 오라클 DB에 Mybatis를 사용했었습니다.때문에 이 책에서도 데이터베이스를 다루는 SQL mapper를 Mybatis로 사용할 것이라 추측했습니다.그러나 이 책에서 데이터베이스는 JPA를 통해 관리됩니다. 여...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","slug":"스프링-부트와-AWS로-혼자-구현하는-웹-서비스","count":7,"path":"api/categories/스프링-부트와-AWS로-혼자-구현하는-웹-서비스.json"}],"tags":[{"name":"springBoot","slug":"springBoot","count":7,"path":"api/tags/springBoot.json"},{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"JPA","slug":"JPA","count":1,"path":"api/tags/JPA.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JPA-Java-Persistence-API\"><span class=\"toc-text\">JPA(Java Persistence API)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-JPA%EC%9D%98-%EC%A0%95%EC%9D%98\"><span class=\"toc-text\">1. JPA의 정의</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-JPA-%EC%82%AC%EC%9A%A9-%EC%9D%B4%EC%9C%A0\"><span class=\"toc-text\">2. JPA 사용 이유</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-1-%EC%83%9D%EC%82%B0%EC%84%B1%EC%9D%84-%EB%86%92%EC%9D%B4%EA%B8%B0-%EC%9C%84%ED%95%B4\"><span class=\"toc-text\">2-1 생산성을 높이기 위해</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-2-%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84%EC%9D%98-%EB%B6%88%EC%9D%BC%EC%B9%98%EB%A5%BC-%ED%95%B4%EC%86%8C%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%B4\"><span class=\"toc-text\">2-2 패러다임의 불일치를 해소하기 위해</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-JPA-%EA%B5%AC%ED%98%84%EC%B2%B4-Hibernate\"><span class=\"toc-text\">3. JPA 구현체 - Hibernate</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-Hibernate\"><span class=\"toc-text\">3-1 Hibernate</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Spring-Data-JPA\"><span class=\"toc-text\">4. Spring Data JPA</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-%EA%B5%AC%ED%98%84%EC%B2%B4-%EA%B5%90%EC%B2%B4%EC%9D%98-%EC%9A%A9%EC%9D%B4%EC%84%B1\"><span class=\"toc-text\">4-1 구현체 교체의 용이성</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-%EC%A0%80%EC%9E%A5%EC%86%8C-%EA%B5%90%EC%B2%B4%EC%9D%98-%EC%9A%A9%EC%9D%B4%EC%84%B1\"><span class=\"toc-text\">4-2 저장소 교체의 용이성</span></a></li></ol></li></ol></li></ol>","author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"mapped":true,"prev_post":{},"next_post":{"title":"1. 자료 구조","uid":"a4c20de877725d90cf1ede9509e3fa58","slug":"cs-data-structure","date":"2021-06-23T05:05:59.000Z","updated":"2021-06-23T07:31:46.597Z","comments":true,"path":"api/articles/cs-data-structure.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/computer_science.jpeg","text":"오랜만에 집정리를 하던 도중, 정보처리기사 책을 발견했습니다.자격증을 딴 이후로 방치된 책인데 오랜만에 열어보니 덜 풀은 문제가 있더군요.문제를 다 푼 후에 버릴 심산으로 심심할 때마다 정보처리기사 문제를 풀게 되었습니다.그런데 의외로 정리해두면 좋을...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"Computer Science","slug":"Computer-Science","count":1,"path":"api/categories/Computer-Science.json"}],"tags":[{"name":"Computer Science","slug":"Computer-Science","count":1,"path":"api/tags/Computer-Science.json"},{"name":"Data Structure","slug":"Data-Structure","count":1,"path":"api/tags/Data-Structure.json"}],"author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"feature":true}}