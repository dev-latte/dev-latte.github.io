{"title":"1. 알고리즘의 복잡도","uid":"d6a03e07ef9853873ef42e3c7ea6ee4a","slug":"algorithm-complexity","date":"2021-06-12T12:42:51.000Z","updated":"2021-06-27T05:30:47.572Z","comments":true,"path":"api/articles/algorithm-complexity.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/algorithm.jpeg","content":"<p>프로그래밍 공부를 하는 사람이라면 “복잡도(Complexity)”라는 단어를 한 번 쯤은 들어봤을겁니다.<br>그런데 이게 대~충은 알 것 같은데 막상 누군가에게 복잡도에 대해서 설명하려고 하면 설명하기 어려운 경우가 많습니다.<br>때문에 이 포스트에서는 알고리즘과 관련된 개념을 정리하는 시간을 가져보려고 합니다.</p>\n<h3 id=\"1-복잡도-Complexity\"><a href=\"#1-복잡도-Complexity\" class=\"headerlink\" title=\"1. 복잡도(Complexity)\"></a>1. 복잡도(Complexity)</h3><p>복잡도는 알고리즘의 성능을 나타내는 척도로 문제를 해결하는 데에 알고리즘이 얼마나 복잡하게 문제를 해결하는 지를 나타냅니다. 복잡도는 크게 시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)로 구분됩니다.</p>\n<ul>\n<li>시간 복잡도 : 알고리즘이 어떤 문제를 해결하는 데에 걸리는 시간</li>\n<li>공간 복잡도 : 알고리즘이 어떤 문제를 해결하는 데에 차지하는 메모리</li>\n</ul>\n<p>즉, 시간 복잡도는 알고리즘의 수행시간을, 공간 복잡도는 알고리즘의 메모리 사용량을 나타냅니다.  </p>\n<p>동일한 기능을 수행하는 알고리즘이 있다면 일반적으로 <strong>복잡도가 낮을수록 좋은 알고리즘</strong>입니다.<br>복잡도를 표현할 때에는 빅오(Big-O)표기법을 사용하는데 이에 대한 자세한 내용은 아래에서 다루도록 하겠습니다.</p>\n<h4 id=\"1-1-시간-복잡도-Time-Complexity\"><a href=\"#1-1-시간-복잡도-Time-Complexity\" class=\"headerlink\" title=\"1-1 시간 복잡도(Time Complexity)\"></a>1-1 시간 복잡도(Time Complexity)</h4><p>시간 복잡도는 알고리즘이 문제를 해결하기 위한 <strong>연산의 횟수</strong>를 말합니다.<br>프로그램이 비효율적으로 작성되어 연산 횟수가 증가하는 경우, 시간 복잡도도 증가하게 됩니다.<br>알고리즘 문제에서 단순히 복잡도라고 하면, 보통 이 시간 복잡도를 의미합니다.  </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>보통 시간 복잡도에서의 “연산”은 프로그래밍 언어에서 지원하는 사칙 연산, 비교 연산 등과 같은 <strong>기본 연산</strong>을 의미합니다.</p></blockquote>\n<h4 id=\"1-2-공간-복잡도-Space-Complexity\"><a href=\"#1-2-공간-복잡도-Space-Complexity\" class=\"headerlink\" title=\"1-2 공간 복잡도(Space Complexity)\"></a>1-2 공간 복잡도(Space Complexity)</h4><p>공간 복잡도는 알고리즘의 동작을 위해 필요한 메모리의 양을 의미합니다.<br>최근에는 주기억장치인 RAM의 용량이 커져서 중요도가 낮아졌지만, 임베디드나 펌웨어 환경 등 하드웨어 환경이 매우 한정되어 있는 분야에서는 중요하게 고려되어야 합니다.</p>\n<p><strong>시간 복잡도와 공간 복잡도는 반비례하는 경향이 있습니다.</strong><br>최근에는 공간 복잡도보다 시간 복잡도를 더 중요하게 생각하므로 메모리를 더 많이 사용해서 실행 시간을 비약적으로 줄이기도 하는데 이러한 기법을 메모이제이션(memoization)이라고 합니다.</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">메모이제이션(memoization)</p>\n<p>컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술로, 동적 계획법의 핵심이 되는 기술입니다. <a href=\"https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98\">(출처 : 위키피디아 - 메모이제이션)</a></p>\n</div>\n<h3 id=\"2-빅오-표기법-Big-O\"><a href=\"#2-빅오-표기법-Big-O\" class=\"headerlink\" title=\"2. 빅오 표기법(Big-O)\"></a>2. 빅오 표기법(Big-O)</h3><p>빅오 표기법은 점근 표기법 중 하나로 최악의 경우를 우선적으로 고려하는 방식입니다.</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">점근 표기법(asymptotic notation)</p>\n<p>어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법으로 알고리즘의 복잡도를 단순화할 때나 무한급수의 뒷부분을 간소화할 때 사용됩니다. <a href=\"https://ko.wikipedia.org/wiki/%EC%A0%90%EA%B7%BC_%ED%91%9C%EA%B8%B0%EB%B2%95\">(출처 : 위키피디아 - 점근 표기법)</a></p>\n</div>\n<h4 id=\"2-1-시간-복잡도의-빅오-표기법\"><a href=\"#2-1-시간-복잡도의-빅오-표기법\" class=\"headerlink\" title=\"2-1 시간 복잡도의 빅오 표기법\"></a>2-1 시간 복잡도의 빅오 표기법</h4><p>시간 복잡도의 빅오 표기법은 다음과 같습니다. 위에서 아래로 내려갈 수록 시간 복잡도가 증가합니다.  </p>\n<table>\n<thead>\n<tr>\n<th>빅오 표기법</th>\n<th align=\"center\">명칭</th>\n<th align=\"center\">특징</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>O(1)</td>\n<td align=\"center\">상수 시간(Constant time)</td>\n<td align=\"center\">주어진 입력 자료에 관계 없이 일정한  연산 시간</td>\n</tr>\n<tr>\n<td>O(logN)</td>\n<td align=\"center\">로그 시간(Logt ime)</td>\n<td align=\"center\">이진트리나 이진탐색에서 찾아 볼 수 있는 연산 시간. <br>시간이 지날수록 작업을 수행하는 단계가 반 씩 줄어드는 특징을 지님</td>\n</tr>\n<tr>\n<td>O(N)</td>\n<td align=\"center\">선형 시간(Linear time)</td>\n<td align=\"center\">수행시간이 입력 크기에 따라 선형적으로 증가함을 의미</td>\n</tr>\n<tr>\n<td>O(NlogN)</td>\n<td align=\"center\">선형 로그 시간(Linearithmic time)</td>\n<td align=\"center\">n log n 수행시간은 간단히 Θ(log n) 연산의 n 배 수행시간의 결과 가짐</td>\n</tr>\n<tr>\n<td>O(N²)</td>\n<td align=\"center\">이차 시간</td>\n<td align=\"center\">작업을 수행하는데 걸리는 단계의 수가 n의 제곱</td>\n</tr>\n<tr>\n<td>O(N³)</td>\n<td align=\"center\">삼차 시간</td>\n<td align=\"center\">작업을 수행하는데 걸리는 단계의 수가 n의 세제곱</td>\n</tr>\n<tr>\n<td>O(2N)</td>\n<td align=\"center\">지수 시간</td>\n<td align=\"center\">작업을 수행하는 데 걸리는 단계의 수가 n의 크기에 따라 일정함</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84\">(출처 : 위키피디아 - 시간 복잡도)</a><br><a href=\"https://hyunalee.tistory.com/109\">(출처 : [알고리즘] 시간 복잡도, 공간 복잡도, 빅오(Big O))</a></p>\n<h4 id=\"2-2-공간-복잡도의-빅오-표기법\"><a href=\"#2-2-공간-복잡도의-빅오-표기법\" class=\"headerlink\" title=\"2-2 공간 복잡도의 빅오 표기법\"></a>2-2 공간 복잡도의 빅오 표기법</h4><p>시간 복잡도를 이해하셨다면 공간 복잡도의 빅오 표기를 이해하는 데에 어려움이 없을 겁니다.<br>예를들어, 크기가 n인 배열을 만들고 싶다면 O(n)의 공간이 필요하고, 크기가 n인 2차원 배열을 만들고싶다면 O(n²)의 공간이 필요합니다.</p>\n<p>공간 복잡도의 경우 메모리 사용량의 기준은 MB로 표시됩니다. 보통 코딩테스트에서는 메모리 사용량을 128~512MB로 제한합니다.<br>이는 데이터의 개수가 1,000만 단위가 넘어가지 않게 설계해야한다는 의미입니다.</p>\n<hr>\n<p>여기까지, 간단하게 복잡도에 대해서 알아보았습니다.<br>사실, 좀 더 깊이 들어가면 수학적 계산도 필요하고 알아볼 내용이 더 많습니다.<br>하지만, 이번 포스트의 목표가 복잡도의 개념을 설명할 수 있게 되는 것이기에 여기까지만 정리하도록 하겠습니다.<br>다음에는 기초적인 알고리즘에 대해 정리해보도록 하겠습니다.</p>\n","feature":true,"text":"프로그래밍 공부를 하는 사람이라면 “복잡도(Complexity)”라는 단어를 한 번 쯤은 들어봤을겁니다.그런데 이게 대~충은 알 것 같은데 막상 누군가에게 복잡도에 대해서 설명하려고 하면 설명하기 어려운 경우가 많습니다.때문에 이 포스트에서는 알고리즘...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"알고리즘","slug":"알고리즘","count":4,"path":"api/categories/알고리즘.json"}],"tags":[{"name":"algorithm","slug":"algorithm","count":5,"path":"api/tags/algorithm.json"},{"name":"complexity","slug":"complexity","count":1,"path":"api/tags/complexity.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%EB%B3%B5%EC%9E%A1%EB%8F%84-Complexity\"><span class=\"toc-text\">1. 복잡도(Complexity)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-Time-Complexity\"><span class=\"toc-text\">1-1 시간 복잡도(Time Complexity)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-%EA%B3%B5%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-Space-Complexity\"><span class=\"toc-text\">1-2 공간 복잡도(Space Complexity)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%EB%B9%85%EC%98%A4-%ED%91%9C%EA%B8%B0%EB%B2%95-Big-O\"><span class=\"toc-text\">2. 빅오 표기법(Big-O)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%9D%98-%EB%B9%85%EC%98%A4-%ED%91%9C%EA%B8%B0%EB%B2%95\"><span class=\"toc-text\">2-1 시간 복잡도의 빅오 표기법</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2-%EA%B3%B5%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84%EC%9D%98-%EB%B9%85%EC%98%A4-%ED%91%9C%EA%B8%B0%EB%B2%95\"><span class=\"toc-text\">2-2 공간 복잡도의 빅오 표기법</span></a></li></ol></li></ol>","author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"mapped":true,"prev_post":{"title":"2. 탐욕 알고리즘(Greedy Algorithm)","uid":"4db30505bd3613ad654d9a53e43df5c4","slug":"algorithm-greedy","date":"2021-06-13T01:27:11.000Z","updated":"2021-06-27T05:30:41.693Z","comments":true,"path":"api/articles/algorithm-greedy.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/algorithm.jpeg","text":"이번 포스트에서는 탐욕 알고리즘(Greedy Algorithm)에 대해서 정리하겠습니다.사실 코딩 테스트에서 탐욕 알고리즘은 출제 빈도가 낮은 편에 속합니다.(프로그래머스 기준)그럼에도 탐욕 알고리즘을 정리하는 이유는 이를 공부하다보면 알고리즘 문제의...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"알고리즘","slug":"알고리즘","count":4,"path":"api/categories/알고리즘.json"}],"tags":[{"name":"algorithm","slug":"algorithm","count":5,"path":"api/tags/algorithm.json"},{"name":"Greedy","slug":"Greedy","count":1,"path":"api/tags/Greedy.json"}],"author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"feature":true},"next_post":{"title":"3. 프로젝트 설정 확인","uid":"1bc1fccedcb28371ce507abc90a2b06f","slug":"springboot-web-4","date":"2021-06-11T02:24:43.000Z","updated":"2021-06-11T04:00:37.410Z","comments":true,"path":"api/articles/springboot-web-4.json","keywords":"Programming, JAVA, JS, Spring MVC/Boot, React","cover":"../images/main.png","text":"이 포스트에서는 이전까지 작성한 프로젝트가 제대로 동작하는지 테스트하도록 하겠습니다.테스트코드를 작성하기 전에 기능테스트를 위한 간단한 API를 작성해보겠습니다. “hello”를 반환하는 GET method API 만들기3-1 패키지 생성프로젝트에서 ...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","slug":"스프링-부트와-AWS로-혼자-구현하는-웹-서비스","count":11,"path":"api/categories/스프링-부트와-AWS로-혼자-구현하는-웹-서비스.json"}],"tags":[{"name":"springBoot","slug":"springBoot","count":11,"path":"api/tags/springBoot.json"},{"name":"java","slug":"java","count":2,"path":"api/tags/java.json"},{"name":"TDD","slug":"TDD","count":1,"path":"api/tags/TDD.json"}],"author":{"name":"Latte","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"최근에는 바닐라 라떼가 가장 좋습니다.","socials":{"github":"https://github.com/dev-latte","twitter":"https://twitter.com/dev_latte","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"mail":{"icon":"fas fa-envelope","link":null}}}},"feature":true}}