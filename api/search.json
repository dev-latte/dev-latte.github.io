[{"id":"4db30505bd3613ad654d9a53e43df5c4","title":"2. 탐욕 알고리즘(Greedy Algorithm)","content":"이번 포스트에서는 탐욕 알고리즘(Greedy Algorithm)에 대해서 정리하겠습니다.사실 코딩 테스트에서 탐욕 알고리즘은 출제 빈도가 낮은 편에 속합니다.(프로그래머스 기준)그럼에도 탐욕 알고리즘을 정리하는 이유는 이를 공부하다보면 알고리즘 문제의 원리를 깨닫는 능력을 향상시키는 데에 도움이 될 것이라 생각했기 때문입니다.즉, 탐욕 알고리즘의 정리를 통해 문제가 요구하는 최소한의 원리를 떠올릴 수 있는 능력을 키워보려 합니다.\n탐욕 알고리즘 (Greedy Algorithm)1. 정의탐욕 알고리즘(Greedy Algorithm)은 매 순간 가장 좋아보이는 최적의 선택을 하는 방법으로 진행하여 최종적인 해답에 도달하는 방식입니다.Greedy라는 단어는 “탐욕”이라는 뜻을 가지므로 국내에서는 탐욕 알고리즘으로 불립니다. (이하 탐욕 알고리즘)\n그리디 알고리즘은 가장 좋아보이는 것이라는 기준이 존재하므로 문제에서 “가장 큰 순서대로”, “가장 작은 순서대로”와 같은 기준을 알게 모르게 제시해줍니다.때문에 그리디 알고리즘은 정렬 알고리즘과 짝을 이뤄 출제되는 경우가 많습니다.\n2. 문제탐욕 알고리즘의 가장 유명한 예시는 동전 문제 입니다.거스름 돈 문제를 예를 들어 탐욕 알고리즘을 설명하겠습니다.(아래의 문제는 나동빈님의 저서 「이것이 취직을 위한 코딩 테스트다 with 파이썬」에서 발췌한 문제입니다)\n\n\n\n\n\n\n거스름 돈\n당신은 계산을 도와주는 점원입니다.카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재합니다.손님에게 거슬러주어야할 돈이 N원일 때, 거슬러 줘야 할 동전의 최소 개수는 몇 개인가요?단, 거슬러 줘야할 돈 N은 항상 10의 배수입니다.\n\n동전의 개수를 최소화 하는 것이 이 알고리즘의 목적입니다.그럼 동전의 개수를 최소화 하기 위해서는 어떻게 해야할까요?생각을 잘 정리해봅시다. 저는 아래와 같이 생각이 흘러갔습니다.\n\n\n\n\n\n\n\n\n\n\n동전의 종류를 살펴보면, 500원은 100원을 5개를 모아야하고, 50원은 10원을 5개 모아야 한다.  \n동전이 여러 개 모이면 큰 종류의 동전이 된다.  \n동전의 개수를 줄이기 위해서는 큰 금액의 동전을 먼저 사용하는 것이 유리하다.\n\n저는 이런식으로 “가장 큰 화폐 단위부터 돈을 거슬러주어야 동전의 개수가 최소화된다” 라는 생각을 유추해냈습니다.그럼 이 생각을 코드로 짜기위해서 어떻게 해야할지 고민해보겠습니다. (자바 기준 서술)\n\n\n\n\n\n\n\n\n\n\n동전 종류를 담는 배열에 동전의 금액이 큰 것부터 내림차순으로 선언한다.\n동전의 개수를 셀 변수를 선언한다.\n동전의 종류를 돌면서 거슬러줄 수 있는 만큼 거슬러주고, 그만큼을 동전의 개수에 추가한다.\n거슬러준 금액을 원래의 금액에서 차감한다.\n\n이것이 제가 생각한 알고리즘의 흐름이고, 이것을 자바로 표현하면 아래와 같습니다.\npublic static void main(String[] args) &#123;\n        int n = 1260;\n        int [] coins = &#123;500, 100, 50, 10&#125;;\n        int coin_count = 0;\n\n        for (int i = 0; i &lt; coins.length; i++) &#123;\n            int coin = n / coins[i];\n            coin_count += coin;\n            n -= (coin * coins[i]);\n        &#125;\n        System.out.println(coin_count);\n&#125;\n\n3. 주의점-1 : 탐욕 알고리즘이 아닐 가능성탐욕 알고리즘은 탐욕적으로 문제에 접근했을 때, 정확한 답을 찾을 수 있다는 보장이 있을 때에는 매우 효과적이고 직관적입니다.위의 문제를 그리디 알고리즘으로 해결할 수 있는 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문입니다.즉, 큰 단위가 작은 단위의 배수 형태이기에 큰 동전부터 거슬러주고, 작은 동전을 거슬러준다는 말이 성립되는 겁니다. \n예를 들어 만들어야 하는 금액이 800원이고, 화폐의 단위가 100원, 400원, 500원이라면 그리디 알고리즘은 500원 1개과 100원 3개의 조합을 생각해낼 것입니다.그러나 가장 효과적인 조합은 400원짜리 2개입니다.때문에 화폐의 배열이 무작위인 경우, 그리디 알고리즘으로는 해결할 수 없으니 주의할 필요가 있습니다.\n4. 주의점-2 : 탐욕 알고리즘은 결과가 전체적으로 최적이 아닐 가능성탐욕 알고리즘은 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않습니다.때문에 선택의 순간마다 하는 선택은 최적이지만, 이것이 전체적으로 최적이라는 보장은 없습니다. \n그러나 어떤 특별한 구조가 있는 문제에 대해서는 탐욕 알고리즘이 언제나 최적해를 찾아낼 수 있는데 이 구조를 매트로이드라고 합니다.\n\n지금까지 탐욕 알고리즘의 정의와 기본 원리에 대해서 알아보았습니다.탐욕 알고리즘에서 중요한 것은 아래의 두 가지 입니다.\n\n\n\n\n\n\n\n\n\n\n문제가 요구하는 최소한의 원리를 알아낼 수 있는가\n이것이 탐욕 알고리즘이라는 확신이 있는가\n\n이 두 가지를 가슴에 새기고, 다양한 문제를 풀어보며 감을 익혀가도록 합시다.탐욕 알고리즘에 관해서는 여기까지 적도록 하겠습니다.\n","slug":"algorithm-greedy","date":"2021-06-13T01:27:11.000Z","categories_index":"알고리즘 & 코딩 테스트","tags_index":"algorithm,Greedy","author_index":"Latte"},{"id":"d6a03e07ef9853873ef42e3c7ea6ee4a","title":"1. 알고리즘의 복잡도","content":"프로그래밍 공부를 하는 사람이라면 “복잡도(Complexity)”라는 단어를 한 번 쯤은 들어봤을겁니다.그런데 이게 대~충은 알 것 같은데 막상 누군가에게 복잡도에 대해서 설명하려고 하면 설명하기 어려운 경우가 많습니다.때문에 이 포스트에서는 알고리즘과 관련된 개념을 정리하는 시간을 가져보려고 합니다.\n1. 복잡도(Complexity)복잡도는 알고리즘의 성능을 나타내는 척도로 문제를 해결하는 데에 알고리즘이 얼마나 복잡하게 문제를 해결하는 지를 나타냅니다. 복잡도는 크게 시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)로 구분됩니다.\n\n시간 복잡도 : 알고리즘이 어떤 문제를 해결하는 데에 걸리는 시간\n공간 복잡도 : 알고리즘이 어떤 문제를 해결하는 데에 차지하는 메모리\n\n즉, 시간 복잡도는 알고리즘의 수행시간을, 공간 복잡도는 알고리즘의 메모리 사용량을 나타냅니다.  \n동일한 기능을 수행하는 알고리즘이 있다면 일반적으로 복잡도가 낮을수록 좋은 알고리즘입니다.복잡도를 표현할 때에는 빅오(Big-O)표기법을 사용하는데 이에 대한 자세한 내용은 아래에서 다루도록 하겠습니다.\n1-1 시간 복잡도(Time Complexity)시간 복잡도는 알고리즘이 문제를 해결하기 위한 연산의 횟수를 말합니다.프로그램이 비효율적으로 작성되어 연산 횟수가 증가하는 경우, 시간 복잡도도 증가하게 됩니다.알고리즘 문제에서 단순히 복잡도라고 하면, 보통 이 시간 복잡도를 의미합니다.  \n\n\n\n\n\n\n\n\n\n보통 시간 복잡도에서의 “연산”은 프로그래밍 언어에서 지원하는 사칙 연산, 비교 연산 등과 같은 기본 연산을 의미합니다.\n1-2 공간 복잡도(Space Complexity)공간 복잡도는 알고리즘의 동작을 위해 필요한 메모리의 양을 의미합니다.최근에는 주기억장치인 RAM의 용량이 커져서 중요도가 낮아졌지만, 임베디드나 펌웨어 환경 등 하드웨어 환경이 매우 한정되어 있는 분야에서는 중요하게 고려되어야 합니다.\n시간 복잡도와 공간 복잡도는 반비례하는 경향이 있습니다.최근에는 공간 복잡도보다 시간 복잡도를 더 중요하게 생각하므로 메모리를 더 많이 사용해서 실행 시간을 비약적으로 줄이기도 하는데 이러한 기법을 메모이제이션(memoization)이라고 합니다.\n\n\n\n\n\n\n메모이제이션(memoization)\n컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술로, 동적 계획법의 핵심이 되는 기술입니다. (출처 : 위키피디아 - 메모이제이션)\n\n2. 빅오 표기법(Big-O)빅오 표기법은 점근 표기법 중 하나로 최악의 경우를 우선적으로 고려하는 방식입니다.\n\n\n\n\n\n\n점근 표기법(asymptotic notation)\n어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법으로 알고리즘의 복잡도를 단순화할 때나 무한급수의 뒷부분을 간소화할 때 사용됩니다. (출처 : 위키피디아 - 점근 표기법)\n\n2-1 시간 복잡도의 빅오 표기법시간 복잡도의 빅오 표기법은 다음과 같습니다. 위에서 아래로 내려갈 수록 시간 복잡도가 증가합니다.  \n\n\n\n빅오 표기법\n명칭\n특징\n\n\n\nO(1)\n상수 시간(Constant time)\n주어진 입력 자료에 관계 없이 일정한  연산 시간\n\n\nO(logN)\n로그 시간(Logt ime)\n이진트리나 이진탐색에서 찾아 볼 수 있는 연산 시간. 시간이 지날수록 작업을 수행하는 단계가 반 씩 줄어드는 특징을 지님\n\n\nO(N)\n선형 시간(Linear time)\n수행시간이 입력 크기에 따라 선형적으로 증가함을 의미\n\n\nO(NlogN)\n선형 로그 시간(Linearithmic time)\nn log n 수행시간은 간단히 Θ(log n) 연산의 n 배 수행시간의 결과 가짐\n\n\nO(N²)\n이차 시간\n작업을 수행하는데 걸리는 단계의 수가 n의 제곱\n\n\nO(N³)\n삼차 시간\n작업을 수행하는데 걸리는 단계의 수가 n의 세제곱\n\n\nO(2N)\n지수 시간\n작업을 수행하는 데 걸리는 단계의 수가 n의 크기에 따라 일정함\n\n\n(출처 : 위키피디아 - 시간 복잡도)(출처 : [알고리즘] 시간 복잡도, 공간 복잡도, 빅오(Big O))\n2-2 공간 복잡도의 빅오 표기법시간 복잡도를 이해하셨다면 공간 복잡도의 빅오 표기를 이해하는 데에 어려움이 없을 겁니다.예를들어, 크기가 n인 배열을 만들고 싶다면 O(n)의 공간이 필요하고, 크기가 n인 2차원 배열을 만들고싶다면 O(n²)의 공간이 필요합니다.\n공간 복잡도의 경우 메모리 사용량의 기준은 MB로 표시됩니다. 보통 코딩테스트에서는 메모리 사용량을 128~512MB로 제한합니다.이는 데이터의 개수가 1,000만 단위가 넘어가지 않게 설계해야한다는 의미입니다.\n\n여기까지, 간단하게 복잡도에 대해서 알아보았습니다.사실, 좀 더 깊이 들어가면 수학적 계산도 필요하고 알아볼 내용이 더 많습니다.하지만, 이번 포스트의 목표가 복잡도의 개념을 설명할 수 있게 되는 것이기에 여기까지만 정리하도록 하겠습니다.다음에는 기초적인 알고리즘에 대해 정리해보도록 하겠습니다.\n","slug":"algorithm-complexity","date":"2021-06-12T12:42:51.000Z","categories_index":"알고리즘 & 코딩 테스트","tags_index":"algorithm,complexity","author_index":"Latte"},{"id":"1bc1fccedcb28371ce507abc90a2b06f","title":"3. 프로젝트 설정 확인","content":"이 포스트에서는 이전까지 작성한 프로젝트가 제대로 동작하는지 테스트하도록 하겠습니다.테스트코드를 작성하기 전에 기능테스트를 위한 간단한 API를 작성해보겠습니다.\n“hello”를 반환하는 GET method API 만들기3-1 패키지 생성프로젝트에서 경로 src &gt; main &gt; java 디렉토리 에 패키지를 생성합니다.일반적으로 패키지명은 웹 사이트 주소의 역순으로 작성합니다. 저는 com.dev.latte.springboot로 작성했습니다.\n[그림3-1] 패키지 생성\n3-2 Application 클래스 생성방금 작성한 패키지에 Application이라는 이름으로 자바 클래스파일을 추가해줍니다.여기서 주의할 것은 경로가 다르면 안된다는 것과 클래스의 맨 첫글자가 대문자라는 것입니다.이는 자바의 명명규칙으로 자바의 클래스 이름의 첫 글자는 항상 대문자로 작성되어야 합니다.자바 명명규약(Naming Rule)은 기회가 된다면 다루어보도록 하겠습니다.\n[그림3-2] Application 클래스 생성\n3-3 클래스 내용 작성Application 클래스에 아래의 코드를 작성합니다.지금 작성하는 Application.class는 프로젝트의 메인클래스가 됩니다!\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Application.class, args);\n    &#125;\n&#125;\n\n\n\n\n\n\nimport가 자동으로 추가되지 않는다면?\n    import가 자동으로 추가되지 않는다면, 추가되지 않아 붉게 변한 코드로 이동한 후 윈도우는 [alt + enter], 맥은 [option + enter]를 눌러 직접 import해주세요.\n\n\n\n\n\n\n\n\n\n\n\n@SpringBootApplication: 스프링 부트의 자동 설정, 스프링 bean읽기와 생성을 모두 자동으로 설정하기 위한 어노테이션입니다. 프로젝트는 이 어노테이션이 있는 지점부터 설정을 읽어가기 때문에 @SpringBootApplication이 붙어있는 클래스는 항상 프로젝트 최상단에 위치해야합니다.\nSpringApplication.run 메서드: 이 메서드는 내부 WAS를 실행합니다. 때문에 톰캣이 필요 없다는 장점이 있으며 스프링 부트에서도 내장 WAS를 사용하는 것을 권장하고 있습니다.\n\n3-4 테스트를 위한 Controller의 패키지 생성현재 패키지(com.dev.latte.springboot)의 하위에 web 패키지를 만들어보겠습니다.앞으로 컨트롤러와 관련된 클래스들은 모두 이 패키지에 담겠습니다.\n3-5 Controller 생성 및 코드 작성web 패키지 아래에 테스트를 시행할 컨트롤러를 만들어 보겠습니다.클래스이름은 HelloController이며 내부 코드는 다음과 같습니다.\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController &#123;\n    @GetMapping(\"/hello\")\n    public String hello()&#123;\n        return \"hello\";\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n@RestController: 컨트롤러를 JSON객체를 반환하는 컨트롤러로 만들어줍니다.  \n@GetMapping: GET요청을 받는 API를 만들어줍니다.\n\n기능 테스트3-6 Controller의 기능 테스트를 위한 클래스 생성작성한 코드가 제대로 작동하는지 테스트하겠습니다.방금 생성한 HelloController의 클래스 이름 위에 커서를 두고, 윈도우는 [alt + enter], 맥은 [option + enter]를 누른 후, create test를 선택하여 그대로 테스트 클래스를 생성해주세요.\n[그림3-3] 테스트 클래스 생성\n생성된 테스트 클래스의 내부 코드를 아래와 같이 작성해주세요.\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n\n@WebMvcTest(controllers = HelloController.class)\nclass HelloControllerTest &#123;\n    @Autowired\n    private MockMvc mvc;\n\n    @Test\n    public void hello가_리턴된다() throws Exception &#123;\n        String hello = \"hello\";\n        mvc.perform(get(\"/hello\"))\n                .andExpect(status().isOk())\n                .andExpect(content().string(hello));\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n@WebMvcTest: MVC Controoler를 위한 테스트로 동작이 예상한대로 동작하는지 확인하는 데에 사용한다.\n@Autowired: 해당 변수 및 메서드에 스프링이 관리하는 Bean을 자동으로 매핑해준다. (스프링 의존성 주입)\n@Test: 테스트를 수행하는 메소드를 선언한다.\n\n책에서는 @WebMvcTest() 어노테이션 위에 @RunWith(SpringRunner.class) 어노테이션이 작성되어 있지만, 이 코드에서는 적지 않습니다.그 이유는 JUnit의 버전이 책과 다르기 때문입니다. [그림3-3]을 보면 이 테스트 클래스는 JUnit5버전입니다. @RunWith() 어노테이션은 JUnit4버전에 존재하는 어노테이션으로 JUnit5버전으로 올라오면서 @ExtendWith()로 대체되었습니다. 때문에 @RunWith() 대신에 @ExtendWith()을 사용해야 합니다.(출처 : @RunWith no longer exists; superseded by @ExtendWith)  \n하지만 이미 스프링 부트가 제공하는 모든 테스트용 어노테이션에는 @ExtendWith()가 메타 어노테이션으로 적용되어 있기 때문에 @ExtendWith(SpringExtension.class)를 생략할 수 있습니다.(출처 : Junit 5 with Spring Boot: When to use @ExtendWith Spring or Mockito?)\n3-7 테스트 코드 실행그럼 작성한 메소드를 테스트해봅시다. 왼쪽에 있는 초록색 삼각형을 눌러서 테스트를 실행해주세요!\n[그림3-4] 테스트 코드 실행\n테스트가 실행되고, 코드에 문제가 없다면 아래와 같이 Tests passed가 표시됩니다.  \n[그림3-5] 테스트 결과화면\n3-8 프로젝트 동작 확인마지막으로 프로젝트가 실제로 잘 동작하는지 확인해보겠습니다.Application.class로 돌아가 메인 메소드를 실행(Run ‘Application’)해주세요.\n[그림3-6] 어플리케이션 실행\n프로젝트가 문제없이 실행되었다면 콘솔 탭에 아래와 같이 표시됩니다.\n[그림3-6] 어플리케이션 실행\n브라우저에서 localhost:8080/hello로 접속해주세요.접속했을 때, 다음과 같이 문자열 hello가 잘 노출된다면 프로젝트가 제대로 동작하고 있는겁니다!\n[그림3-7] API 실행 결과\n\n이제, 웹 서비스를 위한 가장 기초적인 설정을 끝냈습니다.  \n\n스프링 부트 프로젝트 설정  \nAPI 코드 작성 및 테스트방법  \n\n다음 포스트에서는 생산성을 높여주는 라이브러리 롬복에 대해 설명하겠습니다.\n","slug":"springboot-web-4","date":"2021-06-11T02:24:43.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,java,TDD","author_index":"Latte"},{"id":"18c39e99fd033dd5083bccdf6728bd02","title":"2. Gradle을 스프링 부트 프로젝트로 변경","content":"이번 포스트에서는 작성한 프로젝트를 스프링 부트 프로젝트로 변경하는 방법을 설명합니다.의존성 주입을 통해 gradle을 스프링 부트 프로젝트로 변경하도록 하겠습니다.\nGradle을 스프링 부트 프로젝트로 변경2-1 “build.gradle”의 프로젝트의 플러그인 의존성 관리를 위한 설정 코드를 작성우선 프로젝트 내에 위치한 build.gradle의 최상단에 의존성 관리를 위한 설정코드를 작성합니다.코드를 작성하기 전에, 이 포스트에서는 책의 내용과 다른 방식으로 설정 코드를 작성 것을 미리 알려둡니다.그럼 어떻게 다른지 살펴볼까요? 우선, 책에서는 아래와 같이 코드를 작성하고 있습니다.\nbuildscript &#123;\n    ext &#123;\n        springBootVersion &#x3D; &#39;2.1.9.RELEASE&#39;\n    &#125;\n    repositories &#123;\n        mavenCentral()\n        jcenter()\n    &#125;\n    dependencies &#123;\n        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;)\n    &#125;\n&#125;\n\napply plugin: &#39;java&#39;\napply plugin: &#39;eclipse&#39;\napply plugin: &#39;org.springframework.boot&#39;\napply plugin: &#39;io.spring.dependency-management&#39;\n\n위와 같이 작성하던 도중, gradle.build에 자동으로 생성되어있던 plugins &#123; id &quot;java&quot;&#125;가 눈에 들어왔습니다.\n[그림2-1] 신경쓰이는 존재, plugins { id “java”}\n위에서 작성한 코드에서 apply plugin과 닮은 모습에 혹시 apply plugin을 모아서 사용할 수 있는 건 아닐까 하는 의심이 들었고, 자세한 사항을 알기 위해 검색하게 되었습니다. 검색해보니 plugins &#123;&#125; 은 gradle이 업데이트 되면서 변경된 사항으로 “plugins block”라 불리며, 플러그인을 추가하고, 선택적인 매개변수를 사용하여 적용 시기를 제어할 수 있다는 특징을 지닌다고 합니다.(출처)\n이 업데이트로 위의 코드의 buildscript&#123;&#125;과 apply plugins는 아래와 같이  합쳐서 적는 것이 가능해졌습니다.\nplugins &#123;\n    id &quot;java&quot;\n    id &quot;eclipse&quot;\n    id &quot;org.springframework.boot&quot; version &quot;2.1.9.RELEASE&quot;\n    id &quot;io.spring.dependency-management&quot; version &quot;1.0.11.RELEASE&quot;\n&#125;\n\n\n\n\n\n\n\n\n\n플러그인 정보는 이곳에서 확인 가능합니다.\n훨씬 간편하고 보기 좋아졌습니다.이 4개의 플러그인은 자바와 스프링 부트를 사용하기 위해 반드시 추가해야함을 잊지 말아주세요!그럼, gradle을 마저 추가해봅시다.\n2-2 dependencies에 개발에 필요한 의존성들을 선언dependencies에 개발에 필요한 의존성들을 선언합니다.책에서는 compile을 사용하였으나, 여기서는 implementation을 사용합니다.implementation을 사용하는 이유가 몇 가지 있습니다만, 가장 큰 이유는 compile이 gradle7+ 버전에서 삭제되었다는 것입니다.그 외에도 이유는 많지만, 이 포스트는 프로젝트 생성을 위한 자리이니 자세한건 다음에 다루어보겠습니다.혹시, 이 사항에 관심있으신 분을 위해 아래의 포스트 주소를 남기니 확인해보시길 바랍니다.\n\n\n\n\n\n\n\n\n\nGradle implementation vs. compile dependencies\n그럼, build.gradle의 dependencies에 다음의 의존성을 추가해봅시다.\ndependencies &#123;\n    implementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-web&#39;, version: &#39;2.4.5&#39;\n    testImplementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-test&#39;, version: &#39;2.4.5&#39;\n&#125;\n\n2-3 자바의 버전을 1.8로 설정해줍니다.이제 자바 소스 코드의 버전을 1.8로 설정해보겠습니다. 참고로, 제 컴퓨터에 설치되어있는 JDK는 13입니다.그럼에도 불구하고 1.8로 설정하는 이유는 책과의 환경 차이에서 생기는 오류를 줄이기 위함입니다.책에서는 스프링 부트 2.1.9.RELEASE 버전을 사용하며 gradle은 4.8~4.10 버전을 사용하고 있습니다.JDK 13은 스프링 부트 2.2.x 버전 이상, gradle은 6버전 이상만이 지원하기 때문에 스프링 부트의 버전업이 불가피합니다.스프링 부트의 버전업으로 인해 어떤 오류가 생길지 모르니 초반에는 JDK 1.8로 프로젝트를 진행하고, 후에 기회가 된다면 스프링 부트 업그레이드 후 13으로 변경하여 작업해보도록 하겠습니다.그럼, version아래에 다음과 같은 코드를 추가해주세요.\nsourceCompatibility &#x3D; 1.8\n이 코드는 자바 소스 코드의 버전을 의미합니다.\n2-4 build.gradle작성이 완료된 build.gradle의 전체 코드는 아래와 같습니다.\nplugins &#123;\n    id &quot;java&quot;\n    id &quot;eclipse&quot;\n    id &quot;org.springframework.boot&quot; version &quot;2.1.9.RELEASE&quot;\n    id &quot;io.spring.dependency-management&quot; version &quot;1.0.11.RELEASE&quot;\n&#125;\n\ngroup &#39;com.dev.latte&#39;\nversion &#39;1.0-SNAPSHOT&#39;\nsourceCompatibility &#x3D; 1.8\n\nrepositories &#123;\n    mavenCentral()\n&#125;\n\ndependencies &#123;\n    implementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-web&#39;, version: &#39;2.4.5&#39;\n    testImplementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-test&#39;, version: &#39;2.4.5&#39;\n&#125;\n\ntest &#123;\n    useJUnitPlatform()\n&#125;\n\n2-5 Gradle 반영하기그레이들 작성이 완료되었다면, 인텔리제이 상단에 있는 Reload 버튼(순환마크)을 클릭하여 그레이들을 반영합니다.\n[그림2-2] gradle import\n버튼을 클릭하면, 인텔리제이 하단에 그레이들의 반영 상황이 표시되고, 반영이 끝나면 Gradle sync finished가 표시됩니다.\n\n이제 스프링 부트 프로젝트의 기본 셋팅이 완료되었습니다!다음 포스트에서는 프로젝트의 설정이 제대로 되었는지 확인해보도록 하겠습니다.\n","slug":"springboot-web-3","date":"2021-06-10T00:46:49.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,Java,gradle","author_index":"Latte"},{"id":"a01df8c8fb60fb63504058a17ab9f187","title":"1. IntelliJ 프로젝트 생성","content":"이 포스트에서 IntelliJ의 설치는 다루고 있지 않습니다. IntelliJ의 설치는 다른 분의 블로그나 웹을 참고해주세요.  \n\n\n\n\n\n\nIntelliJ IDEA\n    - IntelliJ는 기본적으로 유료툴이지만 community버전은 무료로 이용 가능합니다.    - 학생이시라면 1년 간 Ultimate버전 제품을 무료로 사용 가능합니다.\n\nIntelliJ 프로젝트 생성프로젝트 생성 전에, 이 포스트에서는 프로젝트 생성시 Spring Initializer를 사용하지 않습니다.왜 이 방식을 사용하는지 설명하겠습니다.  일단, 스프링 프로젝트를 생성하는 방법은 두 가지가 있습니다.  \n\nSpring Initializer를 이용하는 방법  \n프로젝트 생성 후, 의존성을 추가하는 방법\n\n첫 번째 방법은 간단하지만, 의존성 주입이나 build.gradle 등을 이해하지 않은 상태로 사용할 경우 오히려 혼란스러울 수 있습니다.때문에 이 포스트는 Spring Initializer를 사용하지 않고 간단한 프로젝트를 생성 후, 필요할 때마다 의존성을 추가합니다.\n이제 프로젝트를 생성해봅시다. \n1-1 프로젝트 생성“Create new Project” 혹은 “New Project” 버튼을 클릭합니다.\n[그림1-1] 프로젝트 생성\n1-2 프로젝트 Gradle 설정아래와 같은 창이 뜨면 이하와 같이 설정합니다.  \n[그림1-2] 프로젝트 Gradle 셋팅(JDK 버전은 신경쓰지 않으셔도 괜찮습니다. 나중에 build.gradle에서 1.8로 제어할 예정입니다.)\n설정이 끝났다면, Next를 클릭하여 다음으로 이동해주세요.\n1-3 GroupId와 ArtifactId 등록GroupId와 ArtifactId를 등록합니다.\n[그림1-3] 프로젝트 GroupId &amp; ArtifactId 등록  \n여기서 ArtifactId는 프로젝트의 이름이 됩니다.\n1-4 finish를 클릭하면 프로젝트 빌드가 시작됩니다.\n\n\n\n\n\n\n\n\n위의 과정 중간에 프로젝트의 경로를 정하는 창이 뜰 수도 있습니다. 당황하지 마시고 프로젝트가 저장될 위치를 저장해주세요.\n\n이제 Gradle기반의 자바 프로젝트가 완성되었습니다!다음 포스트에서는 이 프로젝트를 스프링 프로젝트로 변경해보도록 하겠습니다.\n","slug":"springboot-web-2","date":"2021-06-09T12:36:23.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,Java,gradle","author_index":"Latte"},{"id":"681e8e55f24e67b1822965c116da3835","title":"0. 개요","content":"이 카테고리는 이동욱님의 저서 「스프링 부트와 AWS로 혼자 구현하는 웹 서비스」를 기반으로 혼자 연습하며 문제를 해결해가는 카테고리입니다.기본적으로 책을 따라 진행하며, 프로젝트 전반의 흐름 및 진행하면서 생기는 버그의 해결문제를 기록합니다.또한 이 포스트에서 진행하는 프로젝트 환경은 책과 다른 점이 존재하니, 이런 부분을 확인하면서 포스트를 봐주시기 바랍니다.  \n\n\n\n\n\n\n환경\n    - 블로그 : intelliJ IDEA / Java8(JDK 1.8) / Gradle 6.8    - 책 : intelliJ IDEA / Java8(JDK1.8) / Gradle 4.8 ~ Gradle 4.10.2\n\n개인적으로 상냥하게 설명된 책이니 구매하셔서 보시는 것도 추천드립니다. (책 이름에 yes24 링크가 걸려있습니다)\n또한 기본적인 버그는 이동욱님의 공식 깃허브에서 논의되고 있으니 이쪽도 확인해보세요.  \n궁극적인 목표는 “서비스를 처음부터 끝까지 혼자 만드는 것!” 이지만 공부를 하기 위함도 있습니다.때문에 프로그램이나 프레임워크가 왜 그렇게 동작하는지를 알기 위해 삼천포로 빠지는 경우가 많을 것 같습니다.글이 길어질 것 같은 경우, 다른 게시글에 정리할 예정이니 관심있으신 분은 링크를 타고 이동해주세요.\n그럼, 시작하겠습니다 :D\n","slug":"springboot-web-1","date":"2021-06-08T12:36:23.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,Java,gradle","author_index":"Latte"},{"id":"3b9e4a33c5246d01da88767642ae37d5","title":"markdown page","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-06-07T12:36:23.000Z","categories_index":"","tags_index":"hexo,aurora","author_index":"Latte"}]