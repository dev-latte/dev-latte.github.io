[{"id":"d93904bd8ecb573f2b3f624285e3ea2a","title":"6. JPA, Hibernate, Spring Data JPA","content":"과거에 스프링 프로젝트를 진행할 때에는 오라클 DB에 Mybatis를 사용했었습니다.때문에 이 책에서도 데이터베이스를 다루는 SQL mapper를 Mybatis로 사용할 것이라 추측했습니다.그러나 이 책에서 데이터베이스는 JPA를 통해 관리됩니다.  \n여기서 저자는 Mybatis를 사용하지 않는 이유를 실제로 개발하는 시간보다 SQL을 다루는 시간이 더 많기 때문이라고 서술하고 있는데, 생각해보니 저도 예전에 프로젝트를 작업할 때 프로젝트 자체보다는 SQL때문에 고통받던 시간이 길었던 것 같습니다.  \n하지만, JPA가 아무리 좋다고해도 JPA가 무엇이고, 왜 이것을 사용하는지, 어떤 부분에서 Mybatis보다 유용한지 알지 못한채로 사용하는 것은 의미가 없는 일이므로, JPA에 대해 정리해보는 시간을 갖겠습니다.\nJPA(Java Persistence API)1. JPA의 정의현대 웹 애플리케이션에서 관계형 데이터베이스(RDB;Relational Database)에서 객체를 관리하는 것은 중요합니다. 때문에 여러가지의 방식이 고려되고 있는데, 최근 많이 이용되는 방식으로 JPA가 있습니다. \nJPA는 자바 어플리케이션에서 관계형 데이터베이스를 관리하는 방식을 정의한 인터페이스이자 자바 표준 ORM(Object Relational Mapping) 기술입니다.\n\n\n\n\n\n\nSQL mapping vs JPA(ORM)\n\nSQL mapping: query를 맵핑하여 직접 DB를 조작합니다.: SQL - mapping - Object\nJPA(ORM; Object Relational Mapping): 객체와 DB의 데이터를 맵핑하여 메서드로 데이터를 조작합니다.: DB data - mapping - Object\n\n\n\n2. JPA 사용 이유JPA를 사용하는 이유는 크게 두 가지가 있습니다.\n2-1 생산성을 높이기 위해관계형 데이터베이스에서 가장 중요한 개념은 SQL인데, 이는 관계형 데이터베이스가 SQL만을 인식할 수 있기 때문입니다. 이러한 이유로 개발자들은 각 테이블마다 기본적인 CRUD(Create/Read/Update/Delete) SQL을 매번 생성해주어야합니다.  \n이러한 특성 탓에 개발자가 아무리 자바 클래스를 아름답게 설계해도, SQL을 통해야만 데이터베이스에 저장하고 조회할 수 있습니다. 문제는 프로젝트에 테이블이 한 개만 존재하지 않는다는 점입니다. 때문에 유사한 SQL이 반복됨에 따라 자바객체를 SQL로 SQL 객체를 자바 객체로 변환하는 과정 또한 반복됩니다. \n또한 프로젝트의 내용을 수정할 때마다 SQL도 수정해야하는 번거로움이 있습니다. 이러한 상황은 생산성과 유지보수에 나쁜 영향을 미치게 됩니다.\nJPA는 위의 서술한 것처럼 쿼리를 직접 작성하는 것이 아니라, 만들어진 객체로 데이터 베이스를 다루게 됩니다.때문에 객체중심의 개발이 가능하다는 장점이 있습니다.\n2-2 패러다임의 불일치를 해소하기 위해\n\n\n\n\n\n\n\n\n- 관계형 데이터베이스는 어떻게 데이터를 저장할지에 초점이 맞춰진 기술 입니다.- 객체지향 프로그래밍 언어는 메시지를 기반으로 기능과 속성을 한 곳에서 관리하는 기술입니다.\n한 눈에 봐도 목적과 사상이 다른데, 관계형 데이터베이스로 객체지향 언어를 표현할 수 있을까요?\n쉽지 않을겁니다. 관계형 데이터베이스와 객체지향 프로그래밍 언어의 패러다임이 서로 다른데, 객체를 데이터베이스에 저장하려고하니 문제가 발생합니다. 이를 패러다임의 불일치라고합니다.\n객체지향 프로그래밍 언어의 상속관계를 예로 들어보겠습니다.\nUser user = findUser();\nGroup group = user.getGroup();\n\n위의 코드를 보면 User와 Group은 부모-자식 관계임을 알 수 있습니다. User가 본인이 속한 Group의 정보를 가져오는 코드이기 때문입니다.그리고 이 코드에 데이터베이스가 추가되면 다음과 같습니다\nUser user = userDao.findUser();\nGroup group = groupDao.FindGroup(user.getGroupId());\n\n이렇게되면 User와 Group은 각자 따로 조회하게 됩니다. 즉, 상속이나 1:N등 다양한 객체 모델링을  데이터베이스로 구현할 수 없습니다.이러다보니 결국 Object를 SQL로 작성해야하고, 이 과정에서 Object &gt; SQL 변환 &gt; RDB에 저장하는 과정을 반복하게 됩니다.\n이는 개발자가 개발에 쓰는 시간보다 SQL 매핑작업에 시간을 쓰는 원인이 됩니다.\n결과적으로 JPA는 서로 지향하는 바가 다른 2개의 영역을 중간에서 조율해주고 패러다임을 일치시켜주기 위한 기술입니다. 개발자는 객체지향적으로 프로그래밍을 하고, JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성해서 실행합니다. 이로인해 개발자는 SQL에 종속적인 개발을 하지 않아도 됩니다.\n3. JPA 구현체 - Hibernate이 항목에서는 JPA 구현체에 대해 이야기해보겠습니다. 이 카테고리를 적는 이유는, JPA와 Hibernate(JPA의 구현체), Spring Data JPA의 차이점이 뭔지, 왜 사용하는지에 대해 헷갈리기 때문입니다\n3-1 HibernateHibernate는 JPA의 구현체입니다. 즉, JPA가 가진 인터페이스를 직접 구현한 라이브러리입니다. 이 정의에서 가장 중요한 것은 JPA를 사용하기 위해서 반드시 Hibernate를 사용할 필요가 없다는 것입니다. Hibernate를 사용하지 않더라도 직접 구현해서 사용하면 될테니까요.  \n때문에 Spring에서 JPA를 사용할 때에도 이 구현체들을 직접 다루지는 않습니다. 우리는 구현체들을 좀 더 쉽게 사용하기 위해서 추상화시킨 Spring Data JPA라는 모듈을 사용할 것입니다.\n4. Spring Data JPASpring Data JPA는 JPA를 쓰기 편하게 만들어놓은 모듈입니다.JPA와 Hibernate(구현체), 그리고 Spring Data JPA의 관계를 설명하자면 다음과 같습니다.\n\n\n\n\n\n\n\n\n\n[그림7-1] JPA, Hibernate, and Spring Data JPA의 관계간단하게 이야기하자면 JPA의 구현체가 Hibernate, 이를 한단계 더 감싸놓은것이 Spring Data JPA입니다.\n\n레퍼런스 : Hibernate ORM 5.4.32.Final User Guide\n\n사실, Hibernate를 사용하건 Spring Data JPA를 사용하건 기능 상에 유의미한 차이는 없습니다.그럼에도 불구하고 Spring 제작팀은 Spring Data JPA를 사용하는 것을 권장하고 있는데 그 이유는 아래와 같습니다  \n4-1 구현체 교체의 용이성구현체 교체의 용이성은 현재 사용중인 구현체 외에 다른 구현체로 쉽게 교체하기 쉬운 특성을 의미합니다.  \n현재는 Hibernate가 상당히 잘 만들어지고 성숙된 구현체이므로 바꿀 필요가 없지만, 수명을 다해서 새로운 JPA 구현체가 대세로 떠올라 새로운 구현체로 교체해야하는 상황이라 가정해봅시다.  \n이렇게되면 어쩔 수 없이 구현체를 교체해야 할 필요성이 생기는데, Spring Data JPA를 사용한 프로젝트라면 내부에서 구현체 매핑을 지원해주기 때문에 아주 쉽게 교체가 가능합니다.\n4-2 저장소 교체의 용이성저장소 교체의 용이성은 관계형 데이터베이스 외에 다른 DB로 쉽게 교체할 수 있는 특성을 의미합니다.  \n예를 들어, 관계형 데이터베이스로 구성된 하나의 프로젝트를 생각해봅시다.  \n지금은 관계형 데이터베이스로도 충분히 서비스가 가능한 수준이지만, 프로젝트가 성장하고 커져감에 따라 트래픽이 많아져 관계형 데이터베이스로는 도저히 감당이 안될 상황이 생겼습니다. 이에 대한 대책으로 개발자들은 데이터베이스의 변경을 제안했고, MongoDB가 좋겠다는 결론에 도달합니다. 때문에 데이터베이스를 관계형 데이터베이스에서 MongoDB로 교체해야합니다.  \n이런 상황에서 프로젝트가 Spring Data JPA를 사용하여 구성되었다면, Spring Data JPA에서 Spring Data MongoDB로 의존성 교체만하면 저장소를 쉽게 교체할 수 있습니다. 게다가 사용하는 메서드나 기능은 대체로 비슷하기때문에 코드를 수정할 필요성도 없습니다.\n이러한 특성 때문에 Spring 제작팀은 구현체를 직접 사용하는 것 보다 Spring Data를 사용하는 것을 권하고 있습니다.\n\n이번 포스트에서는 JPA를 사용하는 이유. 그리고 hibernate와 Spring Data JPA는 무엇인지 살펴보았습니다.다음 포스트에서는 이를 직접 스프링 프로젝트에 적용해보도록 하겠습니다.\n\n레퍼런스  \n\nJPA, Hibernate, 그리고 Spring Data JPA의 차이점  \nJPA는 도대체 뭘까? (orm, 영속성, hibernate, spring-data-jpa)\n\n","slug":"springboot-web-7","date":"2021-06-23T07:43:58.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"Java,springBoot,JPA","author_index":"Latte"},{"id":"a4c20de877725d90cf1ede9509e3fa58","title":"1. 자료 구조","content":"오랜만에 집정리를 하던 도중, 정보처리기사 책을 발견했습니다.자격증을 딴 이후로 방치된 책인데 오랜만에 열어보니 덜 풀은 문제가 있더군요.문제를 다 푼 후에 버릴 심산으로 심심할 때마다 정보처리기사 문제를 풀게 되었습니다.그런데 의외로 정리해두면 좋을 것 같은 문제가 많았는데 그 중에 하나가 자료 구조였습니다.때문에 이 포스트에서는 자료 구조의 정의와 중요한 자료 구조 분류를 정리해보려 합니다.\n자료구조(Data Structure)1. 정의자료 구조(Data Structure)는 말 그대로 데이터를 담는 구조이자 데이터의 집합을 의미합니다. 여기서 각 원소들은 논리적으로 정의된 규칙에 의해 나열되며, 자료를 효율적으로 처리할 수 있도록 구분하여 표현됩니다.이러한 자료구조는 프로그램 내에서 데이터를 가장 효율적으로 저장하고 처리하기 위해 사용되며, 잘 선택된 자료 구조는 보다 좋은 성능을 발휘합니다.\n자료 구조의 종류는 다양하고, 각각의 자료 구조는 각자의 연산 및 목적에 맞게 구성되어 있습니다.때문에 그 특징을 알고 각자에 맞는 알고리즘을 사용하는 것이 매우 중요합니다.\n2.  자료 구조의 분류2-1. 단순 구조(Simple Structure)단순 구조는 컴퓨터가 기본적으로 제공하는 자료형을 의미합니다.\n\n\n\n\n\n\n단순 구조 종류\n\ntrue, false (boolean)\nint, long, float, double\nchar, String\n\n\n\n2-2. 선형 구조(Linear Structure)선형 구조는 데이터들이 일렬로 정렬되어 저장된 상태를 의미합니다.이 자료 구조는 단순히 일렬로 저장하는 방식(스택과 큐도 포함) 과 각 데이터가 다음 데이터의 위치를 가지는 연결 리스트 방식으로 구분됩니다.\n\n\n\n\n\n\n선형 구조 종류\n\nArray - Stack / Queue / De-Queue\nLinked List\n\n\n\n2-3. 비선형 구조(Non-Linear Structure)데이터가 트리형태로 저장되어 있다고 생각하고 사용하는 자료구조이며 자료의 표현에 중점을 두고 있습니다.자료의 순서가 불규칙하고, 자료의 관계가 1:N의 관계를 갖는 등 관계가 복잡하거나 계층을 갖는 경우 주로 사용됩니다.\n\n\n\n\n\n\n비선형 구조 종류\n\nTree - General Tree(일반 트리) / Binary Tree(이진 트리)\nGraph - Directed Graph(방향 그래프) / Undirected Graph(무방향 그래프)\n\n\n\n2-4. 파일 구조(File Structure)파일을 구성하는 레코드들이 보조 기억 장치에 저장되는 방식을 의미합니다.파일 편성 방법에 따라 파일 접근 방법을 분류할 수 있어서 파일 접근 방법이라고도 합니다.\n\n\n\n\n\n\n파일 구조 종류\n\nSequential File (순차 파일 / 순서 파일)\nIndexed Sequential File(색인 순차 파일 / ISAM;Index Sequential Access Method)\nDirect File(직접 파일 / DAM;Direct Access Method)\n\n\n\n\n여기까지, 자료 구조의 정의 및 분류를 알아보았습니다.앞으로 정리할 자료 구조의 종류는 선형 구조와 비선형 구조 위주로 정리될 예정입니다.그 이유는 이 두 개의 자료 구조는 알고리즘에서 제일 중요하게 다뤄지는 자료 구조이기 때문입니다.그럼, 자료 구조의 종류와 특징에 대해서는 다음 포스트에서 진행하도록 하겠습니다.\n\n출처블로그 - 자료구조 : 자료구조란? (Data Structure)블로그 - [Data structure] 자료구조 종류와 분류\n","slug":"cs-data-structure","date":"2021-06-23T05:05:59.000Z","categories_index":"Computer Science","tags_index":"Computer Science,Data Structure","author_index":"Latte"},{"id":"de3f69ccc161905f5bded0c2342c2211","title":"3. 구현(Implementation)","content":"친구들과 알고리즘 공부를 하면서 “이해는 했는데 코드로 짜기가 힘들다”라는 말을 하곤 했습니다.그때는 알고리즘은 원리만 알면 풀 수 있는거 아니야? 하는 생각도 있었는데, 지금 생각해보니 정말 얼토당토않은 말이었죠.알고리즘이 중요하게 다뤄지는 이유는 문제 해결을 위해 방법을 찾고 그 방법을 구현하는 것이기 때문이니까요.때문에 이 포스트에서는 구현에 대해 한 번 정리하고, 자주 사용되는 메서드 등을 정리해 나가려 합니다.\n구현(Implementation)1. 정의코딩테스트에서 구현(Implementation)이란 ‘머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정’입니다.어떤 문제를 풀든 간에 소스코드를 작성하는 과정은 필수이므로, 구현 문제 유형은 모든 범위의 코딩 테스트 문제 유형을 포함하는 개념이지만 코딩 테스트에서 말하는 구현문제는 풀이를 떠올리는 것은 쉽지만, 코드로 옮기기에는 어려운 문제를 의미합니다.\n보통 구현 문제는 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제나 특정 소수점 자리까지 출력해야하는 문제, 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야하는 문제 등 알고리즘 자체보다 라이브러리 사용 경험이 필요한 문제가 많습니다.\n때문에 다양한 유형의 구현 문제를 접하고, 자주 쓰이는 라이브러리와 메소드의 사용법 등을 익혀두는 것이 문제 풀이에 도움이됩니다.  \n(출처 : 이것이 취업을 위한 코딩테스트다 with 파이썬)\n2. 문제구현 문제의 유형은 다양해서 몇 가지 유형으로 분류하는 것이 쉽지 않습니다.때문에 아래의 백준 온라인 저지 홈페이지의 문제 유형에서 구현을 찾아서 풀어보는 것을 추천드립니다.(백준 온라인 저지 - 구현(Implementation) 알고리즘 문제)\n3. 개인적으로 유용하다고 생각하는 라이브러리이 항목은 문제를 풀때마다 추가 될 예정이며 Java 8 API를 기준으로 합니다. \n1) java.util.Arrays\nArrays.copyOfRange(array, start, end): 배열의 특정 위치를 복사하여 새로운 배열로 만드는 메서드\nArrays.sort(array): 배열을 정렬하는 메서드\n\n2) java.util.Comparator\ncompare(a, b): a와 b를 비교하여 a가 더 작은 경우 -1을, 둘이 같다면 0, a가 더 큰 경우에는 1을 반환: 다음과 같이 오버라이트를 통해 응용해서 사용이 가능하다는 점에서 중요하게 봐둘 필요가 있음  \n\nArrays.sort(nums, new Comparator&lt;String&gt;()&#123;\n    @Override\n    public int compare(String num1, String num2) &#123;\n        return (num2+num1).compareTo(num1+num2);\n    &#125;\n&#125;);\n\n3) java.util.Map / java.util.HashMap\nmap.containsKey(key)  / map.containsValue(value): map 안에 key / value 값이 있는지 확인하는 메서드  \nmap.values(): map 객체를 Collection 객체로 반환하는 메서드\nmap1.putAll(map2): map_1의 객체와 map_2의 객체를 합쳐서 반환하는 메서드\n\n4) 기타 기본 라이브러리\nstr1.startsWith(str2): str1이 str2로 시작하는지 체크하는 메서드\nstr1.endsWith(str2): str1이 str2로 끝나는지 체크하는 메서드\nstr.join(“추가할문자”, “대상 array 혹은 list”): array 혹은 list를 더해주는 메서드. 추가할 문자에 값을 넣으면 그 값이 구분자가 됨.\n\n\n구현 문제를 알고리즘이라고 말할 수 있을까 고민했습니다.하지만 생각해보면 로직을 생각하기만 하고 코드를 구현하지 않는다면 무슨 의미가 있을까?하는 생각과 동시에 코드를 구현한다는 것 자체가 알고리즘의 핵심이라는 생각이 들었죠.때문에 블로그에 알고리즘의 유형으로 정의해두었습니다만, 유형이라기보다는 프로그래밍을 하는 사람이라면 반드시 갖춰야하는 능력이 아닐까 싶습니다.많은 문제를 접하며 경험을 쌓는 것. 이건 비단 알고리즘 문제에서만 통용되는 부분은 아니니까요.\n","slug":"algorithm-implementation","date":"2021-06-17T06:09:51.000Z","categories_index":"알고리즘 & 코딩 테스트","tags_index":"algorithm,Implementation","author_index":"Latte"},{"id":"08591114c8a1ce3933292eb92a5512bc","title":"5. 롬복(Lombok)으로 기존 코드 리팩토링","content":"이 포스트에서는 여태까지 작성한 코드를 롬복으로 리팩토링해보겠습니다. \n롬복(Lombok)으로 기존 코드 리팩토링5-1 HelloResponseDto 클래스 추가HelloResponseDto 클래스를 추가합니다.위치는 web 패키지 &gt; dto 패키지 입니다. \n[그림5-1] HelloResponseDto 클래스 위치앞으로 모든 response dto는 이곳에 추가하도록 하겠습니다!\n여기서 DTO가 무엇이고, 왜 추가하는지 의문이신 분도 있을거라고 생각합니다.DTO란 아래와 같습니다.\n\n\n\n\n\n\nDTO(Data Transfer Object)란?\n계층간 데이터 교환을 위한 객체(Java Bean)이자, DB에서 얻은 데이터를 전송할 때 사용하는 객체.로직(메서드)을 갖지 않는다는 특징이 있으며, DB에서 얻은 값을 수정하는 경우가 거의 없어 setter()는 갖지 않고 getter()만을 갖는 경우가 많다.\n\n즉, DB에서 가져온 정보를 담거나 DB에 저장할 정보를 담는 그릇이 필요한데 그것이 DTO인 것입니다.앞으로의 프로젝트는 데이터베이스의 데이터를 가져오거나 저장하는 동작을 할 것입니다.때문에 DB와의 데이터 교환은 DTO를 통해 진행하도록 하겠습니다.\n참고로 DTO를 검색하면 항상 같이 나오는 DAO라는 용어가 있습니다.\n\n\n\n\n\n\nDAO(Data Access Ocject)란?\nDB에 접근하는 객체로 이름 그대로 Service와 DB를 연결하는 역할을 하는 객체.\n\nDTO와 DAO는 이름이 비슷하고 DB와 관련되어 있다는 공통점때문에 자주 헷갈리니, 여기서 한 번 읽어보고 가도록 합시다!\n5-2 HelloResponseDto 코드 작성클래스 추가가 완료되었다면, 클래스 내부에 다음과 같은 코드를 작성합니다.\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\n\n@Getter\n@RequiredArgsConstructor\npublic class HelloResponseDto &#123;\n    private final String name;\n    private final int amount;\n&#125;\n\n주목해서 봐야할 것은 @Getter와 @RequiredArgsConstructor입니다.이들의 내용은 아래와 같습니다.\n\n\n\n\n\n\n\n\n\n\n@Getter: 선언된 모든 필드의  getter를 생성해줍니다.  \n@RequiredArgsConstructor: final로 선언된 필드가 포함된 생성자를 생성해줍니다.\n\nimport의 경로를 보면 이 2개의 어노테이션은 Lombok 어노테이션이라는 것을 알 수 있습니다.롬복의 어노테이션은 이와같이 코드를 굳이 적지 않아도 내부적으로 생성해주어 코드의 길이를 줄일 수 있습니다.\n5-3 HelloResponseDto의 테스트 코드 작성HelloResponseDto 클래스의 코드 작성이 완료되었습니다.이제 이 코드를 테스트할 테스트 클래스를 생성하고, 아래의 코드를 작성해주세요.\nclass HelloResponseDtoTest &#123;\n    @Test\n    public void 롬복_기능_테스트()&#123;\n        // given\n        String name = &quot;test&quot;;\n        int amount = 1000;\n\n        // when\n        HelloResponseDto dto = new HelloResponseDto(name, amount);\n\n        // then\n        assertThat(dto.getName()).isEqualTo(name);\n        assertThat(dto.getAmount()).isEqualTo(amount);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n@Test: 테스트를 수행하는 메소드를 선언  \nAssertThat(): 테스트 검증 라이브러리인 assertj의 검증 메소드  \nisEqualTo(): assertThat()에 이어사용하는 메소드로 assertj의 동등 비교 메소드\n\n테스트 코드의 작성이 완료되었습니다! 그럼, 테스트를 실행해봅시다.\n5-4 error: variable name not initialized in the default constructor 메시지의 해결테스트 코드를 실행하면, error: variable name not initialized in the default constructor라는 에러 메시지가 표시됩니다.번역하자면 디폴트 생성자에서 변수의 이름이 초기화되지 않았다는 의미입니다. 이 메시지는 뭘까요?이 에러 메시지는 롬복이 제대로 주입(DI)되지 않았을 때에 발생하는 에러입니다.그렇다면 이전에 추가해주었던 의존성이 잘못된 걸까요?정답부터 말하자면, 단순히 gradle의 버전과 관련된 문제입니다.gradle5 버전부터는 어노테이션을 구별해서 추가해주지 않으면 제대로 주입되지 않습니다.때문에 Lombok Gradle plugin을 추가하거나, annotationProcessor에 Lombok을 추가하여 컴파일 범위를 지정해주어야 합니다.(출처 : Project Lombok)\n// Lombok Gradle plugin을 추가하는 방법\nplugins &#123;\n  id &quot;io.freefair.lombok&quot; version &quot;6.0.0-m2&quot;\n&#125;\n\n// annotationProcessor를 추가하는 방법\ndependencies &#123;\n    compileOnly &#39;org.projectlombok:lombok:1.18.20&#39;\n    annotationProcessor &#39;org.projectlombok:lombok:1.18.20&#39;\n&#125;\n\n여기서는 Lombok Gradle plugin을 추가하는 방법을 사용하여 에러 메시지를 해결하도록 하겠습니다.그럼, build.gradle의 plugins { } 안에 위의 코드를 추가하고, gradle을 reload 해주세요.\n[그림5-2] Lombok Gradle plugin 추가\n이제 다시 테스트를 실행하면, 에러 메시지가 없어지고 tests passed가 되는 것을 볼 수 있습니다.이렇게 되면 롬복의 @Getter 어노테이션으로 get메서드가, @RequiredArgsConstructor로 생성자가 자동으로 생성된 것입니다.\n그럼 HelloController에도 새로만든 ResponseDto를 사용하도록 코드를 추가해봅시다!\n5-5 HelloController가 ResponseDto를 사용하도록 수정HelloController클래스의 hello 메서드를 아래의 코드처럼 변경합니다.\n@GetMapping(&quot;/hello/dto&quot;)\npublic HelloResponseDto helloDto(@RequestParam(&quot;name&quot;) String name,\n                                 @RequestParam(&quot;amount&quot;) int amount)&#123;\n   return new HelloResponseDto(name, amount);\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n@RequestParam(“paramName”): 외부에서 API로 넘긴 파라미터를 가져오는 어노테이션→ 위의 코드에서는 외부에서 name으로 넘긴 파라미터를 String name 변수에 저장해 사용\n\n이제, 변경한 코드가 제대로 동작하는지 확인하기 위해 HelloControllerTest에 테스트 코드를 추가하겠습니다.\n5-6 HelloControllerTest에 테스트 코드 추가아래의 임포트를 추가해주세요. 이 임포트는 is 메서드를 사용하기 위해 추가합니다.is()는 내부적으로 equalTo()와 같은 것으로 가독성을 증진시키기 위해 사용하는 메서드입니다.\nimport static org.hamcrest.Matchers.is;\n\n아래의 테스트 메서드를 추가해주세요.\n@Test\npublic void helloDto가_리턴된다() throws  Exception &#123;\n    String name = &quot;hello&quot;;\n    int amount = 1000;\n\n    mvc.perform(get(&quot;/hello/dto&quot;)\n                .param(&quot;name&quot;, name)\n                .param(&quot;amount&quot;, String.valueOf(amount))\n    )\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(&quot;$.name&quot;, is(name)))\n            .andExpect(jsonPath(&quot;$.amount&quot;, is(amount)));\n&#125;\n\n\n\n\n\n\n\n\n\n\n\nparam(): API 테스트할 떄 사용될 요청 파라미터를 설정합니다. 단, 값은 String만 허용됩니다.\njsonPath(): JSON 응답값을 필드별로 검증할 수 있는 메소드입니다. $를 기준으로 필드명을 명시합니다.\n\n이제 추가된 API의 테스트를 실행해봅시다.\n[그림5-3] helloDto 테스트 메서드 추가\n테스트가 문제없이 통과되는 것을 확인하실 수 있습니다.\n\n기존 코드를 롬복을 사용해 리팩토링 해보았습니다. DTO의 코드가 짧은걸 느낄 수 있으신가요?원래라면 DTO에 Getter, Constructor, toString 같은 요소를 전부 적어주어야 합니다.하지만, 롬복을 통해 어노테이션 두 개와 속성 두 개로 DTO의 코드가 해결되었습니다.앞으로의 코드는 이 유용한 라이브러리인 롬복을 이용해서 코드를 작성하도록 하겠습니다.\n","slug":"springboot-web-6","date":"2021-06-16T14:03:34.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"Java,springBoot,Lombok","author_index":"Latte"},{"id":"4f4324f9c57576ee9b59f6532264f460","title":"4. 프로젝트 설정 확인과 롬복(Lombok)","content":"이 포스트에서는 롬복을 소개하고 프로젝트에 롬복을 추가하여 사용해보도록 하겠습니다.\n롬복(Lombok)자바 개발자들의 필수 라이브러리 롬복(Lombok)은 어노테이션 기반으로 코드를 자동완성 해주는 라이브러리입니다.롬복을 이용하면 생성자 및 Getter와 Setter 등의 코드를 자동완성 시킬 수 있습니다.이런 자동완성을 통해 사용자는 클래스 내에 직접 코드를 작성하지 않아도 해당 메소드를 사용할 수 있게 됩니다.때문에 코드가 단순해지고 가독성이 좋아지는데 이러한 단순화를 코드 다이어트라고 부르기도 합니다.\n그럼, 프로젝트에 롬복을 추가하고 롬복을 기반으로 리팩토링하여 롬복의 코드 자동완성이 어떤 의미인지 살펴보도록 합시다.(리팩토링은 다음 포스트에서 진행됩니다.)\n4-1 롬복 추가그럼 프로젝트에 롬복을 추가해봅시다.추가 방법은 build.gradle의 dependencies에 다음의 코드를 추가하는 것입니다.\ndependencies &#123;\n    compileOnly group: &#39;org.projectlombok&#39;, name: &#39;lombok&#39;, version: &#39;1.18.20&#39;\n&#125;\n\n[그림4-1] Lombok 의존성 추가\nbuild.gradle에 롬복 의존성을 추가하였으니, gradle을 빌드하여 롬복을 프로젝트에 내려받도록 합니다!\n4-2 롬복 플러그인 추가gradle을 통해 롬복 라이브러리의 임포트가 완료되었다면, 이번엔 롬복 플러그인을 설치합니다.인텔리제이에서 플러그인 설치는 plugins에서 가능하며 윈도우는 [Ctrl + Shift + A], 맥은 [Command + Shift + A] 를 누른 후, plugins를 검색하여 이동이 가능합니다.  \n[그림4-2] intellij plugins로 이동\nPlugins의 MarketPlace 탭으로 이동하여 Lombok을 검색하고 설치한 후 인텔리제이를 재시동해줍니다.\n[그림4-3] Lombok plugin 설치\n(저는 이미 플러그인을 설치한 상태라 installed에 표시됩니다. 처음 설치하시는 분은 Marketplace에 표시될겁니다.)\n4-3 Lombok Annotation Processing 셋팅이번에는 Lombok Annotation Processing을 설정하도록 하겠습니다.롬복을 추가하고, 플러그인까지 설치했는데 빌드를 하면You aren&#39;t using a compiler supported by lombok, so lombok will not work and has been disabled.라는 에러 메시지가 뜨면서 빌드에 실패하게 될겁니다.이런 문제를 해결하기 위해서는 annotation processing을 체크하여 인텔리제이가 롬복을 사용할 수 있게 설정해주어야 합니다.\n먼저, 인텔리 제이의 Preferences로 이동하여 Annotation Processor를 검색하여 해당 메뉴로 이동합니다.해당 메뉴에서 “Enable annotation processing”을 체크하면 설정 완료 입니다.\n[그림4-4] Lombok Annotation Processing 설정\n\n\n\n\n\n\nTIP\n롬복의 플러그인 설치는 한 번이면 끝나지만, Enable Annotation Processing은 프로젝트마다 설정해주어야 합니다.새로운 프로젝트를 만들게된다면 잊지말고 설정해주세요!\n\n\n이제, 롬복의 셋팅이 완료되었습니다!다음 포스트에서는 기존 코드를 롬복을 이용해 리팩토링 하는 시간을 갖겠습니다.\n","slug":"springboot-web-5","date":"2021-06-14T03:18:58.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,java,Lombok","author_index":"Latte"},{"id":"4db30505bd3613ad654d9a53e43df5c4","title":"2. 탐욕 알고리즘(Greedy Algorithm)","content":"이번 포스트에서는 탐욕 알고리즘(Greedy Algorithm)에 대해서 정리하겠습니다.사실 코딩 테스트에서 탐욕 알고리즘은 출제 빈도가 낮은 편에 속합니다.(프로그래머스 기준)그럼에도 탐욕 알고리즘을 정리하는 이유는 이를 공부하다보면 알고리즘 문제의 원리를 깨닫는 능력을 향상시키는 데에 도움이 될 것이라 생각했기 때문입니다.즉, 탐욕 알고리즘의 정리를 통해 문제가 요구하는 최소한의 원리를 떠올릴 수 있는 능력을 키워보려 합니다.\n탐욕 알고리즘 (Greedy Algorithm)1. 정의탐욕 알고리즘(Greedy Algorithm)은 매 순간 가장 좋아보이는 최적의 선택을 하는 방법으로 진행하여 최종적인 해답에 도달하는 방식입니다.Greedy라는 단어는 “탐욕”이라는 뜻을 가지므로 국내에서는 탐욕 알고리즘으로 불립니다. (이하 탐욕 알고리즘)\n그리디 알고리즘은 가장 좋아보이는 것이라는 기준이 존재하므로 문제에서 “가장 큰 순서대로”, “가장 작은 순서대로”와 같은 기준을 알게 모르게 제시해줍니다.때문에 그리디 알고리즘은 정렬 알고리즘과 짝을 이뤄 출제되는 경우가 많습니다.\n2. 문제탐욕 알고리즘의 가장 유명한 예시는 동전 문제 입니다.거스름 돈 문제를 예를 들어 탐욕 알고리즘을 설명하겠습니다.(아래의 문제는 나동빈님의 저서 「이것이 취직을 위한 코딩 테스트다 with 파이썬」에서 발췌한 문제입니다)\n\n\n\n\n\n\n거스름 돈\n당신은 계산을 도와주는 점원입니다.카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재합니다.손님에게 거슬러주어야할 돈이 N원일 때, 거슬러 줘야 할 동전의 최소 개수는 몇 개인가요?단, 거슬러 줘야할 돈 N은 항상 10의 배수입니다.\n\n동전의 개수를 최소화 하는 것이 이 알고리즘의 목적입니다.그럼 동전의 개수를 최소화 하기 위해서는 어떻게 해야할까요?생각을 잘 정리해봅시다. 저는 아래와 같이 생각이 흘러갔습니다.\n\n\n\n\n\n\n\n\n\n\n동전의 종류를 살펴보면, 500원은 100원을 5개 모아야하고, 50원은 10원을 5개 모아야 한다.  \n동전이 여러 개 모이면 큰 금액의 동전이 된다.  \n동전의 개수를 줄이기 위해서는 큰 금액의 동전을 먼저 사용하는 것이 유리하다.\n\n저는 이런식으로 “가장 큰 화폐 단위부터 돈을 거슬러주어야 동전의 개수가 최소화된다” 라는 생각을 유추해냈습니다.그럼 이 생각을 코드로 짜기위해서 어떻게 해야할지 고민해보겠습니다. (자바 기준 서술)\n\n\n\n\n\n\n\n\n\n\n동전 종류를 담는 배열에 동전의 금액이 큰 것부터 내림차순으로 선언한다.\n동전의 개수를 셀 변수를 선언한다.\n동전의 종류를 돌면서 거슬러줄 수 있는 만큼 거슬러주고, 그만큼을 동전의 개수에 추가한다.\n거슬러준 금액을 원래의 금액에서 차감한다.\n\n이것이 제가 생각한 알고리즘의 흐름이고, 이것을 자바로 표현하면 아래와 같습니다.\npublic static void main(String[] args) &#123;\n        int n = 1260;\n        int [] coins = &#123;500, 100, 50, 10&#125;;\n        int coin_count = 0;\n\n        for (int i = 0; i &lt; coins.length; i++) &#123;\n            int coin = n / coins[i];\n            coin_count += coin;\n            n -= (coin * coins[i]);\n        &#125;\n        System.out.println(coin_count);\n&#125;\n\n3. 주의점-1 : 탐욕 알고리즘이 아닐 가능성탐욕 알고리즘은 탐욕적으로 문제에 접근했을 때, 정확한 답을 찾을 수 있다는 보장이 있을 때에는 매우 효과적이고 직관적입니다.위의 문제를 그리디 알고리즘으로 해결할 수 있는 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문입니다.즉, 큰 단위가 작은 단위의 배수 형태이기에 큰 동전부터 거슬러주고, 작은 동전을 거슬러준다는 말이 성립되는 겁니다. \n예를 들어 만들어야 하는 금액이 800원이고, 화폐의 단위가 100원, 400원, 500원이라면 그리디 알고리즘은 500원 1개과 100원 3개의 조합을 생각해낼 것입니다.그러나 가장 효과적인 조합은 400원짜리 2개입니다.때문에 화폐의 배열이 무작위인 경우, 그리디 알고리즘으로는 해결할 수 없으니 주의할 필요가 있습니다.\n4. 주의점-2 : 탐욕 알고리즘은 결과가 전체적으로 최적이 아닐 가능성탐욕 알고리즘은 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않습니다.때문에 선택의 순간마다 하는 선택은 최적이지만, 이것이 전체적으로 최적이라는 보장은 없습니다. \n그러나 어떤 특별한 구조가 있는 문제에 대해서는 탐욕 알고리즘이 언제나 최적해를 찾아낼 수 있는데 이 구조를 매트로이드라고 합니다.\n\n지금까지 탐욕 알고리즘의 정의와 기본 원리에 대해서 알아보았습니다.탐욕 알고리즘에서 중요한 것은 아래의 두 가지 입니다.\n\n\n\n\n\n\n\n\n\n\n문제가 요구하는 최소한의 원리를 알아낼 수 있는가\n이것이 탐욕 알고리즘이라는 확신이 있는가\n\n이 두 가지를 가슴에 새기고, 다양한 문제를 풀어보며 감을 익혀가도록 합시다.탐욕 알고리즘에 관해서는 여기까지 적도록 하겠습니다.\n","slug":"algorithm-greedy","date":"2021-06-13T01:27:11.000Z","categories_index":"알고리즘 & 코딩 테스트","tags_index":"algorithm,Greedy","author_index":"Latte"},{"id":"d6a03e07ef9853873ef42e3c7ea6ee4a","title":"1. 알고리즘의 복잡도","content":"프로그래밍 공부를 하는 사람이라면 “복잡도(Complexity)”라는 단어를 한 번 쯤은 들어봤을겁니다.그런데 이게 대~충은 알 것 같은데 막상 누군가에게 복잡도에 대해서 설명하려고 하면 설명하기 어려운 경우가 많습니다.때문에 이 포스트에서는 알고리즘과 관련된 개념을 정리하는 시간을 가져보려고 합니다.\n1. 복잡도(Complexity)복잡도는 알고리즘의 성능을 나타내는 척도로 문제를 해결하는 데에 알고리즘이 얼마나 복잡하게 문제를 해결하는 지를 나타냅니다. 복잡도는 크게 시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)로 구분됩니다.\n\n시간 복잡도 : 알고리즘이 어떤 문제를 해결하는 데에 걸리는 시간\n공간 복잡도 : 알고리즘이 어떤 문제를 해결하는 데에 차지하는 메모리\n\n즉, 시간 복잡도는 알고리즘의 수행시간을, 공간 복잡도는 알고리즘의 메모리 사용량을 나타냅니다.  \n동일한 기능을 수행하는 알고리즘이 있다면 일반적으로 복잡도가 낮을수록 좋은 알고리즘입니다.복잡도를 표현할 때에는 빅오(Big-O)표기법을 사용하는데 이에 대한 자세한 내용은 아래에서 다루도록 하겠습니다.\n1-1 시간 복잡도(Time Complexity)시간 복잡도는 알고리즘이 문제를 해결하기 위한 연산의 횟수를 말합니다.프로그램이 비효율적으로 작성되어 연산 횟수가 증가하는 경우, 시간 복잡도도 증가하게 됩니다.알고리즘 문제에서 단순히 복잡도라고 하면, 보통 이 시간 복잡도를 의미합니다.  \n\n\n\n\n\n\n\n\n\n보통 시간 복잡도에서의 “연산”은 프로그래밍 언어에서 지원하는 사칙 연산, 비교 연산 등과 같은 기본 연산을 의미합니다.\n1-2 공간 복잡도(Space Complexity)공간 복잡도는 알고리즘의 동작을 위해 필요한 메모리의 양을 의미합니다.최근에는 주기억장치인 RAM의 용량이 커져서 중요도가 낮아졌지만, 임베디드나 펌웨어 환경 등 하드웨어 환경이 매우 한정되어 있는 분야에서는 중요하게 고려되어야 합니다.\n시간 복잡도와 공간 복잡도는 반비례하는 경향이 있습니다.최근에는 공간 복잡도보다 시간 복잡도를 더 중요하게 생각하므로 메모리를 더 많이 사용해서 실행 시간을 비약적으로 줄이기도 하는데 이러한 기법을 메모이제이션(memoization)이라고 합니다.\n\n\n\n\n\n\n메모이제이션(memoization)\n컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술로, 동적 계획법의 핵심이 되는 기술입니다. (출처 : 위키피디아 - 메모이제이션)\n\n2. 빅오 표기법(Big-O)빅오 표기법은 점근 표기법 중 하나로 최악의 경우를 우선적으로 고려하는 방식입니다.\n\n\n\n\n\n\n점근 표기법(asymptotic notation)\n어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법으로 알고리즘의 복잡도를 단순화할 때나 무한급수의 뒷부분을 간소화할 때 사용됩니다. (출처 : 위키피디아 - 점근 표기법)\n\n2-1 시간 복잡도의 빅오 표기법시간 복잡도의 빅오 표기법은 다음과 같습니다. 위에서 아래로 내려갈 수록 시간 복잡도가 증가합니다.  \n\n\n\n빅오 표기법\n명칭\n특징\n\n\n\nO(1)\n상수 시간(Constant time)\n주어진 입력 자료에 관계 없이 일정한  연산 시간\n\n\nO(logN)\n로그 시간(Logt ime)\n이진트리나 이진탐색에서 찾아 볼 수 있는 연산 시간. 시간이 지날수록 작업을 수행하는 단계가 반 씩 줄어드는 특징을 지님\n\n\nO(N)\n선형 시간(Linear time)\n수행시간이 입력 크기에 따라 선형적으로 증가함을 의미\n\n\nO(NlogN)\n선형 로그 시간(Linearithmic time)\nn log n 수행시간은 간단히 Θ(log n) 연산의 n 배 수행시간의 결과 가짐\n\n\nO(N²)\n이차 시간\n작업을 수행하는데 걸리는 단계의 수가 n의 제곱\n\n\nO(N³)\n삼차 시간\n작업을 수행하는데 걸리는 단계의 수가 n의 세제곱\n\n\nO(2N)\n지수 시간\n작업을 수행하는 데 걸리는 단계의 수가 n의 크기에 따라 일정함\n\n\n(출처 : 위키피디아 - 시간 복잡도)(출처 : [알고리즘] 시간 복잡도, 공간 복잡도, 빅오(Big O))\n2-2 공간 복잡도의 빅오 표기법시간 복잡도를 이해하셨다면 공간 복잡도의 빅오 표기를 이해하는 데에 어려움이 없을 겁니다.예를들어, 크기가 n인 배열을 만들고 싶다면 O(n)의 공간이 필요하고, 크기가 n인 2차원 배열을 만들고싶다면 O(n²)의 공간이 필요합니다.\n공간 복잡도의 경우 메모리 사용량의 기준은 MB로 표시됩니다. 보통 코딩테스트에서는 메모리 사용량을 128~512MB로 제한합니다.이는 데이터의 개수가 1,000만 단위가 넘어가지 않게 설계해야한다는 의미입니다.\n\n여기까지, 간단하게 복잡도에 대해서 알아보았습니다.사실, 좀 더 깊이 들어가면 수학적 계산도 필요하고 알아볼 내용이 더 많습니다.하지만, 이번 포스트의 목표가 복잡도의 개념을 설명할 수 있게 되는 것이기에 여기까지만 정리하도록 하겠습니다.다음에는 기초적인 알고리즘에 대해 정리해보도록 하겠습니다.\n","slug":"algorithm-complexity","date":"2021-06-12T12:42:51.000Z","categories_index":"알고리즘 & 코딩 테스트","tags_index":"algorithm,complexity","author_index":"Latte"},{"id":"1bc1fccedcb28371ce507abc90a2b06f","title":"3. 프로젝트 설정 확인","content":"이 포스트에서는 이전까지 작성한 프로젝트가 제대로 동작하는지 테스트하도록 하겠습니다.테스트코드를 작성하기 전에 기능테스트를 위한 간단한 API를 작성해보겠습니다.\n“hello”를 반환하는 GET method API 만들기3-1 패키지 생성프로젝트에서 경로 src &gt; main &gt; java 디렉토리 에 패키지를 생성합니다.일반적으로 패키지명은 웹 사이트 주소의 역순으로 작성합니다. 저는 com.dev.latte.springboot로 작성했습니다.\n[그림3-1] 패키지 생성\n3-2 Application 클래스 생성방금 작성한 패키지에 Application이라는 이름으로 자바 클래스파일을 추가해줍니다.여기서 주의할 것은 경로가 다르면 안된다는 것과 클래스의 맨 첫글자가 대문자라는 것입니다.이는 자바의 명명규칙으로 자바의 클래스 이름의 첫 글자는 항상 대문자로 작성되어야 합니다.자바 명명규약(Naming Rule)은 기회가 된다면 다루어보도록 하겠습니다.\n[그림3-2] Application 클래스 생성\n3-3 클래스 내용 작성Application 클래스에 아래의 코드를 작성합니다.지금 작성하는 Application.class는 프로젝트의 메인클래스가 됩니다!\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Application.class, args);\n    &#125;\n&#125;\n\n\n\n\n\n\n\nimport가 자동으로 추가되지 않는다면?\n    import가 자동으로 추가되지 않는다면, 추가되지 않아 붉게 변한 코드로 이동한 후 윈도우는 [alt + enter], 맥은 [option + enter]를 눌러 직접 import해주세요.\n\n\n\n\n\n\n\n\n\n\n\n@SpringBootApplication: 스프링 부트의 자동 설정, 스프링 bean읽기와 생성을 모두 자동으로 설정하기 위한 어노테이션입니다. 프로젝트는 이 어노테이션이 있는 지점부터 설정을 읽어가기 때문에 @SpringBootApplication이 붙어있는 클래스는 항상 프로젝트 최상단에 위치해야합니다.\nSpringApplication.run 메서드: 이 메서드는 내부 WAS를 실행합니다. 때문에 톰캣이 필요 없다는 장점이 있으며 스프링 부트에서도 내장 WAS를 사용하는 것을 권장하고 있습니다.\n\n3-4 테스트를 위한 Controller의 패키지 생성현재 패키지(com.dev.latte.springboot)의 하위에 web 패키지를 만들어보겠습니다.앞으로 컨트롤러와 관련된 클래스들은 모두 이 패키지에 담겠습니다.\n3-5 Controller 생성 및 코드 작성web 패키지 아래에 테스트를 시행할 컨트롤러를 만들어 보겠습니다.클래스이름은 HelloController이며 내부 코드는 다음과 같습니다.\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController &#123;\n    @GetMapping(&quot;/hello&quot;)\n    public String hello()&#123;\n        return &quot;hello&quot;;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n@RestController: 컨트롤러를 JSON객체를 반환하는 컨트롤러로 만들어줍니다.  \n@GetMapping: GET요청을 받는 API를 만들어줍니다.\n\n기능 테스트3-6 Controller의 기능 테스트를 위한 클래스 생성작성한 코드가 제대로 작동하는지 테스트하겠습니다.방금 생성한 HelloController의 클래스 이름 위에 커서를 두고, 윈도우는 [alt + enter], 맥은 [option + enter]를 누른 후, create test를 선택하여 그대로 테스트 클래스를 생성해주세요.\n[그림3-3] 테스트 클래스 생성\n생성된 테스트 클래스의 내부 코드를 아래와 같이 작성해주세요.\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n\n@WebMvcTest(controllers = HelloController.class)\nclass HelloControllerTest &#123;\n    @Autowired\n    private MockMvc mvc;\n\n    @Test\n    public void hello가_리턴된다() throws Exception &#123;\n        String hello = &quot;hello&quot;;\n        mvc.perform(get(&quot;/hello&quot;))\n                .andExpect(status().isOk())\n                .andExpect(content().string(hello));\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n@WebMvcTest: MVC Controoler를 위한 테스트로 동작이 예상한대로 동작하는지 확인하는 데에 사용한다.\n@Autowired: 해당 변수 및 메서드에 스프링이 관리하는 Bean을 자동으로 매핑해준다. (스프링 의존성 주입)\n@Test: 테스트를 수행하는 메소드를 선언한다.\n\n책에서는 @WebMvcTest() 어노테이션 위에 @RunWith(SpringRunner.class) 어노테이션이 작성되어 있지만, 이 코드에서는 적지 않습니다.그 이유는 JUnit의 버전이 책과 다르기 때문입니다. [그림3-3]을 보면 이 테스트 클래스는 JUnit5버전입니다. @RunWith() 어노테이션은 JUnit4버전에 존재하는 어노테이션으로 JUnit5버전으로 올라오면서 @ExtendWith()로 대체되었습니다. 때문에 @RunWith() 대신에 @ExtendWith()을 사용해야 합니다.(출처 : @RunWith no longer exists; superseded by @ExtendWith)  \n하지만 이미 스프링 부트가 제공하는 모든 테스트용 어노테이션에는 @ExtendWith()가 메타 어노테이션으로 적용되어 있기 때문에 @ExtendWith(SpringExtension.class)를 생략할 수 있습니다.(출처 : Junit 5 with Spring Boot: When to use @ExtendWith Spring or Mockito?)\n3-7 테스트 코드 실행그럼 작성한 메소드를 테스트해봅시다. 왼쪽에 있는 초록색 삼각형을 눌러서 테스트를 실행해주세요!\n[그림3-4] 테스트 코드 실행\n테스트가 실행되고, 코드에 문제가 없다면 아래와 같이 Tests passed가 표시됩니다.  \n[그림3-5] 테스트 결과화면\n3-8 프로젝트 동작 확인마지막으로 프로젝트가 실제로 잘 동작하는지 확인해보겠습니다.Application.class로 돌아가 메인 메소드를 실행(Run ‘Application’)해주세요.\n[그림3-6] 어플리케이션 실행\n프로젝트가 문제없이 실행되었다면 콘솔 탭에 아래와 같이 표시됩니다.\n[그림3-6] 어플리케이션 실행\n브라우저에서 localhost:8080/hello로 접속해주세요.접속했을 때, 다음과 같이 문자열 hello가 잘 노출된다면 프로젝트가 제대로 동작하고 있는겁니다!\n[그림3-7] API 실행 결과\n\n이제, 웹 서비스를 위한 가장 기초적인 설정을 끝냈습니다.  \n\n스프링 부트 프로젝트 설정  \nAPI 코드 작성 및 테스트방법  \n\n다음 포스트에서는 생산성을 높여주는 라이브러리 롬복에 대해 설명하겠습니다.\n","slug":"springboot-web-4","date":"2021-06-11T02:24:43.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,java,TDD","author_index":"Latte"},{"id":"18c39e99fd033dd5083bccdf6728bd02","title":"2. Gradle을 스프링 부트 프로젝트로 변경","content":"이번 포스트에서는 작성한 프로젝트를 스프링 부트 프로젝트로 변경하는 방법을 설명합니다.의존성 주입을 통해 gradle을 스프링 부트 프로젝트로 변경하도록 하겠습니다.\nGradle을 스프링 부트 프로젝트로 변경2-1 “build.gradle”의 프로젝트의 플러그인 의존성 관리를 위한 설정 코드를 작성우선 프로젝트 내에 위치한 build.gradle의 최상단에 의존성 관리를 위한 설정코드를 작성합니다.코드를 작성하기 전에, 이 포스트에서는 책의 내용과 다른 방식으로 설정 코드를 작성 것을 미리 알려둡니다.그럼 어떻게 다른지 살펴볼까요? 우선, 책에서는 아래와 같이 코드를 작성하고 있습니다.\nbuildscript &#123;\n    ext &#123;\n        springBootVersion = &#39;2.1.9.RELEASE&#39;\n    &#125;\n    repositories &#123;\n        mavenCentral()\n        jcenter()\n    &#125;\n    dependencies &#123;\n        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;)\n    &#125;\n&#125;\n\napply plugin: &#39;java&#39;\napply plugin: &#39;eclipse&#39;\napply plugin: &#39;org.springframework.boot&#39;\napply plugin: &#39;io.spring.dependency-management&#39;\n\n위와 같이 작성하던 도중, gradle.build에 자동으로 생성되어있던 plugins &#123; id &quot;java&quot;&#125;가 눈에 들어왔습니다.\n[그림2-1] 신경쓰이는 존재, plugins { id “java”}\n위에서 작성한 코드에서 apply plugin과 닮은 모습에 혹시 apply plugin을 모아서 사용할 수 있는 건 아닐까 하는 의심이 들었고, 자세한 사항을 알기 위해 검색하게 되었습니다. 검색해보니 plugins &#123;&#125; 은 gradle이 업데이트 되면서 변경된 사항으로 “plugins block”라 불리며, 플러그인을 추가하고, 선택적인 매개변수를 사용하여 적용 시기를 제어할 수 있다는 특징을 지닌다고 합니다.(출처)\n이 업데이트로 위의 코드의 buildscript&#123;&#125;과 apply plugins는 아래와 같이  합쳐서 적는 것이 가능해졌습니다.\nplugins &#123;\n    id &quot;java&quot;\n    id &quot;eclipse&quot;\n    id &quot;org.springframework.boot&quot; version &quot;2.1.9.RELEASE&quot;\n    id &quot;io.spring.dependency-management&quot; version &quot;1.0.11.RELEASE&quot;\n&#125;\n\n\n\n\n\n\n\n\n\n\n플러그인 정보는 이곳에서 확인 가능합니다.\n훨씬 간편하고 보기 좋아졌습니다.이 4개의 플러그인은 자바와 스프링 부트를 사용하기 위해 반드시 추가해야함을 잊지 말아주세요!그럼, gradle을 마저 추가해봅시다.\n2-2 dependencies에 개발에 필요한 의존성들을 선언dependencies에 개발에 필요한 의존성들을 선언합니다.책에서는 compile을 사용하였으나, 여기서는 implementation을 사용합니다.implementation을 사용하는 이유가 몇 가지 있습니다만, 가장 큰 이유는 compile이 gradle7+ 버전에서 삭제되었다는 것입니다.그 외에도 이유는 많지만, 이 포스트는 프로젝트 생성을 위한 자리이니 자세한건 다음에 다루어보겠습니다.혹시, 이 사항에 관심있으신 분을 위해 아래의 포스트 주소를 남기니 확인해보시길 바랍니다.\n\n\n\n\n\n\n\n\n\nGradle implementation vs. compile dependencies\n그럼, build.gradle의 dependencies에 다음의 의존성을 추가해봅시다.\ndependencies &#123;\n    implementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-web&#39;, version: &#39;2.4.5&#39;\n    testImplementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-test&#39;, version: &#39;2.4.5&#39;\n&#125;\n\n2-3 자바의 버전을 1.8로 설정해줍니다.이제 자바 소스 코드의 버전을 1.8로 설정해보겠습니다. 참고로, 제 컴퓨터에 설치되어있는 JDK는 13입니다.그럼에도 불구하고 1.8로 설정하는 이유는 책과의 환경 차이에서 생기는 오류를 줄이기 위함입니다.책에서는 스프링 부트 2.1.9.RELEASE 버전을 사용하며 gradle은 4.8~4.10 버전을 사용하고 있습니다.JDK 13은 스프링 부트 2.2.x 버전 이상, gradle은 6버전 이상만이 지원하기 때문에 스프링 부트의 버전업이 불가피합니다.스프링 부트의 버전업으로 인해 어떤 오류가 생길지 모르니 초반에는 JDK 1.8로 프로젝트를 진행하고, 후에 기회가 된다면 스프링 부트 업그레이드 후 13으로 변경하여 작업해보도록 하겠습니다.그럼, version아래에 다음과 같은 코드를 추가해주세요.\nsourceCompatibility = 1.8\n\n이 코드는 자바 소스 코드의 버전을 의미합니다.\n2-4 build.gradle작성이 완료된 build.gradle의 전체 코드는 아래와 같습니다.\nplugins &#123;\n    id &quot;java&quot;\n    id &quot;eclipse&quot;\n    id &quot;org.springframework.boot&quot; version &quot;2.1.9.RELEASE&quot;\n    id &quot;io.spring.dependency-management&quot; version &quot;1.0.11.RELEASE&quot;\n&#125;\n\ngroup &#39;com.dev.latte&#39;\nversion &#39;1.0-SNAPSHOT&#39;\nsourceCompatibility = 1.8\n\nrepositories &#123;\n    mavenCentral()\n&#125;\n\ndependencies &#123;\n    implementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-web&#39;, version: &#39;2.4.5&#39;\n    testImplementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-test&#39;, version: &#39;2.4.5&#39;\n&#125;\n\ntest &#123;\n    useJUnitPlatform()\n&#125;\n\n2-5 Gradle 반영하기그레이들 작성이 완료되었다면, 인텔리제이 상단에 있는 Reload 버튼(순환마크)을 클릭하여 그레이들을 반영합니다.\n[그림2-2] gradle import\n버튼을 클릭하면, 인텔리제이 하단에 그레이들의 반영 상황이 표시되고, 반영이 끝나면 Gradle sync finished가 표시됩니다.\n\n이제 스프링 부트 프로젝트의 기본 셋팅이 완료되었습니다!다음 포스트에서는 프로젝트의 설정이 제대로 되었는지 확인해보도록 하겠습니다.\n","slug":"springboot-web-3","date":"2021-06-10T00:46:49.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"Java,gradle,springBoot","author_index":"Latte"},{"id":"a01df8c8fb60fb63504058a17ab9f187","title":"1. IntelliJ 프로젝트 생성","content":"이 포스트에서 IntelliJ의 설치는 다루고 있지 않습니다. IntelliJ의 설치는 다른 분의 블로그나 웹을 참고해주세요.  \n\n\n\n\n\n\nIntelliJ IDEA\n    - IntelliJ는 기본적으로 유료툴이지만 community버전은 무료로 이용 가능합니다.    - 학생이시라면 1년 간 Ultimate버전 제품을 무료로 사용 가능합니다.\n\nIntelliJ 프로젝트 생성프로젝트 생성 전에, 이 포스트에서는 프로젝트 생성시 Spring Initializer를 사용하지 않습니다.왜 이 방식을 사용하는지 설명하겠습니다.  일단, 스프링 프로젝트를 생성하는 방법은 두 가지가 있습니다.  \n\nSpring Initializer를 이용하는 방법  \n프로젝트 생성 후, 의존성을 추가하는 방법\n\n첫 번째 방법은 간단하지만, 의존성 주입이나 build.gradle 등을 이해하지 않은 상태로 사용할 경우 오히려 혼란스러울 수 있습니다.때문에 이 포스트는 Spring Initializer를 사용하지 않고 간단한 프로젝트를 생성 후, 필요할 때마다 의존성을 추가합니다.\n이제 프로젝트를 생성해봅시다. \n1-1 프로젝트 생성“Create new Project” 혹은 “New Project” 버튼을 클릭합니다.\n[그림1-1] 프로젝트 생성\n1-2 프로젝트 Gradle 설정아래와 같은 창이 뜨면 이하와 같이 설정합니다.  \n[그림1-2] 프로젝트 Gradle 셋팅(JDK 버전은 신경쓰지 않으셔도 괜찮습니다. 나중에 build.gradle에서 1.8로 제어할 예정입니다.)\n설정이 끝났다면, Next를 클릭하여 다음으로 이동해주세요.\n1-3 GroupId와 ArtifactId 등록GroupId와 ArtifactId를 등록합니다.\n[그림1-3] 프로젝트 GroupId &amp; ArtifactId 등록  \n여기서 ArtifactId는 프로젝트의 이름이 됩니다.\n1-4 finish를 클릭하면 프로젝트 빌드가 시작됩니다.\n\n\n\n\n\n\n\n\n위의 과정 중간에 프로젝트의 경로를 정하는 창이 뜰 수도 있습니다. 당황하지 마시고 프로젝트가 저장될 위치를 저장해주세요.\n\n이제 Gradle기반의 자바 프로젝트가 완성되었습니다!다음 포스트에서는 이 프로젝트를 스프링 프로젝트로 변경해보도록 하겠습니다.\n","slug":"springboot-web-2","date":"2021-06-09T12:36:23.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"Java,gradle,springBoot","author_index":"Latte"},{"id":"681e8e55f24e67b1822965c116da3835","title":"0. 개요","content":"이 카테고리는 이동욱님의 저서 「스프링 부트와 AWS로 혼자 구현하는 웹 서비스」를 기반으로 혼자 연습하며 문제를 해결해가는 카테고리입니다.기본적으로 책을 따라 진행하며, 프로젝트 전반의 흐름 및 진행하면서 생기는 버그의 해결문제를 기록합니다.또한 이 포스트에서 진행하는 프로젝트 환경은 책과 다른 점이 존재하니, 이런 부분을 확인하면서 포스트를 봐주시기 바랍니다.  \n\n\n\n\n\n\n환경\n    - 블로그 : intelliJ IDEA / Java8(JDK 1.8) / Gradle 6.8    - 책 : intelliJ IDEA / Java8(JDK1.8) / Gradle 4.8 ~ Gradle 4.10.2\n\n개인적으로 상냥하게 설명된 책이니 구매하셔서 보시는 것도 추천드립니다. (책 이름에 yes24 링크가 걸려있습니다)\n또한 기본적인 버그는 이동욱님의 공식 깃허브에서 논의되고 있으니 이쪽도 확인해보세요.  \n궁극적인 목표는 “서비스를 처음부터 끝까지 혼자 만드는 것!” 이지만 공부를 하기 위함도 있습니다.때문에 프로그램이나 프레임워크가 왜 그렇게 동작하는지를 알기 위해 삼천포로 빠지는 경우가 많을 것 같습니다.글이 길어질 것 같은 경우, 다른 게시글에 정리할 예정이니 관심있으신 분은 링크를 타고 이동해주세요.\n그럼, 시작하겠습니다 :D\n","slug":"springboot-web-1","date":"2021-06-08T12:36:23.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"Java,gradle,springBoot","author_index":"Latte"},{"id":"3b9e4a33c5246d01da88767642ae37d5","title":"markdown page","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-06-07T12:36:23.000Z","categories_index":"","tags_index":"hexo,aurora","author_index":"Latte"}]