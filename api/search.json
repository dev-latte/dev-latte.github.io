[{"id":"9823f8c5a18f804c1c6c693243f76046","title":"5. DFS/BFS","content":"CS에서 탐색(Search)이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 의미합니다.프로그래밍에서는 주로 자료구조 안에서 탐색하는 경우가 많습니다.(자료구조에 대한 자세한 설명은 여기에서 확인해주세요)\n5. DFS(깊이 우선 탐색) / BFS(너비 우선 탐색)5-1-1 DFS(Depth-First Search) - 깊이 우선 탐색DFS(Depth-First Search)는 깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘입니다.DFS를 설명하기 위해서는 그래프의 기본 구조부터 알아야합니다.(그래프의 자세한 설명은 이 포스트를 참고해주세요)\n이 알고리즘을 설명하기 위해 필요한 그래프의 개념은 노드(Node) 와 간선(Edge) 입니다.(노드를 정점_Vertex이라고도 합니다.)\n그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말하며, 여기서 두 노드가 간선으로 연결되어 있다면 ‘두 노드는 인접하다(Adjacent)’ 라고 표현합니다.\n5-1-2 그래프의 표현방식프로그래밍에서 그래프는  인접 행렬(Adjacency Matrix) 과 인접 리스트(Adjacency List) 두 가지 방식으로 표현할 수 있습니다.코딩테스트에서는 이 두 방식 모두 필요하니 두 개념에 대해 바르게 알고가도록 합시다.(자세한 내용은 그래프 관련 포스팅을 참고해주세요)\n5-1-3 DFS의 동작 방식이 알고리즘은 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙하게 들어가서 노드를 방문한 후, 다시 돌아가 경로를 탐색하는 탐색 알고리즘입니다.DFS는 스택 자료구조를 이용하며, 구체적인 동작 과정은 다음과 같습니다.\n\n\n\n\n\n\nDFS 과정\n\n탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.\n스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면, 그 인접 노드를 스택에 넣고 방문처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.\n2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.\n\n\n\n그럼, 이 과정을 그래프를 통해서 살펴봅시다. 아래에 다음과 같은 그래프가 있습니다.\n[그림5-1] 그래프 예시\n[노드 1]을 시작 노드로 설정하여 DFS를 진행해봅시다!\n\n\n\n\n\n\nDFS의 탐색 순서\n(일반적으로 인접한 노드 중에서 방문하지 않은 노드가 여러 개 존재할 경우 번호가 낮은 순서부터 처리합니다)\n\n시작 [노드 1] 을 스택에 삽입하고 방문 처리를 합니다.\n[노드 1]의 인접 노드인 [노드 2]와 [노드 3], [노드 8] 중에 가장 작은 [노드 2] 를 스택에 넣고 방문 처리합니다.\n[노드 2]의 인접 노드인 [노드 7] 을 스택에 넣고 방문 처리합니다.\n[노드 7]의 인접 노드인 [노드 6]과 [노드 8] 중에 가장 작은 [노드 6] 을 스택에 넣고 방문 처리합니다.\n[노드 6]은 인접 노드가 없으므로 스택에서 [노드 6] 을 꺼냅니다.\n다시 [노드 7]로 돌아가 방문하지 않은 [노드 8] 을 스택에 넣고 방문 처리합니다.\n[노드 8]은 인접 노드가 없으므로 스택에서 [노드 8] 을 꺼냅니다.\n다시 [노드 7]로 돌아갑니다. [노드 7]에서 방문하지 않은 인접 노드가 없으므로 스택에서 [노드 7] 을 꺼냅니다.\n다시 [노드 2]로 돌아갑니다. [노드 2]에서 방문하지 않은 인접 노드가 없으므로 스택에서 [노드 2] 를 꺼냅니다.\n시작 노드인 [노드 1]로 돌아갑니다.\n[노드 1]의 인접 노드인 [노드 3] 을 스택에 넣고 방문 처리합니다.\n[노드 3]의 인접 노드인 [노드 4]와 [노드 5]중에 숫자가 더 작은 [노드 4] 를 스택에 넣고 방문 처리합니다.\n[노드 4]의 인접 노드인 [노드 5] 를 스택에 넣고 방문 처리합니다.\n[노드 5]는 인접 노드가 없으므로 스택에서 [노드 5] 를 꺼냅니다.\n이제 방문하지 않은 노드가 없습니다. 스택에서 남은 노드를 하나씩 꺼내주면 탐색이 종료됩니다.\n\n\n\n결과적으로 노드의 탐색 순서는 다음과 같습니다.\n\n\n\n\n\n\n\n\n\n노드 1 → 노드 2 → 노드 7 → 노드 6 → 노드 8 → 노드 3 → 노드 4 → 노드 5\n또한, DFS는 스택을 이용하는 알고리즘이기 때문에 실제 구현은 재귀함수를 이용했을 때 매우 간결하게 구현할 수 있습니다.\n5-2-1 BFS(Breadth-First Search) - 너비 우선 탐색BFS(Breadth-First Search) 알고리즘은 ‘너비 우선 탐색’ 알고리즘 입니다. 쉽게 말해서 가까운 노드부터 탐색하는 알고리즘입니다. DFS랑 비교해보자면, DFS는 최대한 멀리 있는 노드(가장 깊은 노드)를 우선으로 탐색하는 방식이지만, BFS는 그 반대입니다. \n이러한 BFS의 탐색은 큐 자료구조를 이용하여 구현하게 됩니다. 동작 방식은 아래와 같습니다.\n\n\n\n\n\n\nBFS 과정\n\n탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다.\n큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 합니다.\n2번의 과정을 더 이상 수행할 수 없을 때까지 반복합니다.\n\n\n\n그럼, 이 과정을 위의 [그림5-1] 그래프를 통해서 살펴봅시다.\n\n\n\n\n\n\nBFS의 탐색 순서\n\n[노드 1]과 가까운 [노드 2], [노드 3], [노드 8] 을 순차적으로 큐에 삽입하고 방문 처리 합니다. \n번호가 빠른 [노드 2]를 큐에서 꺼내고, 방문하지 않은 인접 노드 [노드 7] 을 큐에 삽입, 방문 처리 합니다.\n그 다음인 [노드 3]을 큐에서 꺼내고, 방문하지 않은 인접 노드 [노드 4] 와 [노드 5] 큐에 삽입, 방문 처리합니다.\n큐에서 그 다음인 [노드 8]을 꺼내고, 방문하지 않은 인접 노드가 없으므로 다음 노드로 넘어갑니다.\n그 다음 번호인 [노드 7]을 큐에서 꺼내고 방문하지 않은 인접 노드 [노드 6] 을 큐에 삽입하고 방문 처리합니다.\n 남아있는 노드가 없고, 방문하지 않은 노드도 없으므로 큐에서 모든 노드를 차례대로 꺼내고 탐색을 종료합니다. \n\n\n\n결과적으로 노드의 탐색 순서는 다음과 같습니다.\n\n\n\n\n\n\n\n\n\n노드 1 → 노드 2 → 노드 3 → 노드 8 → 노드 7 → 노드 4 → 노드 5 → 노드 6\nBFS(너비 탐색) 알고리즘은 큐 자료구조를 이용한다는 점에서 구현이 간편합니다.큐 자체보다는 deque 라이브러리를 사용하는 것이 좋고, O(n)의 시간이 소요됩니다.일반적인 경우, 실제 수행 시간이 DFS보다 좋은 편이라는 점을 기억해둡시다!\n5-3 DFS vs BFS\n\n\n\nDFS\nBFS\n\n\n\n동작 원리\n스택\n큐\n\n\n구현 방법\n재귀 함수 이용\n큐 자료구조 이용(deque 추천)\n\n\n앞에서 이 둘을 설명하는 데에 전형적인 그래프를 이용했는데, 1차원 배열이나 2차원 배열도 그래프 형태로 생각하면 수월하게 문제를 풀 수 있습니다.\n예를 들어, 게임 맵이 3x3 형태의 2차원 배열이고 각 데이터를 좌표라고 생각해봅시다.게임 캐릭터의 시작점은 좌표 (1, 1)이며, 캐릭터의 이동은 상하좌우로만 가능합니다.이 경우, 좌표를 그래프 형태로 바꿔서 생각할 수 있습니다.\n즉, 코딩테스트에서 2차원 배열에서의 탐색 문제를 만나면 이렇게 그래프 형태로 바꿔서 생각하면 풀이 방법을 떠올리는 것이 더 쉽습니다!그러므로, 코딩테스트에서 탐색 문제를 보면 그래프 형태로 표현한 풀이법을 고민해 보도록 합시다!\n","slug":"algorithm-DFS-BFS","date":"2021-08-09T06:53:40.000Z","categories_index":"알고리즘","tags_index":"algorithm,DFS,BFS","author_index":"Latte"},{"id":"6cbdd4fd25742628092b5aa717b3e98a","title":"10. 머스테치(mustache)로 화면 구성하기","content":"이번 포스트는 머스테치를 이용한 프론트 엔드 개발을 설명하겠습니다.\n머스테치(mustache)로 화면 구성하기10-1 템플릿 엔진(Template Engine)이란?템플릿 엔진(Template Engine)이란, 지정된 템플릿 양식과 특정 데이터 모델에 따른 입력 자료를 합성하여 결과 문서를 출력하는 소프트웨어(혹은 소프트웨어 컴포넌트)를 말합니다. 이전에 스프링이나 서블릿을 사용했던 분들은 JSP, Freemarker 등을 떠올리실테고, 최근 개발을 시작한 독자들은 리액트, 뷰 등의 프레임워크를 떠올릴 것입니다.\n다만, 이들은 조금 차이가 있습니다. 전자는 서버 템플릿 엔진이라 불리고, 후자는 클라이언트 템플릿 엔진이라 불립니다. 간단하게 설명하자면 서버 템플릿 엔진은 서버쪽에서 구동되는 것을 의미하며, 클라이언트 템플릿 엔진은 브라우저(클라이언트 측) 위에서 작동되는 템플릿 엔진이라는 겁니다.\n\n\n\n서버 사이드 템플릿 엔진\n클라이언트 사이드 템플릿 엔진\n\n\n\n서버에서 DB 혹은 API에서 가져온 데이터를 미리 정의된 Template에 넣어 html을 그려서 클라이언트에 전달해주는 역할을 한다.\nHTML 형태로 코드를 작성할 수 있으며, 데이터를 받아 DOM 객체에 동적으로 그려주는 프로세스를 담당한다.\n\n\nHTML 코드에서 고정적으로 사용되는 부분은 템플릿으로 만들어두고, 동적으로 생성되는 부분만 템플릿 특정장소에 끼워넣는 방식으로 동작할 수 있도록 해준다.\n자바스크립트의 랜더링이 끝난 뒤(HTML DOM이 다 그려진 후)에 서버통신 없이 화면 변경이 필요한 경우에 사용된다.\n\n\n출처 : [Template Engine] 템플릿 엔진(Template Engine)이란?\n10-2 머스테치(mustache)자바에는 흔히 JSP, Velociry, Freemarker, Thymeleaf 등의 서버 템플릿 엔진이 존재하지만, 여러가지 문제점이 존재합니다. 때문에 이 프로젝트에서는 **머스테치(mustache)**를 사용합니다.\n\n\n\n\n\n\nJSP, Velociry, Freemarker, Thymeleaf의 문제점\n\nJPS: 임베디드 서블릿 컨테이너를 사용하는 스프링 부트에서 제약이 많아 스프링 부트에서는 권장하지 않습니다.\nVelocity(사용중지): Spring 버전 4.3부터 지원하지 않습니다. \nFreemarker: 템플릿 엔진으로는 너무 과하게 많은 기능을 지원하며 높은 자유도로 인해 숙련도가 낮을수록 Freemarker 안에 비지니스 로직이 추가될 가능성이 높습니다.: 또한, 몇 년 동안 업데이트되지 않고 있어 권장하지 않습니다.\nThymeleaf: 스프링에서 적극적으로 밀고있으나, 자바스크립트와 태그 속성 위주의 문법이므로 서버 엔지니어에게는 다소 문법이 어려울 수 있습니다.\n\n\n\n머스테치(mustache)는 루비, 자바스크립트, 파이썬, php, 자바, 펄, Go, ASP등 현존하는 대부분 언어를 지원하는 가장 심플한 템플릿 엔진입니다. 그러다보니 자바에서 사용될 때는 서버 템플릿 엔진으로, 자바스크립트에서 사용될때에는 클라이언트 템플릿 엔진으로 사용됩니다.\n머스테치의 장점은 아래와 같습니다.\n\n\n\n\n\n\n머스테치(mustache)의 장점\n\n문법이 다른 템플릿 엔진보다 심플합니다.\n로직 코드를 사용할 수 없어 View의 역할과 서버의 역할이 명확하게 분리됩니다.\nmustache.js와 mustache.java 2가지 다 있어, 하나의 문법으로 클라이언트/서버 템플릿을 모두 사용 가능합니다.\n\n\n\n(참고로, 템플릿 엔진은 화면의 역할에 충실해야 합니다. 너무 많은 기능을 제공하면 로직을 서로 나눠 갖게 되어 역할 분담 및 유지 보수가 어렵게 됩니다.)\n이제 인텔리제이에 머스테치를 사용하기 위한 플러그인을 설치해봅시다.\n10-3 머스테치 플러그인 설치IntelliJ의 Plugins에서 mustache를 검색한 후 설치해주세요. 설치 후에는 IntelliJ를 재기동해주세요.[그림10-1] 머스테치 플러그인 설치(저는 설치된 상태라 installed에 표시되지만 여러분은 marketplace에 표시될 것입니다)\n10-4 머스테치 의존성 추가이제 스프링 부트 프로젝트에서 머스테치를 편하게 사용할 수 있도록 머스테치 스타터 의존성을 build.gradle에 추가해줍니다.\ndependencies &#123;\n...\nimplementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-mustache&#39;, version: &#39;2.3.12.RELEASE&#39;\n...\n&#125;\n\n머스테치는 스프링부트에서 공식 지원하는 템플릿 엔진이므로, 의존성 하나만 추가하면 추가 설정 없이 설치가 끝입니다.\n10-5 머스테치 기본 페이지(index) 생성머스테치의 파일 위치는 기본적으로 src/main/resources/templates입니다. 이 위치에 머스테치 파일을 두면 스프링 부트에서 자동으로 로딩합니다. 첫 페이지를 담당할 index.mustache를 저 위치에 생성해봅시다. index.mustache의 내용은 아래와 같습니다\n&lt;!DOCTYPE HTML>\n&lt;html>\n    &lt;head>\n        &lt;title>스프링 부트 웹 서비스&lt;/title>\n        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/>\n    &lt;/head>\n\n    &lt;body>\n        &lt;h1>스프링 부트로 시작하는 웹 서비스&lt;/h1>\n    &lt;/body>\n&lt;/html>\n\n이 페이지는 간단하게 h1 크기로 “스프링 부트로 시작하는 웹 서비스”를 출력하는 페이지입니다.\n이제 이 머스테치에 URL을 매핑해봅시다. 매핑은 당연히 Controller에서 진행합니다.web 패키지 안에 IndexController를 생성해주세요.\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n@Controller\npublic class IndexController &#123;\n    @GetMapping(\"/\")\n    public String index()&#123;\n        return \"index\";\n    &#125;\n&#125;\n\n머스테치 스타터 덕분에 컨트롤러에서 문자열을 반환할 때 앞의 경로(src/main/resources/templates)와 뒤의 파일 확장자(.mustache)가 자동으로 지정됩니다. 즉, 여기서는 “index”를 반환하므로 URL은 “src/main/resources/templates/index.mustache” 로 전환되어 View Resolver가 처리하게 됩니다.\n여기까지 코드가 완성되었다면, 테스트 코드로 검증해보겠습니다. test 패키지에 IndexControllerTest 클래스를 생성합니다. 코드는 다음과 같습니다\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@ExtendWith(SpringExtension.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\nclass IndexControllerTest &#123;\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Test\n    public void 메인페이지_로딩()&#123;\n        //when\n        String body = this.restTemplate.getForObject(\"/\", String.class);\n\n        //then\n        assertThat(body).contains(\"스프링 부트로 시작하는 웹 서비스\");\n    &#125;\n&#125;    \n\n이 테스트는 실제로 URL 호출 시 페이지의 내용이 제대로 호출되는 지에 대한 테스트입니다. 테스트를 실행하면, h1 크기로 표시했던 “스프링 부트로 시작하는 웹 서비스”가 포함되어 테스트가 성공하는 것을 확인할 수 있습니다.\n[그림10-2] 메인페이지 로딩 테스트\n테스트도 성공하였으나, 이제 실제로 화면이 잘 나오는지 확인해보겠습니다.\nApplication.java의 main메서드를 실행하고 브라우저에서 http://localhost:8080 으로 접속해보겠습니다.\n[그림10-3] index 페이지 접속 확인정상적으로 index파일에 접근하여 h1 크기의 “스프링 부트로 시작하는 웹 서비스”가 출력되는 것을 확인했습니다.\n\n여기까지, 템플릿 엔진에 대한 간단한 설명과 머스테치의 설치방법에 대해서 알아보았습니다.다음 포스트에서는 머스테치를 이용하여 게시글의 CRUD 화면을 작성해보도록 하겠습니다.\n","slug":"springboot-web-11","date":"2021-07-21T07:37:52.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,Java,JPA Auditing","author_index":"Latte"},{"id":"9ed3a98723cc8a223c9fd2c456508919","title":"4. 재귀 함수(Recursive Function)","content":"DFS(Depth-First Srarch) 및 BFS(Breadth First Search)에 대해 정리하다보니, 이를 이해하기 위해서는 그래프, 스택, 재귀 함수에 대한 이해가 필요하다는 것을 알게 되었습니다. 그래프와 스택은 이전에 정리해두었으니, 이 포스트에서는 나머지 하나인 재귀 함수에 대해 정리해보려 합니다.(이 포스트는 이것이 취업을위한 코딩테스트다 with 파이썬을 기준으로 정리한 글입니다.)\n재귀 함수(Recursive Function)1. 정의재귀 함수(Recursive Function)란 자기 자신을 다시 호출하는 함수를 말합니다.가장 간단한 재귀함수의 예는 다음과 같습니다.\nclass Main &#123;\n    public static void main(String [] args) throws IOException &#123;\n        recursive();\n    &#125;\n\n    private static void recursive() &#123;\n        System.out.println(\"재귀함수를 호출합니다.\");\n        recursive();\n    &#125;\n&#125;\nrecursive() 메서드 안에 recursive()메서드가 포함된 것이 보이시나요? 재귀 함수는 이런식으로 자기 자신을 다시 호출합니다.  \n참고로 위의 코드를 실행하면 재귀함수를 호출합니다라는 문자열을 무한히 출력하다가 에러가 발생합니다. 컴퓨터의 사정상 무한대로 재귀 호출을 진행하기는 어렵기 때문입니다. 때문에 재귀 함수에서는 반드시 종료 조건을 명시하여 원하는 시점에 종료를 할 수 있도록 작성해야 합니다. \n2. 재귀함수의 동작 방식컴퓨터 내부에서 재귀 함수의 수행은 스택 자료 구조를 이용합니다. 함수를 계속 호출했을 때 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 때문입니다.\n그럼, 구체적으로 어떻게 스택 자료 구조를 이용하는지 팩토리얼을 예시로 설명해보겠습니다.\n[그림4-1] 재귀 함수의 동작 방식 1[그림4-2] 재귀 함수의 동작 방식 2[그림4-3] 재귀 함수의 동작 방식 3\n재귀 함수의 동작 방식이 이해 되셨나요? 중요한 것만 이야기하자면, \n\n\n\n\n\n\n\n\n\n\n재귀 함수는 내부적으로 스택 자료구조와 동일하다!\n따라서, 스택 자료구조를 활용해야하는 상당수 알고리즘은 재귀함수를 이용해서 간편하게 구현할 수 있다! \n\n라는 것입니다.\n다음은 예시로 들었던 팩토리얼에 대해 가볍게 설명하고 지나가겠습니다.\n3. 예시 - 팩토리얼(Factorial)재귀 함수를 이용하는 대표적인 예제로는 팩토리얼(Factorial) 문제가 있습니다. 팩토리얼은 1부터 어떤 양의 정수 n까지의 정수를 모두 곱한 것을 말하며 n! 로 표현합니다. 여기서 n!은 1 × 2 × 3 × …… × (n-1) × n 를 의미합니다. 팩토리얼 함수는 수학적으로 0! 과 1! 의 값이 1로 같다는 성질을 이용하여 n이 1 이하가 되었을때에 함수를 종료하는 재귀함수의 형태로 구현할 수 있습니다.  \n이를 코드로 구현하면 아래와 같습니다.\n백준 온라인 저지 10872번 문제 - 팩토리얼\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/*\n    백준 10872 문제 - 팩토리얼\n*/\nclass Main &#123;\n    public static void main(String [] args) throws IOException &#123;\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        System.out.println(factorial(n));\n    &#125;\n\n    private static int factorial(int n) &#123;\n        if (n &lt;= 1) return 1;\n        return n * factorial(n-1);\n    &#125;\n&#125;\n\n사실, 팩토리얼 문제는 대표적인 재귀 함수의 예시지만 반복문으로도 구현이 가능합니다.\n그렇다면 반복문 대신에 재귀 함수를 사용했을 때의 장점은 무엇일까요?\n4. 재귀 함수의 장단점4-1 장점재귀 함수의 가장 큰 장점은 코드가 더 간결해진다라는 것입니다.\n코드가 간결해지는 이유는 재귀 함수가 수학의 점화식(재귀식) 을 그대로 코드로 변경한 것이기 때문입니다.\n수열의 일반항으로서 수열을 정의하는 것이 아니라 이웃하는 항들과의 관계식으로서 수열을 정의하는 것을 수열의 귀납적 정의라 하며 수학에서 점화식(재귀식)은 수열에서 이웃하는 두개의 항 사이에 성립하는 관계를 나타난 관계식을 의미합니다.(이 개념은 후에 배울 다이나믹 프로그래밍으로 이어집니다.)\n팩토리얼을 수학적 점화식으로 표현해보면 다음과 같습니다\n\n\n\n\n\n\n\n\n\n\nn이 0이거나 1일 때 : factorial(n) = 1\nn이 1보다 클 경우 : factorial(n) = n * factorial(n-1)\n\n이런 식으로 점화식을 정리해두면, 종료 조건을 쉽게 찾을 수 있습니다. 여기에서 종료조건은 n이 0이거나 1일 때 입니다.이 경우를 고려하지 않으면, 재귀함수는 무한히 반복되고 결과를 출력할 수 없을 것입니다.또한 n이 음수가 들어왔을 때에는 입력 범위 오류이므로, 오류 메시지를 띄워야합니다. \n이러한 속성 때문에 재귀 함수의 구현은 반복문보다 쉽습니다. 그러나, 몇 가지 단점 때문에 재귀 함수를 이용하기보다는 반복문의 사용이 권장되고 있는데, 그러한 단점은 다음과 같습니다.\n4-2 단점단점은 크게 2가지 입니다.\n첫 번째, 재귀 함수는 호출될 때마다 call stack에 쌓이기 때문에 한계치 이상으로 호출되면 StackOverflow가 발생합니다.두 번째, 또한 재귀 함수와 반복문의 실행 시간을 비교해보면, 재귀 함수가 반복문보다 느린 것을 보실 수 있습니다.\n에러를 발생시킬 수 있다는 점과 속도가 느리다는 점은 매우 큰 단점이므로 반복문의 사용이 훨씬 유용하게 느껴지실겁니다.\n하지만 그럼에도 저희는 재귀 함수를 사용합니다. 그럼 과연 어떨 때에 재귀 함수를 사용해야할까요?\n5. 재귀 함수를 사용해야하는 경우재귀 함수를 사용해야하는 경우는 아래와 같습니다.\n\n\n\n\n\n\n\n\n\n\n알고리즘 자체가 재귀적인 표현이 자연스러운 경우\n변수 사용을 줄일 필요가 있을 때\n\n여기서 변수 사용을 줄인다는 것은 변수가 잡아 먹는 메모리에 대한 이야기가 아니라, mutable state(변경 가능한 상태) 를 제거하여 프로그램 오류가 발생할 수 있는 가능성을 줄이는 것을 의미합니다. 단순한 경우에는 오히려 재귀호출이 직관적으로 이해하기 어려울 수도 있지만, 프로그램이 복잡해지면 mutable state를 최대한 피하는 것이 오류 없는 프로그램을 짜는 데에 중요한 원칙이 됩니다. mutable state 를 최대한 피하는 것은 변수의 수를 줄이는 것과 변수가 가질 수 있는 값의 종류 또는 범위를 정확히 제한하는 것입니다.\n\n\n\n\n\n\nMutable State\n가변적인 전역변수를 의미하며 아래와 같은 단점이 존재합니다.\n\n상태를 변경할 수 있는 영역이 넓어질수록 특정 시점의 변수 값을 예측하기 어렵습니다.\n위의 이유로 테스트하기 어렵습니다.\n실행 순서에 따라 의도찮은 동작을 하거나, 데드락(Dead Lock)이 걸릴 가능성이 있습니다.\n\n\n\n때문에, 구현해야하는 코드가 위의 이유에 해당이 된다면 재귀 함수의 사용을 고려해야합니다.\n\n여기까지, 재귀함수 정의와 동작 방식, 그리고 장점과 단점에 대해서 이야기해보았습니다.다음 시간에는 DFS(Depth-First Srarch) 와 BFS(Breadth First Search)에 대해 정리해보도록 하겠습니다!\n\n레퍼런스\n\n이것이 취업을 위한 코딩테스트다 with 파이썬  \n위키피디아:점화식  \n[Algorithm - Theory]반복문과 재귀함수의 차이  \n재귀 함수(Recursive Function)  \n[JS] state와 mutable, immutable\n\n","slug":"algorithm-recursive-function","date":"2021-07-15T02:00:06.000Z","categories_index":"알고리즘","tags_index":"algorithm,Recursive Function","author_index":"Latte"},{"id":"20b86973dc8825e5a6ade1bddd196184","title":"3. 비선형구조 - 그래프(Graph)","content":"이번 포스트는 비선형구조 중 하나인 그래프(Graph)에 대해 정리해보도록하겠습니다.\n비선형구조 - 그래프(Graph)그래프(Graph)는 정점(vertex)과 간선(edge)으로 이루어진 자료구조이자 연결되어 있는 데이터 간의 관계를 표현하기 위한 자료구조 입니다. 대표적인 그래프로는 최단 경로를 찾기 위한 지도에서의 최단 경로, 지하철 노선도, 회로 구조 등이 있습니다. 트리(Tree) 구조도 그래프의 특수한 형태입니다.\n[그림3-1] 그래프의 예 \n이 그래프가 G1이라는 이름일 때에 다음과 같이 표기할 수 있습니다.\n\n\n\n\n\n\n그래프 표기의 예\n\nV(G1) = {A, B, C , D}   \nE(G1) = {(A, B), (B, C), (C, D), (B, D), (A, C)}\n\n\n\n3-1 그래프의 주요 용어\n\n\n용어\n내용\n비고\n\n\n\n정점(Vertex)\n그래프의 구성요소로 특성을 가질 수 있는 객체를 의미.\n노드(Node)라고도 불림\n\n\n간선(Edge)\n정점(Vertex)간 연결 관계.\n링크(Link)라고도 불림\n\n\n가중치(Weight)\n간선(Edge)의 비용이나 가중치가 가 있는 경우. 가중치값\n\n\n\n인접 정점(Adjacent-Vertex)\n간선(Edge)에 의해 연결된 정점.\n[그림3-1]에서 정점A와 정점 B는 인접 정점이다\n\n\n단순 경로(Simple-Path)\n경로 중 반복되는 정점이 없는 것. 같은 간선을 지나가지 않는 경로\n\n\n\n차수(Degree)\n무방향 그래프에서 하나의 정점에 인접한 정점의 수.\n[그림3-1]에서 정점B의 차수는 3이다\n\n\n진출 차수(Out-Degree)\n방향그래프에서 사용되는 용어로 한 노드에서 외부로 향하는 간선의 수\n\n\n\n진입 차수(In-Degree)\n방향그래프에서 사용되는 용어로 외부 노드에서 들어오는 간선의 수\n\n\n\n3-2 그래프의 종류3-2-1 무방향 그래프(Undirected Graph)[그림3-2] 무방향 그래프  \n\n무방향 간선(undirected edge)만을 사용합니다.  \n방향이 정해져있지 않으므로, 간선을 통해서 양방향으로 이동이 가능합니다.    \n(A, B) 와 같이 표기하며 이는 A와 B 사이의 간선을 의미합니다.    \n(A, B) = (B, A)이 성립합니다.\n\n3-2-2 방향그래프(Directed Graph)[그림3-3] 방향 그래프  \n\n방향 간선(directed edge)만을 사용합니다.  \n간선을 통해서 한쪽 방향으로만 갈 수 있습니다.  \n&lt;A, B&gt; 와 같이 표기하며 이는 A에서 B로 가는 간선을 의미합니다.  \n&lt;A, B&gt; ≠ &lt;B, A&gt;이 성립합니다.\n\n3-2-3 가중치 그래프(Weighted Graph)[그림3-4] 가중치 그래프  \n\n가중그래프 중 방향 그래프를 네트워크 그래프(Network Graph)라고도 부릅니다.  \n간선에 비용(cost)이나 가중치(weight)가 할당된 그래프입니다.  \n가중치는 양수와 음수 모두를 가질 수 있습니다.  \n최단 경로 문제와 관련 있으며 이는 가중치의 합이 최소가 되는 경로를 구하는 문제입니다.   \n경우에 따라 문제를 해결하는 알고리즘이 서로 다릅니다.  \n\n3-2-4 루트없는 트리(Unrooted Tree)[그림3-5] 루트없는 트리  \n\n서로 다른 두 정점을 잇는 방법이 한 가지인 그래프입니다.  \n트리의 정의와 유사하나 루트가 없습니다.\n\n3-2-5 이분 그래프(Bipartite Graph)[그림3-6] 이분 그래프  \n\n그래프의 정점을 겹치지 않게 두 그룹으로 나눈 후, 다른 그룹끼리만 간선이 존재하도록 분할하는 그래프입니다.  \n홀수 길이의 순환 그래프는 이분 그래프가 될 수 없습니다.\n\n3-2-6 사이클이 없는 방향 그래프(DAG;Directed Acycleic Graph)[그림3-7] 사이클이 없는 방향 그래프  \n\n정점에서 출발해 자기자신으로 돌아오는 경로(사이클)가 없는  그래프 입니다.  \n어느 경로에서도 자기 자신으로 돌아올 수 없습니다.  \n위상정렬이 있는 방향 그래프입니다.  \n\n\n\n\n\n\n\n위상정렬(Topological Sorting)\n위상 정렬(Topological Sorting)은 유향 그래프(방향 그래프)의 꼭짓점들(vertex)을 변의 방향을 거스르지 않도록 나열하는 것을 의미한다.\n\n\n3-3 그래프의 구현 방법[그림3-8] 그래프 예시\n3-3-1 인접 행렬(Adjacency Materix)을 이용한 방법먼저 인접 행렬 방식은 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식입니다. 연결되어 있지 않은 노드끼리는 무한(Infinity)의 비용이라고 작성합니다. 실제 코드에서는 논리적으로 정답이 될 수 없는 큰 값 중에서 “999999999”, “987654321” 등의 값으로 초기화하는 경우가 많습니다.\n이렇게 [그림3-8]의 그래프를 인접 행렬 방식으로 처리할 때는 다음과 같이 데이터를 초기화합니다.\n\n\n\n\nA\nB\nC\n\n\n\nA\n0\n7\n5\n\n\nB\n7\n0\n무한\n\n\nC\n5\n무한\n0\n\n\n\n인접 행렬의 장점과 단점은 다음과 같습니다.\n\n\n\n\n장점\n단점\n\n\n\n두 점에 대한 연결정보 조회는 O(1)의 시간 복잡도면 가능\n모든 정점에 대한 간선 정보를 대입해야하므로 O(n²)의 시간복잡도가 소요됨\n\n\n구현이 비교적 간단함\n무조건 2차원 배열이 필요하기 때문에 필요 이상의 공간이 낭비됨\n\n\n3-3-2 인접 리스트(Adjacency List)를 이용한 방법인접 리스트(Adjacency List) 방식은 그래프의 노드를 리스트로 표현한 것으로 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장합니다. 위의 [그림3-8]을 기준으로 인접 리스트를 표현하면 다음과 같습니다.\n[그림3-9] 인접 리스트 방식\n\n인접리스트의 장점과 단점은 다음과 같습니다.\n\n\n\n\n장점\n단점\n\n\n\n정점들의 연결 정보를 탐색할때 O(n)의 시간이면 가능 (n은 간선의 개수)\n배열보다 검색 속도가 느립니다.\n\n\n인접행렬과 비교했을 때, 공간의 낭비가 적습니다.\n구현이 비교적 어렵습니다.\n\n\n3-3-3 인접 행렬 방식 vs 인접 리스트 방식이 두 방식에는 어떤 차이가 있을까요? 메모리와 속도 측면에서 살펴보겠습니다.\n메모리 측면에서 인접 행렬 방식은 모든 관계를 저장하므로, 노드의 개수가 많을 수록 불필요하게 메모리가 낭비되는 반면에 인접리스트는 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용하게 됩니다.\n하지만 이와 같은 특성때문에 인접 리스트 방식은 인접 행렬에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느립니다. 인접리스트는 연결된 데이터를 하나씩 확인해야하기 때문입니다.\n일반적으로 인접 행렬 방식과 인접 리스트 방식의 차이를 정리하면 아래와 같습니다.\n\n\n\n\n인접 행렬 방식\n인접 리스트 방식\n\n\n\n메모리\n인접 리스트에 비해 낭비가 큼\n인접 행렬에 비해 메모리 낭비가 적음\n\n\n속도\n인접 리스트에 비해 속도가 빠름\n인접 행렬에 비해 속도가 느림\n\n\n하지만, 상황에 따라서는 인접 행렬이 메모리 공간의 낭비가 적은 경우도 존재합니다.예를 들어, 노드가 1부터 10까지 있는 상황을 가정해봅시다. 그리고, [노드 1] 과 [노드 7] 이 연결되어 있고, 우리는 이것이 연결되어 있는지 확인해야 합니다.인접 행렬 방식에서는 graph[1][7] 만 확인하면 됩니다.반면에, 인접 리스트 방식에서는 노드 1에 대한 인접 리스트를 앞에서부터 차례대로 확인해야합니다.그러므로, 특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우, 인접 행렬 방식을 사용하는 것이 메모리 공간의 낭비가 적습니다.\n\n이번 포스트에서는 비선형구조 중 하나인 그래프를 배워보았습니다.그래프는 탐색 알고리즘, 그리고 다양한 경로를 찾는 알고리즘에 사용되는 자료구조입니다.잘 알아두면 알고리즘 테스트뿐만 아니라 현업에서도 도움이 될 것이라 생각합니다.(아직 머리 속에서 정리가 덜 되어 잘못된 부분이 존재할 수 있습니다. 이 부분 참고해주세요.) \n\n레퍼런스\n\n[자료구조 1] 그래프(Graph) 이해하기  \n[Algorithm] 자료구조 그래프(Graph)란 무엇인가?  \nChap 10 : 그래프  \n위키피디아:가중그래프  \n[C언어]자료구조-가중치 그래프 Weighted Graph + Kruscal - 1\n\n","slug":"cs-graph","date":"2021-07-11T07:24:05.000Z","categories_index":"Computer Science","tags_index":"Nonlinear structure,Graph","author_index":"Latte"},{"id":"cbd579b642610e229f2314ec50cc2bc8","title":"9. JPA Auditing","content":"JPA Auditing 으로 생성시간/수정시간 자동화하기보통 엔티티(Entity)는 해당 데이터의 생성 시간과 수정 시간을 반드시 갖고 있습니다.언제 만들어졌는지, 언제 수정되었는지 등의 정보는 차후 유지 보수에 있어 굉장히 중요한 정보이기 때문입니다.그렇다보니 DB에 삽입(Insert)하기 전, 갱신(Update)하기 전에 날짜 데이터를 등록하거나 수정하는 코드가 반복해서 들어가게 됩니다.\n게시글의 생성일을 예로 들어보겠습니다. 게시글의 엔티티에 생성일의 정보를 추가하기 위해서는 게시글을 생성하는 코드에 현재 시간을 셋팅하는 코드를 추가해야합니다. 이것이 한 줄 정도였다면 크게 문제가 되지 않지만, 복수의 엔티티에 추가된다고 생각해봅시다. 추가나 변경이 있을때마다 코드를 일일히 추가하거나 수정해주어야 하고, 이렇게되면 쓸데없이 코드가 길어지게됩니다.\n그래서 이 문제를 해결하고자 JPA Auditing 을 사용하겠습니다.\n9-1 LocalDate 사용Java8 이전 버전의 Java를 사용했던 분들은 현재 시간을 가져오는 방식으로 Date 혹은 Calendar 클래스를 사용했을겁니다. 그러나 이 클래스들은 다음과 같은 문제점이 있었습니다.\n\n\n\n\n\n\n\n\n\nDate와 Calendar 클래스의 문제점\n\n불변(변경이 불가능한) 객체가 아닙니다.: 멀티 스레드 환경에서 언제든 문제가 발생할 수 있습니다.\nCalendar는 월(Month) 값 설계가 잘못 되었습니다.: 10월을 나타내는 Calendar.OCTOBER의 숫자값은 ‘9’입니다.: Enum의 표기(OCTOBER)와 실제 숫자값(9)에서 발생하는 괴리는 큰 혼란을 가져옵니다.\n\n때문에 Java8부터 LocalDate와 LocalDateTime이 등장했습니다. 이는 Java의 기본 날짜 타입이었던 Date의 문제점을 제대로 고친 타입이므로 이것으로 사용을 대체할 것을 권장합니다.\n\n\n\n\n\n\n\n\n\nLocalDate vs LocalTime vs LocalDateTime  \n\nLocalDate: 로컬 날짜 클래스로 날짜 정보만 필요할 때에 사용됩니다.:LocalDate currentDate = LocalDate.now();  \nLocalTime: 로컬 시간 클래스로 시간 정보만 필요할 떄에 사용됩니다.:LocalTime currentTime = LocalTime.now();  \nLocalDateTime: 날짜와 시간 정보 모두 필요할 때에 사용됩니다.:LocalDateTime currentDateTime = LocalDateTime.now();\n\n그럼, 이 클래스를 이용하여 생성 시간 및 수정 시간을 추가해보도록 하겠습니다.\n9-2 JPA Auditing 기능 추가하기먼저 domain 패키지에 BaseTimeEntity라는 이름의 추상클래스를 생성하고 아래의 코드를 추가합니다.이 BaseTimeEntity 클래스는 모든 Entity의 상위 클래스가 되어 Entity들의 createdDate, modifiedDate를 자동으로 관리하는 역할을 하게 됩니다.\n[그림9-1] BaseTimeEntity 클래스 경로\nimport lombok.Getter;\nimport org.springframework.data.annotation.CreatedDate;\nimport org.springframework.data.annotation.LastModifiedDate;\nimport org.springframework.data.jpa.domain.support.AuditingEntityListener;\n\nimport javax.persistence.EntityListeners;\nimport javax.persistence.MappedSuperclass;\nimport java.time.LocalDateTime;\n\n@Getter\n@MappedSuperclass\n@EntityListeners(AuditingEntityListener.class)\npublic abstract class BaseTimeEntity &#123;\n    @CreatedDate\n    private LocalDateTime createdDate;\n    @LastModifiedDate\n    private LocalDateTime modifiedDate;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n@MappedSuperclass: JPA Entity 클래스들이 BaseTimeEntity을 상속할 경우 BaseTimeEntity의 필드들도 칼럼으로 인식하도록 합니다.  \n@EntityListeners(AuditingEntityListener.class): BaseTimeEntity 클래스에 Auditing 기능을 포함시킵니다.  \n@CreatedDate: Entity가 생성되어 저장될 떄 시간이 자동 저장됩니다.  \n@LastModifiedDate: 조회한 Entity의 값을 변경할 떄 시간이 자동 저장됩니다.\n\n이제, Post 클래스에 생성 시각과 수정 시각을 추가하기 위해 BaseTimeEntity를 상속받는 코드를 추가합니다!\n...\npublic class Posts extends BaseTimeEntity &#123;\n...\n\n\n마지막으로 JPA Auditing 어노테이션을 활성화하기 위해 Application 클래스에 활성화를 위해 @EnableJpaAuditing 어노테이션을 추가합니다.\n...\nimport org.springframework.data.jpa.repository.config.EnableJpaAuditing;\n\n@EnableJpaAuditing\n@SpringBootApplication\npublic class Application &#123;\n...\n\n이제 JPA Auditing을 추가하는 코드가 완성되었습니다. 기능이 동작하는지 확인하기 위한 테스트 코드를 작성해 보도록 합시다.\n9-3 JPA Auditing 테스트 코드 작성하기PostsRepositoryTest 클래스에 테스트 메소드를 하나 더 추가하겠습니다!\n@Test\npublic void BaseTimeEntity_등록() &#123;\n    // given\n    LocalDateTime now = LocalDateTime.of(2019, 6, 4, 0, 0, 0);\n    postsRepository.save(Posts.builder()\n            .title(\"title\")\n            .content(\"content\")\n            .author(\"author\")\n            .build());\n    // when\n    List&lt;Posts> postsList = postsRepository.findAll();\n\n    // then\n    Posts posts = postsList.get(0);\n\n    System.out.println(\">>>>>>>>>> createDate=\" + posts.getCreatedDate() + \", modifiedDate=\" + posts.getModifiedDate());\n\n    assertThat(posts.getCreatedDate()).isAfter(now);\n    assertThat(posts.getModifiedDate()).isAfter(now);\n&#125;    \n\n테스트 코드를 수행해보면 다음과 같이 실제 시간이 잘 저장된 것을 확인할 수 있습니다\n[그림9-2] JPA Auditing 테스트 코드 실행 결과\n앞으로 추가될 엔티티들은 더 이상 등록일/수정일로 고민할 필요 없이 BaseTimeEntity를 상속받으면 됩니다.\n간단하죠?\n\n지금까지 JPA Auditing을 이용하여 엔티티에 생성 시간, 수정 시간을 추가하는 방법을 알아보았습니다.다음 포스트에는 템플릿 엔진을 이용하여 화면을 만들어보겠습니다.\n","slug":"springboot-web-10","date":"2021-07-10T05:31:52.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,Java,JPA Auditing","author_index":"Latte"},{"id":"46bc520d99f0fdb2597458e927fef029","title":"8. 등록, 수정, 조회 API 만들기","content":"등록, 수정, 조회 API 만들기API를 만들기 위해서는 총 3개의 클래스가 필요합니다.\n\nRequest 데이터를 받을 DTO\nAPI 요청을 받을 Controller\n트랜잭션, 도메인 기능 간의 순서를 보장하는 Service\n\n여기서 Service는 트랜잭션, 도메인 간 순서 보장의 역할만 할 뿐 비지니스 로직을 처리하지 않으며 스프링에서 비지니스 로직의 처리는 domain에서 처리합니다.\nAPI를 만들기에 앞서, 이들을 어디에 어떻게 생성할 것인지, 왜 그곳이어야 하는지 이해하기 위해 Spring의 웹 계층에 대해 이해하고 지나갑시다.\n[그림8-1] Spring Web Layer\n\n\n\n\n\n\n\n\n\n\nWeb Layer: 컨트롤러(@Controller)와 JSP/Freemaker 등 뷰 템플릿 영역입니다.: 이외에도 필터(@Filter), 인터셉터, 컨트롤러 어드바이스(@ControllerAdvice) 등 외부 요청과 응답에 대한 전반적인 영역을 이야기합니다.\nService Layer: @Service에 사용되는 서비스 영역입니다.: 일반적으로 Controller와 Dao의 중간 영역에서 사용됩니다.: @Transactional이 사용되어야 하는 영역이기도 합니다.\nRepository Layer: Database와 같은 데이터 저장소에 접근하는 영역입니다.: DAO(Data Access Object) 영역으로 이해하면 쉽습니다.  \nDtos: Dto(Data Transfer Object)의 영역을 의미합니다.: 예를 들어, 뷰 템플릿 엔진에서 사용될 객체나 Repository Layer에서 넘겨준 객체 등이 이것입니다.  \nDomain Model: 도메인이라 불리는 개발 대상을 모든사람이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화 시킨 것을 말합니다.: @Entity가 사용된 영역 역시 도메인 모델이지만, 도메인 모델이 무조건 데이터베이스의 테이블과 관계가 있는 것은 아닙니다.: VO처럼 값 객체들도 이 영역에 해당합니다.  \n\n간단히 이해하셨다면, 이제 등록 기능을 추가해보겠습니다.\n8-1 등록 기능 추가먼저 등록 기능을 추가해봅시다.  \nPostsApiController를 web 패키지에,PostsSaveRequestDto를 web.dto 패지키에,PostsService를 service.posts 패키지에 생성합니다.\n[그림8-2] 클래스 생성 경로\nPostsApiController를 추가했다면 등록 메소드를 추가합니다.\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RequiredArgsConstructor\n@RestController\npublic class PostsApiController &#123;\n    private final PostsService postsService;\n\n    @PostMapping(\"/api/v1/posts\")\n    public Long save(@RequestBody PostsSaveRequestDto requestDto)&#123;\n        return postsService.save(requestDto);\n    &#125;\n&#125;\n\nPostsService 클래스에도 등록 메서드를 추가해줍니다.\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@RequiredArgsConstructor\n@Service\npublic class PostsService &#123;\n    private final PostsRepository postsRepository;\n\n    @Transactional\n    public Long save(PostsSaveRequestDto requestDto)&#123;\n        return postsRepository.save(requestDto.toEntity()).getId();\n    &#125;\n&#125;\n\n스프링을 어느정도 써보셨던 분이라면 Controller와 Service에 @Autowired가 없는 것이 어색하게 느껴질 것입니다.   스프링에서 Bean을 주입받는 방식은 3가지입니다.\n\n\n\n\n\n\n\n\n\n\n필드주입(Field Injection): @Autowired 어노테이션을 붙여주는 방식의 의존성 주입. final 선언이 불가능하다.\n수정자 주입(Setter Injection): 수정자(Setter)를 이용한 주입방법\n생성자 주입(Constructure Injection): 생성자로 객체를 생성하는 시점에 필요한 빈을 주입하는 방식.\n\n가장 권장하는 방식은 생성자로 주입받는 방식입니다. (이에 대해서는 기회가 되면 정리해보도록 하곘습니다)\n여기서는 롬복 어노테이션인 @RequiredArgsConstructor를 이용하여 생성자를 주입받고 있습니다.생성자를 직접 안 쓰고 롬복 어노테이션을 사용하는 이유는 해당 클래스의 의존성 관계가 변경될 때마다 생성자 코드를 계속해서 수정해야하는 문제를 해결하기 위해서입니다.\n계속해서 PostsSaveRequestDto의 코드를 작성하도록 하겠습니다.\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\n\n@Getter\n@NoArgsConstructor\npublic class PostsSaveRequestDto &#123;\n    private String title;\n    private String content;\n    private String author;\n\n    @Builder\n    public PostsSaveRequestDto(String title, String content, String author) &#123;\n        this.title = title;\n        this.content = content;\n        this.author = author;\n    &#125;\n\n    public Posts toEntity()&#123;\n        return Posts.builder()\n                .title(title)\n                .content(content)\n                .author(author)\n                .build();\n    &#125;\n&#125;\n\nDto는 Entity 클래스와 거의 유사한 형태임에도 추가로 생성하였습니다.절대로 Entity 클래스는 Request나 Response클래스로 사용해서는 안 되기 때문입니다.\nEntity는 데이터베이스에 직접적으로 영향을 미치는 핵심 클래스입니다. Entity 클래스를 기준으로 테이블이 생성되고, 스키마가 변경됩니다. Entity 클래스가 변경되면 여러 클래스에 영향을 미치게 됩니다.\n그리고 Request와 Response 용 Dto는 View를 위한 클래스이기에 정말 자주 변경, 수정됩니다.\n이런 이유로 View Layer와 DB Layer의 역할 분리는 철저해야합니다. 실제로 Controller에서 결괏값으로 여러 테이블을 조인해서 줘야하는 경우가 빈번하므로 Entity 클래스만으로 표현하기 어려운 경우가 많습니다. 제가 다니던 회사는 이 문제때문에  전체적으로 리팩토링을 진행한 적이 있습니다. View를 위한 DTO가 따로 존재하지 않아 DB에 과하게 접근, DB 성능에까지 영향을 미쳤기 때문입니다.\n그러므로 이런 문제가 생기기 전에 미리 Entity 클래스와 Controller에서 쓸 Dto는 분리해서 사용하도록 합시다.\n이제, 등록 기능의 코드가 완성되었으니 데스트 코드로 검증하도록 하겠습니다.테스트 클래스의 이름은 PostsApiControllerTest이며 위치는 아래의 그림과 같습니다\n[그림8-3] 테스트 클래스 경로\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.web.server.LocalServerPort;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\n\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@ExtendWith(SpringExtension.class)\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\nclass PostsApiControllerTest &#123;\n    @LocalServerPort\n    private int port;\n\n    @Autowired\n    private TestRestTemplate testRestTemplate;\n\n    @Autowired\n    private PostsRepository postsRepository;\n\n    @AfterEach\n    public void tearDown() throws Exception &#123;\n        postsRepository.deleteAll();\n    &#125;\n\n    @Test\n    public void Posts_등록된다() throws Exception &#123;\n        // given\n        String title = \"title\";\n        String content = \"content\";\n        PostsSaveRequestDto requestDto = PostsSaveRequestDto.builder()\n                .title(title)\n                .content(content)\n                .author(\"author\")\n                .build();\n        String url = \"http://localhost:\" + port + \"/api/v1/posts\";\n\n        //when\n        ResponseEntity&lt;Long> responseEntity = testRestTemplate.postForEntity(url, requestDto, Long.class);\n\n        //then\n        assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);\n        assertThat(responseEntity.getBody()).isGreaterThan(0L);\n\n        List&lt;Posts> all = postsRepository.findAll();\n        assertThat(all.get(0).getTitle()).isEqualTo(title);\n        assertThat(all.get(0).getContent()).isEqualTo(content);\n    &#125;\n&#125;\n\nApiController를 테스트하는데에 HelloController와 달리 @WebMvcTest를 사용하지 않습니다.@WebMvcTest의 경우 JPA 기능이 작동하지 않기 때문입니다. 때문에 지금같이 JPA 기능까지 한 번에 테스트할 때에는 @SpringbBootTest와 TestRestTemplate를 사용해야합니다.테스트를 수행하면 다음과 같이 성공할 것입니다\n[그림8-4] 등록 기능 테스트 결과\nWebEnvironment.RANDOM_PORT로 인해 랜덤 포트 실행과 insert 쿼리가 실행된 것을 보실 수 있습니다.\n이제 등록 기능을 완성했으니 수정 및 조회 기능도 추가해보도록 하겠습니다.\n8-2 수정 기능 추가수정 기능의 리퀘스트 데이터를 처리해줄 PostsUpdateRequestDto를 추가, 코드를 작성합니다.경로는 다음과 같습니다.\n[그림8-5] PostsUpdateRequestDto &amp;  PostsResponseDto경로\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\n\n@Getter\n@NoArgsConstructor\npublic class PostsUpdateRequestDto &#123;\n    private String title;\n    private String content;\n\n    @Builder\n    public PostsUpdateRequestDto(String title, String content)&#123;\n        this.title = title;\n        this.content = content;\n    &#125;\n&#125;\n\n작성이 완료되었다면 Posts에 도메인 수정을 위한 update 메서드를 추가해줍니다.\npublic void update(String title, String content)&#123;\n    this.title = title;\n    this.content = content;\n&#125;\n\nPostsResponseDto도 추가해줍니다.\nimport lombok.Getter;\n\n@Getter\npublic class PostsResponseDto &#123;\n    private Long id;\n    private String title;\n    private String content;\n    private String author;\n\n    public PostsResponseDto(Posts entity) &#123;\n        this.id = entity.getId();\n        this.title = entity.getTitle();\n        this.content = entity.getContent();\n        this.author = entity.getAuthor();\n    &#125;\n&#125;\n\nPostsService에 수정 기능 메서드를 추가합니다.\n@Transactional\npublic Long update(Long id, PostsUpdateRequestDto requestDto)&#123;\n    Posts posts = postsRepository.findById(id).orElseThrow(() -> new IllegalArgumentException(\"해당 게시글이 없습니다. id = \" + id));\n    posts.update(requestDto.getTitle(), requestDto.getContent());\n    return id;\n&#125;\n\npublic PostsResponseDto findById(Long id)&#123;\n    Posts entity = postsRepository.findById(id).orElseThrow(() -> new IllegalArgumentException(\"해당 게시글이 없습니다. id = \" + id));\n    return new PostsResponseDto(entity);\n&#125;\n\nPostsApiControlle 에 수정 기능 API 메서드를 작성합니다\n@PutMapping(\"/api/v1/posts/&#123;id&#125;\")\npublic Long update(@PathVariable Long id, @RequestBody PostsUpdateRequestDto requestDto)&#123;\n    return postsService.update(id, requestDto);\n&#125;\n\n@GetMapping(\"/api/v1/posts/&#123;id&#125;\")\npublic PostsResponseDto findById(@PathVariable Long id)&#123;\n    return postsService.findById(id);\n&#125;\n\n마지막으로 수정 기능의 테스트 코드를 PostsApiControllerTest에 추가합니다.\n@Test\npublic void Posts_수정된다() throws Exception &#123;\n    //given\n    Posts savedPosts = postsRepository.save(Posts.builder()\n            .title(\"title\")\n            .content(\"content\")\n            .author(\"author\")\n            .build());\n\n    Long updateId = savedPosts.getId();\n    String expectedTitle = \"title2\";\n    String expectedContent = \"content2\";\n\n    PostsUpdateRequestDto requestDto = PostsUpdateRequestDto.builder()\n            .title(expectedTitle)\n            .content(expectedContent)\n            .build();\n\n    String url = \"http://localhost:\" + port + \"/api/v1/posts/\" + updateId;\n\n    HttpEntity&lt;PostsUpdateRequestDto> requestEntity = new HttpEntity&lt;>(requestDto);\n\n    //when\n    ResponseEntity&lt;Long> responseEntity = testRestTemplate.exchange(url, HttpMethod.PUT, requestEntity, Long.class);\n\n    //then\n    assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);\n    assertThat(responseEntity.getBody()).isGreaterThan(0L);\n\n    List&lt;Posts> all = postsRepository.findAll();\n    assertThat(all.get(0).getTitle()).isEqualTo(expectedTitle);\n    assertThat(all.get(0).getContent()).isEqualTo(expectedContent);\n&#125;\n\n테스트 결과가 다음과 같이 출력됩니다.\n[그림8-6] 수정 기능 테스트 결과\n8-3 조회 기능 확인하기조회기능은 실제로 톰캣을 실행해서 확인해보도록 하겠습니다. 로컬환경에선 데이터베이스를 h2를 사용하기 때문에 직접 접근하기 위해서는 웹 콘솔을 사용해야 합니다.\n먼저 웹 콘솔 옵션을 활성화해봅시다. application.properties에 다음과 같은 옵션을 추가합니다\nspring.h2.console.enabled=true\n\n추가한 후 Application 클래스의 메인 메서드를 실행, http://localhost:8080/h2-console로 접속해주세요.그러면 웹 콘솔화면이 나타날 것입니다. \n[그림8-7] h2 console page\nJDBC URL이 jdbc:h2:mem:testdb로 되어있지 않다면 똑같이 작성해주세요.\n자 그럼 Connect 버튼을 클릭하여 현재 프로젝트의 h2를 관리할 수 있는 페이지로 이동합시다.왼쪽 상단에 POSTS 테이블이 정상적으로 노출되어야 합니다.\n[그림8-8] h2 console main page\n그럼 간단한 쿼리를 실행해봅시다!\nSELECT * FROM posts;\n\n등록된 데이터가 없어 결과가 나오지 않지만 문제없이 동작합니다.이번엔 간단하게 데이터를 집어넣은 후에 이를 API로 조회해보겠습니다.\nINSERT INTO posts(author, content, title) VALUES ('author', 'content', 'title');\n\n등록된 데이터를 요청해보겠습니다. url은 http://localhost:8080/api/v1/posts/1 입니다\n[그림8-9] API request result\n요청한 데이터가 잘 넘어오는 것을 확인할 수 있습니다 :)\n\n이제 기본적인 등록, 수정, 조회 기능을 사용할 수 있게 되었습니다!다음 포스트에서는 JPA Auditing을 통해 생성 시간과 수정 시간을 자동화해보도록 하곘습니다.\n","slug":"springboot-web-9","date":"2021-07-05T07:00:07.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,Java,JPA","author_index":"Latte"},{"id":"6f509e2dbed1e4f5397d3d96a9fdd4cd","title":"7. 프로젝트에 Spring Data JPA 적용하기","content":"지난 포스트에서는 JPA가 무엇이고, 왜 사용하는 것인지에 대해 알아보았습니다.이번 포스트에서는 프로젝트에 Spring Data JPA 를 적용해보도록하겠습니다.\n프로젝트에 Spring Data JPA 적용하기7-1 Spring Data JPA 의존성 등록하기build.gradle에 아래와 같이 Spring Data JPA 와 h2 의 의존성을 등록합니다.\n&#x2F;&#x2F; spring-boot-starter-data-jpa\nimplementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-data-jpa&#39;, version: &#39;2.5.1&#39;\n&#x2F;&#x2F; h2\ncompile(&#39;com.h2database:h2&#39;)\n\n\n\n\n\n\n\n\n\n\n\nspring-boot-starter-data-jpa: 스프링 부트용 Spring Data JPA     추상화 라이브러리입니다.: 스프링 부트 버전에 맞춰 자동으로 JPA관련 라이브러리들의 버전을 관리해줍니다.\nh2: 인메모리(In-memory) 관계형 데이터베이스로 메인 메모리(RAM)에 설치되어 운영되는 DB 시스템을 말합니다.: 메모리에서 실행되기 때문에 설치가 필요없고, 애플리케이션을 재시작할 때마다 초기화되는 특징을 지닙니다.: 이런 특징을 이용하여 테스트용도로 많이 사용되며, 이 포스트는 JPA 테스트 및 로컬환경에서의 구동에 사용됩니다.\n\n의존성 등록이 완료되었으니 JPA기능을 사용하기 위해 기능을 추가해보도록 하겠습니다.\n7-2 JPA 기능 추가이제 JPA 기능을 추가하겠습니다!먼저 springboot 패키지 아래의 경로에 domain 패키지 를 생성합니다.이 패키지는 도메인을 담는 패키지가 됩니다.\n\n\n\n\n\n\n도메인(Domain)이란?\n\n책에서 말하는 domain은 DDD(Domain-driven design)의 domain 개념과 유사합니다.\n게시글, 댓글, 회원, 정산, 결제 등 소프트웨어에 대한 요구사항 혹은 문제영역을 의미합니다.\n예를 들어, 게시판이라는 큰 도메인(Domain) 안에는 부분 집합인 게시글, 회원, 정산, 댓글 등은 서브 도메인(Sub Domain)이 존재합니다.(출처 : Domain Driven Design 이란 무엇인가?)\n\n\n\n기존에 Mybatis와 같은 쿼리 매퍼를 사용했다면 dao 패키지를 떠올리실겁니다. 다만, 도메인은 Dao 패지키와는 조금 결이 다릅니다. 그동안 xml에 쿼리를 담고, 클래스는 오로지 쿼리의 결과만 담던 일들이 모두 도메인 클래스라고 불리는 곳에서 해결됩니다.\n그럼 domain 패키지에 posts 패키지와 Posts 클래스 를 만듭니다.Posts 클래스의 코드는 다음과 같습니다.\npackage com.dev.latte.springboot.domain.posts;\n\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Id;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\n\n@Getter\n@NoArgsConstructor\n@Entity\npublic class Posts &#123;\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(length = 500, nullable = false)\n    private String title;\n\n    @Column(columnDefinition = \"TEXT\", nullable = false)\n    private String content;\n\n    private String author;\n\n    @Builder\n    public Posts(String title, String content, String author) &#123;\n        this.title = title;\n        this.content = content;\n        this.author = author;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n@Entity:  DB의 테이블과 링크될 클래스임을 나타내는 어노테이션입니다.: 매칭은 기본적으로 클래스의 이름을 언더스코어로 변경하여 매칭합니다. (예 - SalesManager.java → sales_manager 테이블)\n@Id:  해당 테이블의 PK를 지정하는 어노테이션입니다.\n@GeneratedValue:  PK 생성 규칙을 의미하는 어노테이션입니다.: 옵션값을 지정해주어야합니다. 이 클래스에서는 GenerationType.IDENTITY옵션을 사용합니다.  \n@Column:  테이블의 칼럼을 나타냅니다.: 선언하지 않더라도 해당 클래스의 필드는 모두 칼럼이 됩니다.: 기본 값 외에 추가로 변경할 옵션이 있을 때에 주로 사용합니다.\n\n\n\n\n\n\n\n@GeneratedValue의 옵션\n\nGenerationType.AUTO : 기본 설정 값(Default)  \nGenerationType.IDENTITY : 기본 키(PK) 생성을 데이터베이스에 위임하는 옵션  \nGenerationType.SEQUNCE : 데이터베이스의 시퀀스 object를 이용하는 옵션  \nGenerationType.TABLE : 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 옵션  \n\n\n\n이 Posts 클래스에는 Setter 메서드가 없습니다. VO를 생성하면서 getter/setter 를 무작정 생성하는 경우가 있는데, 이렇게되면 해당 클래스의 인스턴스 값들이 언제 어디서 변해야하는지 코드상으로 명확하게 구분할 수 없어 차후 기능 변경 시 정말 복잡해집니다.\n때문에 Entity클래스에서는 절대 Setter 메서드를 만들지 않습니다.그렇다면, setter 메서드가 없는 이 상황에서 어떻게 값을 채워 DB에 삽입해야 할까요?\n기본적인 구조는 생성자를 통해 최종 값을 채운 후 DB에 값을 삽입하는 것이며, 값 변경이 필요한 경우 목적과 의도를 나타낼 수 있는 메서드를 추가한 후 해당 메소드를 호출하여 변경합니다.\n이 책에는 생성자 대신에 @Builder를 통해 제공되는 빌더 클래스를 사용합니다.\n\n\n\n\n\n\n빌더 패턴(Builder pattern)\n\n빌더 패턴(Builder pattern)이란 복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여 서로 다른 표현이라도 이를 생성할 수 있는 동일한 구축 공정을 제공할 수 있도록 한다.\n이 프로젝트에서는 롬복의 @Builder 애노테이션으로 쉽게 사용할 수 있다.(출처 : 빌더 패턴(Builder Pattern))\n\n\n\n모든 예제는 이렇게 빌더 패턴을 적극적을 사용하지 잘 알아두시면 좋습니다\nPosts 클래스 생성이 끝났다면, Posts 클래스로 database를 접근하게 해줄 JpaRepository 인터페이스를 생성합니다.위치는 posts 디렉토리 아래이며 인터페이스 명은 PostsRepository입니다.\n[그림7-1] Posts 클래스와 PostsRepository 인터페이스의 경로\nRepository는 ibatis나 Mybatis등에서 Dao라고 불리는 JPA의 DB Layer 접근자입니다.인터페이스로 생성하며 JpaRepository&lt;Entity, pk_데이터타입&gt;을 상속하면 기본적인 CRUD메소드가 자동으로 생성됩니다. @Repository를 추가할 필요도 없습니다. \n주의할 점은 Entity와 Repository는 항상 같은 패키지에 위치해야한다는 것입니다.나중에 프로젝트 규모가 커져 도메인별로 프로젝트를 분리해야한다면 이때 Entity 클래스와 기본 Repository는 함께 움직여야하므로 domain패키지에서 함께 관리합니다.\n이제, 작성한 코드를 테스트를 통해 기능 검증해보도록 하겠습니다.\n7-3. Spring Data JPA 테스트 코드 작성하기먼저, PostsRepository의 테스트클래스를 생성합니다. 테스트 클래스의 이름은 PostsRepositoryTest입니다.위치는 test 디렉토리 아래이며, 패키지 경로는 main 디렉토리의 PostsRepository의 경로와 같습니다.\n[그림7-2] PostsRepositoryTest의 경로\nPostsRepositoryTest에서는 save와 findAll 기능을 테스트합니다.\npackage com.dev.latte.springboot.domain.posts;\n\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\n\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@ExtendWith(SpringExtension.class)\n@SpringBootTest\nclass PostsRepositoryTest &#123;\n    @Autowired\n    PostsRepository postsRepository;\n\n    @AfterEach\n    public void cleanUp()&#123;\n        postsRepository.deleteAll();\n    &#125;\n\n    @Test\n    public void 게시글저장_불러오기()&#123;\n        String title = \"테스트게시글\";\n        String content = \"테스트본문\";\n\n        postsRepository.save(Posts.builder()\n                            .title(title)\n                            .content(content)\n                            .author(\"Latte\")\n                            .build());\n\n        // when\n        List&lt;Posts> postsList = postsRepository.findAll();\n        // then\n        Posts posts = postsList.get(0);\n        assertThat(posts.getTitle()).isEqualTo(title);\n        assertThat(posts.getContent()).isEqualTo(content);\n    &#125;\n&#125;\n작성이 완료되었다면 테스트를 실행, test passed가 보이면 문제없이 Spring Data JPA가 동작하는 것입니다.\n[그림7-3] 테스트 결과\n여기서 실제로 실행된 쿼리 로그를 보고싶다면 resources 디렉토리 아래에 application.properties 파일을 생성하고 아래와 같은 옵션을 추가해주세요.\n[그림7-4] application.properties 경로\nspring.jpa.show-sql=true\n\n그럼 다음과 같은 쿼리 로그를 확인할 수 있습니다.\n[그림7-5] 쿼리 로그의 확인\n위의 쿼리 로그들 중에서 한 가지 걸리는 것이 있습니다. \ncreate table posts (id bigint generated by default as identity, author varchar(255), content TEXT not null, title varchar(500) not null, primary key (id))\n\n위의 create 쿼리가 그것인데요, 여기서 id bigint generated by default as identity라는 옵션이 보일겁니다.이는 h2의 쿼리 문법이 적용되어 설정된 옵션입니다. MySQL의 문법이 익숙하신 분들을 위해 출력되는 쿼리 로그를 MySQL버전으로 바꾸는 것도 가능합니다. application.properties에 아래의 옵션을 추가해주세요\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n\n추가 후에 코드를 다시 실행해봅시다!\n[그림7-6] 쿼리 로그를 MySql 문법으로\n사진과 같이 변경되었다면 옵션이 잘 적용된 것입니다!\n\n이번 포스트에서는 JPA와 h2에 대한 기본적인 기능과 설정을 진행하였으니, 다음 포스트에서 본격적으로 API기능을 만들어보겠습니다.\n","slug":"springboot-web-8","date":"2021-07-03T09:59:14.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,Java,JPA","author_index":"Latte"},{"id":"02ccdc68ca28ee335d8d90d6267099db","title":"2. 선형구조 - 스택(Stack)과 큐(Queue)","content":"오늘은 이전 포스트(자료구조)에 이어서 선형 구조 중 하나인 스택(Stack)과 큐(Queue)를 정리해보도록 하겠습니다.\n선형구조 - 스택(Stack)과 큐(Queue)선형구조(Linear Structure)란 자료를 구성하는 데이터를 순차적으로 나열시킨 형태를 의미합니다.대부분의 선형구조가 아래와 같은 형태를 띄고 있고, 1:1의 데이터 관계를 갖는다는 특징이 있습니다.\n[그림1] 선형구조\n오늘 설명할 스택과 큐도 위의 형태를 기본으로 합니다.\n2-1 스택(Stack)스택(Stack)은 접근이 목록의 끝에서만 일어나는 나열 구조입니다. 때문에 끝먼저내기 목록(Pushdown list)이라고도 부릅니다. (위키피디아 - 스택)\n위에 있는 [그림1]을 스택으로 표현해보도록 하겠습니다.\n[그림2] 스택(Stack)\n스택은 입구와 출구가 동일합니다. 때문에 자료를 넣는 곳과 자료를 꺼내는 곳이 한 군 데 밖에 없습니다.  \n자료를 넣는 것은 푸쉬(push), 자료를 꺼내는 것을 팝(pop)이라고 합니다. 스택의 가장 큰 특징은 데이터를 사용하기 위해 자료를 요청하면, 마지막에 들어간 데이터가 제일 먼저 나온다는 것입니다. 이런 구조를 후입선출(LIFO;Last Input First Out)이라고 합니다. \n[그림2]를 예로 들어봅시다. 당신은 스택에 담긴 Data-3을 Data-5로 대체하고싶습니다. 목표는 스택의 데이터가 [Data-1, Data-2, Data-5, Data-4]가 되는 것입니다. 그러기 위해서는 어떻게 해야할까요?스택에서는 아래와 같은 흐름을 거칩니다.\n\n\n\n\n\n\n\n\n\n\nData-4를 꺼낸다.\nData-3을 꺼낸다\nData-5를 넣는다\n다시 데이터 4를 넣는다.\n\n그리고 이것을 자바로 표현하면 다음과 같습니다.\nimport java.util.Stack;\n\nclass Main &#123;\n    public static void main(String [] args) &#123;\n        // 스택 선언\n        Stack&lt;String> stack = new Stack&lt;>();\n        for(int i = 0; i &lt; 4; i++)&#123;\n            // Stack에 데이터 4개 추가\n            stack.push(\"Data-\" + (i + 1));\n        &#125;\n\n        stack.pop(); // Data-4 꺼내기\n        stack.pop(); // Data-3 꺼내기\n        stack.push(\"Data-5\"); // Data-5 넣기\n        stack.push(\"Data-4\"); // Data-4 넣기\n\n        System.out.println(stack);\n    &#125;\n&#125;\n결과는 다음과 같습니다.\n[그림3] 코드 실행 결과\n2-2 큐(Queue)큐(Queue)는 먼저 집어 넣은 데이터가 먼저 나오는 선입선출(FIFO; First Input FIrst Out) 구조로 저장하는 형태를 말합니다. 큐는 한쪽 끝(Rear)에서는 삽입 연산(Enqueue)만, 다른 끝에(Front)서는 삭제 연산(Dequeue)만 이루어지며 순서가 존재합니다.\n위에 있는 [그림1]을 큐로 표현해보도록 하겠습니다.\n[그림4] 큐(Queue)\n이번엔 [그림4]를 기준으로 Data-3을 Data-5로 대체해봅시다. 목표는 큐의 데이터가 [Data-1, Data-2, Data-5, Data-4]가 되는 것입니다. 큐에서는 아래와 같은 흐름을 거칩니다.\n\n\n\n\n\n\n\n\n\n\nData-1을 꺼낸다 (Dequeue)\nData-2를 꺼낸다 (Dequeue)\nData-3을 꺼낸다 (Dequeue)\nData-4를 꺼낸다 (Dequeue) - 이 시점에 큐가 비어있음\nData-1을 넣는다 (Enqueue)\nData-2를 넣는다 (Enqueue)\nData-5를 넣는다 (Enqueue)\nData-4를 넣는다 (Enqueue)\n\n그리고 이것을 자바로 표현하면 다음과 같습니다.\nimport java.util.Queue;\nimport java.util.LinkedList;\n\nclass Main &#123;\n    public static void main(String [] args) &#123;\n        // 큐 선언, LinkedList를 이용해서 선언한다.\n        Queue&lt;String> queue = new LinkedList&lt;>();\n        for(int i = 0; i &lt; 4; i++)&#123;\n            queue.offer(\"Data-\" + (i + 1));\n        &#125;\n\n        String data_1 = queue.poll(); // 맨 앞의 데이터 꺼내기(Data-1)\n        String data_2 = queue.poll(); // 맨 앞의 데이터 꺼내기(Data-2)\n        String data_3 = queue.poll(); // 맨 앞의 데이터 꺼내기(Data-3)\n        String data_4 = queue.poll(); // 맨 앞의 데이터 꺼내기(Data-4)\n\n        queue.add(data_1); // 해당 큐의 맨 뒤에 전달된 요소를 삽입함.\n        queue.offer(data_2); // 해당 큐의 맨 뒤에 전달된 요소를 삽입함.\n        queue.offer(\"Data-5\"); \n        queue.offer(data_4);\n\n        System.out.println(queue);\n    &#125;\n&#125;\n\n[그림5] 코드 실행 결과\n코드를 보면 원하는 위치에 값을 넣기 위해서 큐의 값을 비우고 다시 채워주는 것을 볼 수 있습니다. 이는 큐가 원하는 위치에 값을 끼워넣는 것이 불가능 하기 때문입니다. 특정 인덱스에 있는 데이터를 처리하기 위해서는 ArrayList 를 이용해야합니다.\n2-3 오버플로우(Overflow)와 언더플로우(Underflow)마지막으로 스택과 큐는 오버플로우(Overflow)와 언더플로우(Underflow)에 주의해야합니다. \n오버플로우(Overflow) 란 스택/큐에 데이터가 꽉 찬 상태에서 데이터를 더 집어넣으려고 할 때에 발생하는 현상입니다. 공간이 없는데 무언가를 넣으려고 하면 당연히 넘치는데 그런 현상과 유사합니다.\n언더플로우(Underflow) 란 오버플로우와 반대되는 개념으로 데이터가 아무 것도 들어있지 않은 상태에서 데이터를 요청할때 발생하는 현상입니다. 텅 비어버린 상자에서 무언가를 꺼내려고하면 아무 것도 얻을 수 없는데 그럼에도 불구하고 무언가를 달라고 요청하니 발생하는 것입니다.\n이 두 가지의 취약점을 이용하여 공격하는 사이버 공격도 존재하니 오버플로우와 언더플로우를 회피할 수 있는 방법, 혹은 발생했을 경우의 대책을 마련해두는 것이 좋습니다.\n\n이번 포스트에서는 선형구조 중 하나인 스택과 큐를 정리했습니다.다음 포스트에서는 비선형구조 중 하나인 그래프에 대해 정리하도록 하겠습니다.\n","slug":"cs-stack-and-queue","date":"2021-06-27T07:30:37.000Z","categories_index":"Computer Science","tags_index":"Linear Structure,Stack,Queue","author_index":"Latte"},{"id":"a95016e8299093bc301492ede983aea1","title":"No.2588 곱셈","content":"이 포스트는 백준 알고리즘 사이트의 2588번 문제 곱셈을 정리한 페이지입니다. \nNo.2588 곱셈문제 링크 - https://www.acmicpc.net/problem/2588\n문제(세 자리 수) × (세 자리 수)는 다음과 같은 과정을 통하여 이루어진다.\n[그림1] 곱셈 문제  예시\n(1)과 (2)위치에 들어갈 세 자리 자연수가 주어질 때 (3), (4), (5), (6)위치에 들어갈 값을 구하는 프로그램을 작성하시오.\n입력첫째 줄에 (1)의 위치에 들어갈 세 자리 자연수가, 둘째 줄에 (2)의 위치에 들어갈 세자리 자연수가 주어진다.\n출력첫째 줄부터 넷째 줄까지 차례대로 (3), (4), (5), (6)에 들어갈 값을 출력한다.\n문제풀이문제의 내용을 한줄로 요약하자면, 사람이 계산하는 방식으로 곱셈을 행하는 코드를 짜는 것 입니다.사람이 계산하는 방식이니 일의 자리부터 계산이 시작되고, 이는 숫자의 맨 뒷 자리 수부터 읽어와야 한다는 것을 의미합니다.\n힌트 및 제약조건\n곱해지는 수는 1의 자리부터 곱해져야 한다.\n숫자는 세 자리 수만 제시된다.\n\n문제 풀이 흐름이 문제의 알고리즘 흐름은 다음과 같습니다.\n\n(3) = 472 x 5 를 구하고 값을 출력, 그리고 변수 sum에 저장한다.  \n(4) = 472 x 8 를 구하고 값을 출력, 그리고 10을 곱한 후 sum에 값을 더한다.  \n(5) = 472 x 3 를 구하고 값을 출력, 그리고 100을 곱한 후 sum에 값을 더한다  \nsum을 출력한다. 여기서 sum은 (6)이 된다.  \n\n전체 코드[No.2588] 곱셈.java\n[그림2] 코드 실행 결과\n","slug":"baekjoon-No-2588","date":"2021-06-27T05:22:22.000Z","categories_index":"코딩 테스트","tags_index":"algorithm,BaekJoon","author_index":"Latte"},{"id":"d93904bd8ecb573f2b3f624285e3ea2a","title":"6. JPA, Hibernate, Spring Data JPA","content":"과거에 스프링 프로젝트를 진행할 때에는 오라클 DB에 Mybatis를 사용했었습니다.때문에 이 책에서도 데이터베이스를 다루는 SQL mapper를 Mybatis로 사용할 것이라 추측했습니다.그러나 이 책에서 데이터베이스는 JPA를 통해 관리됩니다.  \n여기서 저자는 Mybatis를 사용하지 않는 이유를 실제로 개발하는 시간보다 SQL을 다루는 시간이 더 많기 때문이라고 서술하고 있는데, 생각해보니 저도 예전에 프로젝트를 작업할 때 프로젝트 자체보다는 SQL때문에 고통받던 시간이 길었던 것 같습니다.  \n하지만, JPA가 아무리 좋다고해도 JPA가 무엇이고, 왜 이것을 사용하는지, 어떤 부분에서 Mybatis보다 유용한지 알지 못한채로 사용하는 것은 의미가 없는 일이므로, JPA에 대해 정리해보는 시간을 갖겠습니다.\nJPA(Java Persistence API)1. JPA의 정의현대 웹 애플리케이션에서 관계형 데이터베이스(RDB;Relational Database)에서 객체를 관리하는 것은 중요합니다. 때문에 여러가지의 방식이 고려되고 있는데, 최근 많이 이용되는 방식으로 JPA가 있습니다. \nJPA는 자바 어플리케이션에서 관계형 데이터베이스를 관리하는 방식을 정의한 인터페이스이자 자바 표준 ORM(Object Relational Mapping) 기술입니다.\n\n\n\n\n\n\nSQL mapping vs JPA(ORM)\n\nSQL mapping: query를 맵핑하여 직접 DB를 조작합니다.: SQL - mapping - Object\nJPA(ORM; Object Relational Mapping): 객체와 DB의 데이터를 맵핑하여 메서드로 데이터를 조작합니다.: DB data - mapping - Object\n\n\n\n2. JPA 사용 이유JPA를 사용하는 이유는 크게 두 가지가 있습니다.\n2-1 생산성을 높이기 위해관계형 데이터베이스에서 가장 중요한 개념은 SQL인데, 이는 관계형 데이터베이스가 SQL만을 인식할 수 있기 때문입니다. 이러한 이유로 개발자들은 각 테이블마다 기본적인 CRUD(Create/Read/Update/Delete) SQL을 매번 생성해주어야합니다.  \n이러한 특성 탓에 개발자가 아무리 자바 클래스를 아름답게 설계해도, SQL을 통해야만 데이터베이스에 저장하고 조회할 수 있습니다. 문제는 프로젝트에 테이블이 한 개만 존재하지 않는다는 점입니다. 때문에 유사한 SQL이 반복됨에 따라 자바객체를 SQL로 SQL 객체를 자바 객체로 변환하는 과정 또한 반복됩니다. \n또한 프로젝트의 내용을 수정할 때마다 SQL도 수정해야하는 번거로움이 있습니다. 이러한 상황은 생산성과 유지보수에 나쁜 영향을 미치게 됩니다.\nJPA는 위의 서술한 것처럼 쿼리를 직접 작성하는 것이 아니라, 만들어진 객체로 데이터 베이스를 다루게 됩니다.때문에 객체중심의 개발이 가능하다는 장점이 있습니다.\n2-2 패러다임의 불일치를 해소하기 위해\n\n\n\n\n\n\n\n\n- 관계형 데이터베이스는 어떻게 데이터를 저장할지에 초점이 맞춰진 기술 입니다.- 객체지향 프로그래밍 언어는 메시지를 기반으로 기능과 속성을 한 곳에서 관리하는 기술입니다.\n한 눈에 봐도 목적과 사상이 다른데, 관계형 데이터베이스로 객체지향 언어를 표현할 수 있을까요?\n쉽지 않을겁니다. 관계형 데이터베이스와 객체지향 프로그래밍 언어의 패러다임이 서로 다른데, 객체를 데이터베이스에 저장하려고하니 문제가 발생합니다. 이를 패러다임의 불일치라고합니다.\n객체지향 프로그래밍 언어의 상속관계를 예로 들어보겠습니다.\nUser user = findUser();\nGroup group = user.getGroup();\n위의 코드를 보면 User와 Group은 부모-자식 관계임을 알 수 있습니다. User가 본인이 속한 Group의 정보를 가져오는 코드이기 때문입니다.그리고 이 코드에 데이터베이스가 추가되면 다음과 같습니다\nUser user = userDao.findUser();\nGroup group = groupDao.FindGroup(user.getGroupId());\n\n이렇게되면 User와 Group은 각자 따로 조회하게 됩니다. 즉, 상속이나 1:N등 다양한 객체 모델링을  데이터베이스로 구현할 수 없습니다.이러다보니 결국 Object를 SQL로 작성해야하고, 이 과정에서 Object &gt; SQL 변환 &gt; RDB에 저장하는 과정을 반복하게 됩니다.\n이는 개발자가 개발에 쓰는 시간보다 SQL 매핑작업에 시간을 쓰는 원인이 됩니다.\n결과적으로 JPA는 서로 지향하는 바가 다른 2개의 영역을 중간에서 조율해주고 패러다임을 일치시켜주기 위한 기술입니다. 개발자는 객체지향적으로 프로그래밍을 하고, JPA가 이를 관계형 데이터베이스에 맞게 SQL을 대신 생성해서 실행합니다. 이로인해 개발자는 SQL에 종속적인 개발을 하지 않아도 됩니다.\n3. JPA 구현체 - Hibernate이 항목에서는 JPA 구현체에 대해 이야기해보겠습니다. 이 카테고리를 적는 이유는, JPA와 Hibernate(JPA의 구현체), Spring Data JPA의 차이점이 뭔지, 왜 사용하는지에 대해 헷갈리기 때문입니다\n3-1 HibernateHibernate는 JPA의 구현체입니다. 즉, JPA가 가진 인터페이스를 직접 구현한 라이브러리입니다. 이 정의에서 가장 중요한 것은 JPA를 사용하기 위해서 반드시 Hibernate를 사용할 필요가 없다는 것입니다. Hibernate를 사용하지 않더라도 직접 구현해서 사용하면 될테니까요.  \n때문에 Spring에서 JPA를 사용할 때에도 이 구현체들을 직접 다루지는 않습니다. 우리는 구현체들을 좀 더 쉽게 사용하기 위해서 추상화시킨 Spring Data JPA라는 모듈을 사용할 것입니다.\n4. Spring Data JPASpring Data JPA는 JPA를 쓰기 편하게 만들어놓은 모듈입니다.JPA와 Hibernate(구현체), 그리고 Spring Data JPA의 관계를 설명하자면 다음과 같습니다.\n\n\n\n\n\n\n\n\n\n[그림6-1] JPA, Hibernate, and Spring Data JPA의 관계간단하게 이야기하자면 JPA의 구현체가 Hibernate, 이를 한단계 더 감싸놓은것이 Spring Data JPA입니다.\n\n레퍼런스 : Hibernate ORM 5.4.32.Final User Guide\n\n사실, Hibernate를 사용하건 Spring Data JPA를 사용하건 기능 상에 유의미한 차이는 없습니다.그럼에도 불구하고 Spring 제작팀은 Spring Data JPA를 사용하는 것을 권장하고 있는데 그 이유는 아래와 같습니다  \n4-1 구현체 교체의 용이성구현체 교체의 용이성은 현재 사용중인 구현체 외에 다른 구현체로 쉽게 교체하기 쉬운 특성을 의미합니다.  \n현재는 Hibernate가 상당히 잘 만들어지고 성숙된 구현체이므로 바꿀 필요가 없지만, 수명을 다해서 새로운 JPA 구현체가 대세로 떠올라 새로운 구현체로 교체해야하는 상황이라 가정해봅시다.  \n이렇게되면 어쩔 수 없이 구현체를 교체해야 할 필요성이 생기는데, Spring Data JPA를 사용한 프로젝트라면 내부에서 구현체 매핑을 지원해주기 때문에 아주 쉽게 교체가 가능합니다.\n4-2 저장소 교체의 용이성저장소 교체의 용이성은 관계형 데이터베이스 외에 다른 DB로 쉽게 교체할 수 있는 특성을 의미합니다.  \n예를 들어, 관계형 데이터베이스로 구성된 하나의 프로젝트를 생각해봅시다.  \n지금은 관계형 데이터베이스로도 충분히 서비스가 가능한 수준이지만, 프로젝트가 성장하고 커져감에 따라 트래픽이 많아져 관계형 데이터베이스로는 도저히 감당이 안될 상황이 생겼습니다. 이에 대한 대책으로 개발자들은 데이터베이스의 변경을 제안했고, MongoDB가 좋겠다는 결론에 도달합니다. 때문에 데이터베이스를 관계형 데이터베이스에서 MongoDB로 교체해야합니다.  \n이런 상황에서 프로젝트가 Spring Data JPA를 사용하여 구성되었다면, Spring Data JPA에서 Spring Data MongoDB로 의존성 교체만하면 저장소를 쉽게 교체할 수 있습니다. 게다가 사용하는 메서드나 기능은 대체로 비슷하기때문에 코드를 수정할 필요성도 없습니다.\n이러한 특성 때문에 Spring 제작팀은 구현체를 직접 사용하는 것 보다 Spring Data를 사용하는 것을 권하고 있습니다.\n\n이번 포스트에서는 JPA를 사용하는 이유. 그리고 hibernate와 Spring Data JPA는 무엇인지 살펴보았습니다.다음 포스트에서는 이를 직접 스프링 프로젝트에 적용해보도록 하겠습니다.\n\n레퍼런스  \n\nJPA, Hibernate, 그리고 Spring Data JPA의 차이점  \nJPA는 도대체 뭘까? (orm, 영속성, hibernate, spring-data-jpa)\n\n","slug":"springboot-web-7","date":"2021-06-23T07:43:58.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,Java,JPA","author_index":"Latte"},{"id":"a4c20de877725d90cf1ede9509e3fa58","title":"1. 자료 구조","content":"오랜만에 집정리를 하던 도중, 정보처리기사 책을 발견했습니다.자격증을 딴 이후로 방치된 책인데 오랜만에 열어보니 덜 풀은 문제가 있더군요.문제를 다 푼 후에 버릴 심산으로 심심할 때마다 정보처리기사 문제를 풀게 되었습니다.그런데 의외로 정리해두면 좋을 것 같은 문제가 많았는데 그 중에 하나가 자료 구조였습니다.때문에 이 포스트에서는 자료 구조의 정의와 중요한 자료 구조 분류를 정리해보려 합니다.\n자료구조(Data Structure)1. 정의자료 구조(Data Structure)는 말 그대로 데이터를 담는 구조이자 데이터의 집합을 의미합니다. 여기서 각 원소들은 논리적으로 정의된 규칙에 의해 나열되며, 자료를 효율적으로 처리할 수 있도록 구분하여 표현됩니다.이러한 자료구조는 프로그램 내에서 데이터를 가장 효율적으로 저장하고 처리하기 위해 사용되며, 잘 선택된 자료 구조는 보다 좋은 성능을 발휘합니다.\n자료 구조의 종류는 다양하고, 각각의 자료 구조는 각자의 연산 및 목적에 맞게 구성되어 있습니다.때문에 그 특징을 알고 각자에 맞는 알고리즘을 사용하는 것이 매우 중요합니다.\n2.  자료 구조의 분류2-1. 단순 구조(Simple Structure)단순 구조는 컴퓨터가 기본적으로 제공하는 자료형을 의미합니다.\n\n\n\n\n\n\n단순 구조 종류\n\ntrue, false (boolean)\nint, long, float, double\nchar, String\n\n\n\n2-2. 선형 구조(Linear Structure)선형 구조는 데이터들이 일렬로 정렬되어 저장된 상태를 의미합니다.이 자료 구조는 단순히 일렬로 저장하는 방식(스택과 큐도 포함) 과 각 데이터가 다음 데이터의 위치를 가지는 연결 리스트 방식으로 구분됩니다.\n\n\n\n\n\n\n선형 구조 종류\n\nArray\nStack\nQueue\nDe-Queue\nLinked List\n\n\n\n2-3. 비선형 구조(Non-Linear Structure)데이터가 트리형태로 저장되어 있다고 생각하고 사용하는 자료구조이며 자료의 표현에 중점을 두고 있습니다.자료의 순서가 불규칙하고, 자료의 관계가 1:N의 관계를 갖는 등 관계가 복잡하거나 계층을 갖는 경우 주로 사용됩니다.\n\n\n\n\n\n\n비선형 구조 종류\n\nTree - General Tree(일반 트리) / Binary Tree(이진 트리)\nGraph - Directed Graph(방향 그래프) / Undirected Graph(무방향 그래프)\n\n\n\n2-4. 파일 구조(File Structure)파일을 구성하는 레코드들이 보조 기억 장치에 저장되는 방식을 의미합니다.파일 편성 방법에 따라 파일 접근 방법을 분류할 수 있어서 파일 접근 방법이라고도 합니다.\n\n\n\n\n\n\n파일 구조 종류\n\nSequential File (순차 파일 / 순서 파일)\nIndexed Sequential File(색인 순차 파일 / ISAM;Index Sequential Access Method)\nDirect File(직접 파일 / DAM;Direct Access Method)\n\n\n\n\n여기까지, 자료 구조의 정의 및 분류를 알아보았습니다.앞으로 정리할 자료 구조의 종류는 선형 구조와 비선형 구조 위주로 정리될 예정입니다.그 이유는 이 두 개의 자료 구조는 알고리즘에서 제일 중요하게 다뤄지는 자료 구조이기 때문입니다.그럼, 자료 구조의 종류와 특징에 대해서는 다음 포스트에서 진행하도록 하겠습니다.\n\n출처블로그 - 자료구조 : 자료구조란? (Data Structure)블로그 - [Data structure] 자료구조 종류와 분류\n","slug":"cs-data-structure","date":"2021-06-23T05:05:59.000Z","categories_index":"Computer Science","tags_index":"Computer Science,Data Structure","author_index":"Latte"},{"id":"de3f69ccc161905f5bded0c2342c2211","title":"3. 구현(Implementation)","content":"친구들과 알고리즘 공부를 하면서 “이해는 했는데 코드로 짜기가 힘들다”라는 말을 하곤 했습니다.그때는 알고리즘은 원리만 알면 풀 수 있는거 아니야? 하는 생각도 있었는데, 지금 생각해보니 정말 얼토당토않은 말이었죠.알고리즘이 중요하게 다뤄지는 이유는 문제 해결을 위해 방법을 찾고 그 방법을 구현하는 것이기 때문이니까요.때문에 이 포스트에서는 구현에 대해 한 번 정리하고, 자주 사용되는 메서드 등을 정리해 나가려 합니다.\n구현(Implementation)1. 정의코딩테스트에서 구현(Implementation)이란 ‘머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정’입니다.어떤 문제를 풀든 간에 소스코드를 작성하는 과정은 필수이므로, 구현 문제 유형은 모든 범위의 코딩 테스트 문제 유형을 포함하는 개념이지만 코딩 테스트에서 말하는 구현문제는 풀이를 떠올리는 것은 쉽지만, 코드로 옮기기에는 어려운 문제를 의미합니다.\n보통 구현 문제는 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제나 특정 소수점 자리까지 출력해야하는 문제, 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야하는 문제 등 알고리즘 자체보다 라이브러리 사용 경험이 필요한 문제가 많습니다.\n때문에 다양한 유형의 구현 문제를 접하고, 자주 쓰이는 라이브러리와 메소드의 사용법 등을 익혀두는 것이 문제 풀이에 도움이됩니다.  \n(출처 : 이것이 취업을 위한 코딩테스트다 with 파이썬)\n2. 문제구현 문제의 유형은 다양해서 몇 가지 유형으로 분류하는 것이 쉽지 않습니다.때문에 아래의 백준 온라인 저지 홈페이지의 문제 유형에서 구현을 찾아서 풀어보는 것을 추천드립니다.(백준 온라인 저지 - 구현(Implementation) 알고리즘 문제)\n3. 개인적으로 유용하다고 생각하는 라이브러리이 항목은 문제를 풀때마다 추가 될 예정이며 Java 8 API를 기준으로 합니다. \n1) java.util.Arrays\nArrays.copyOfRange(array, start, end): 배열의 특정 위치를 복사하여 새로운 배열로 만드는 메서드\nArrays.sort(array): 배열을 정렬하는 메서드\n\n2) java.util.Comparator\ncompare(a, b): a와 b를 비교하여 a가 더 작은 경우 -1을, 둘이 같다면 0, a가 더 큰 경우에는 1을 반환: 다음과 같이 오버라이트를 통해 응용해서 사용이 가능하다는 점에서 중요하게 봐둘 필요가 있음  \n\nArrays.sort(nums, new Comparator&lt;String>()&#123;\n    @Override\n    public int compare(String num1, String num2) &#123;\n        return (num2+num1).compareTo(num1+num2);\n    &#125;\n&#125;);\n\n3) java.util.Map / java.util.HashMap\nmap.containsKey(key)  / map.containsValue(value): map 안에 key / value 값이 있는지 확인하는 메서드  \nmap.values(): map 객체를 Collection 객체로 반환하는 메서드\nmap1.putAll(map2): map_1의 객체와 map_2의 객체를 합쳐서 반환하는 메서드\n\n4) 기타 기본 라이브러리\nstr1.startsWith(str2): str1이 str2로 시작하는지 체크하는 메서드\nstr1.endsWith(str2): str1이 str2로 끝나는지 체크하는 메서드\nstr.join(“추가할문자”, “대상 array 혹은 list”): array 혹은 list를 더해주는 메서드. 추가할 문자에 값을 넣으면 그 값이 구분자가 됨.\n\n\n구현 문제를 알고리즘이라고 말할 수 있을까 고민했습니다.하지만 생각해보면 로직을 생각하기만 하고 코드를 구현하지 않는다면 무슨 의미가 있을까?하는 생각과 동시에 코드를 구현한다는 것 자체가 알고리즘의 핵심이라는 생각이 들었죠.때문에 블로그에 알고리즘의 유형으로 정의해두었습니다만, 유형이라기보다는 프로그래밍을 하는 사람이라면 반드시 갖춰야하는 능력이 아닐까 싶습니다.많은 문제를 접하며 경험을 쌓는 것. 이건 비단 알고리즘 문제에서만 통용되는 부분은 아니니까요.\n","slug":"algorithm-implementation","date":"2021-06-17T06:09:51.000Z","categories_index":"알고리즘","tags_index":"algorithm,Implementation","author_index":"Latte"},{"id":"08591114c8a1ce3933292eb92a5512bc","title":"5. 롬복(Lombok)으로 기존 코드 리팩토링","content":"이 포스트에서는 여태까지 작성한 코드를 롬복으로 리팩토링해보겠습니다. \n롬복(Lombok)으로 기존 코드 리팩토링5-1 HelloResponseDto 클래스 추가HelloResponseDto 클래스를 추가합니다.위치는 web 패키지 &gt; dto 패키지 입니다. \n[그림5-1] HelloResponseDto 클래스 위치앞으로 모든 response dto는 이곳에 추가하도록 하겠습니다!\n여기서 DTO가 무엇이고, 왜 추가하는지 의문이신 분도 있을거라고 생각합니다.DTO란 아래와 같습니다.\n\n\n\n\n\n\nDTO(Data Transfer Object)란?\n계층간 데이터 교환을 위한 객체(Java Bean)이자, DB에서 얻은 데이터를 전송할 때 사용하는 객체.로직(메서드)을 갖지 않는다는 특징이 있으며, DB에서 얻은 값을 수정하는 경우가 거의 없어 setter()는 갖지 않고 getter()만을 갖는 경우가 많다.\n\n즉, DB에서 가져온 정보를 담거나 DB에 저장할 정보를 담는 그릇이 필요한데 그것이 DTO인 것입니다.앞으로의 프로젝트는 데이터베이스의 데이터를 가져오거나 저장하는 동작을 할 것입니다.때문에 DB와의 데이터 교환은 DTO를 통해 진행하도록 하겠습니다.\n참고로 DTO를 검색하면 항상 같이 나오는 DAO라는 용어가 있습니다.\n\n\n\n\n\n\nDAO(Data Access Ocject)란?\nDB에 접근하는 객체로 이름 그대로 Service와 DB를 연결하는 역할을 하는 객체.\n\nDTO와 DAO는 이름이 비슷하고 DB와 관련되어 있다는 공통점때문에 자주 헷갈리니, 여기서 한 번 읽어보고 가도록 합시다!\n5-2 HelloResponseDto 코드 작성클래스 추가가 완료되었다면, 클래스 내부에 다음과 같은 코드를 작성합니다.\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\n\n@Getter\n@RequiredArgsConstructor\npublic class HelloResponseDto &#123;\n    private final String name;\n    private final int amount;\n&#125;\n\n주목해서 봐야할 것은 @Getter와 @RequiredArgsConstructor입니다.이들의 내용은 아래와 같습니다.\n\n\n\n\n\n\n\n\n\n\n@Getter: 선언된 모든 필드의  getter를 생성해줍니다.  \n@RequiredArgsConstructor: final로 선언된 필드가 포함된 생성자를 생성해줍니다.\n\nimport의 경로를 보면 이 2개의 어노테이션은 Lombok 어노테이션이라는 것을 알 수 있습니다.롬복의 어노테이션은 이와같이 코드를 굳이 적지 않아도 내부적으로 생성해주어 코드의 길이를 줄일 수 있습니다.\n5-3 HelloResponseDto의 테스트 코드 작성HelloResponseDto 클래스의 코드 작성이 완료되었습니다.이제 이 코드를 테스트할 테스트 클래스를 생성하고, 아래의 코드를 작성해주세요.\nclass HelloResponseDtoTest &#123;\n    @Test\n    public void 롬복_기능_테스트()&#123;\n        // given\n        String name = \"test\";\n        int amount = 1000;\n\n        // when\n        HelloResponseDto dto = new HelloResponseDto(name, amount);\n\n        // then\n        assertThat(dto.getName()).isEqualTo(name);\n        assertThat(dto.getAmount()).isEqualTo(amount);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n@Test: 테스트를 수행하는 메소드를 선언  \nAssertThat(): 테스트 검증 라이브러리인 assertj의 검증 메소드  \nisEqualTo(): assertThat()에 이어사용하는 메소드로 assertj의 동등 비교 메소드\n\n테스트 코드의 작성이 완료되었습니다! 그럼, 테스트를 실행해봅시다.\n5-4 error: variable name not initialized in the default constructor 메시지의 해결테스트 코드를 실행하면, error: variable name not initialized in the default constructor라는 에러 메시지가 표시됩니다.번역하자면 디폴트 생성자에서 변수의 이름이 초기화되지 않았다는 의미입니다. 이 메시지는 뭘까요?이 에러 메시지는 롬복이 제대로 주입(DI)되지 않았을 때에 발생하는 에러입니다.그렇다면 이전에 추가해주었던 의존성이 잘못된 걸까요?정답부터 말하자면, 단순히 gradle의 버전과 관련된 문제입니다.gradle5 버전부터는 어노테이션을 구별해서 추가해주지 않으면 제대로 주입되지 않습니다.때문에 Lombok Gradle plugin을 추가하거나, annotationProcessor에 Lombok을 추가하여 컴파일 범위를 지정해주어야 합니다.(출처 : Project Lombok)\n&#x2F;&#x2F; Lombok Gradle plugin을 추가하는 방법\nplugins &#123;\n  id &quot;io.freefair.lombok&quot; version &quot;6.0.0-m2&quot;\n&#125;\n&#x2F;&#x2F; annotationProcessor를 추가하는 방법\ndependencies &#123;\n\tcompileOnly &#39;org.projectlombok:lombok:1.18.20&#39;\n\tannotationProcessor &#39;org.projectlombok:lombok:1.18.20&#39;\n&#125;\n\n여기서는 Lombok Gradle plugin을 추가하는 방법을 사용하여 에러 메시지를 해결하도록 하겠습니다.그럼, build.gradle의 plugins { } 안에 위의 코드를 추가하고, gradle을 reload 해주세요.\n[그림5-2] Lombok Gradle plugin 추가\n이제 다시 테스트를 실행하면, 에러 메시지가 없어지고 tests passed가 되는 것을 볼 수 있습니다.이렇게 되면 롬복의 @Getter 어노테이션으로 get메서드가, @RequiredArgsConstructor로 생성자가 자동으로 생성된 것입니다.\n그럼 HelloController에도 새로만든 ResponseDto를 사용하도록 코드를 추가해봅시다!\n5-5 HelloController가 ResponseDto를 사용하도록 수정HelloController클래스의 hello 메서드를 아래의 코드처럼 변경합니다.\n@GetMapping(\"/hello/dto\")\npublic HelloResponseDto helloDto(@RequestParam(\"name\") String name,\n                                 @RequestParam(\"amount\") int amount)&#123;\n   return new HelloResponseDto(name, amount);\n&#125;\n\n\n\n\n\n\n\n\n\n\n@RequestParam(“paramName”): 외부에서 API로 넘긴 파라미터를 가져오는 어노테이션→ 위의 코드에서는 외부에서 name으로 넘긴 파라미터를 String name 변수에 저장해 사용\n\n이제, 변경한 코드가 제대로 동작하는지 확인하기 위해 HelloControllerTest에 테스트 코드를 추가하겠습니다.\n5-6 HelloControllerTest에 테스트 코드 추가아래의 임포트를 추가해주세요. 이 임포트는 is 메서드를 사용하기 위해 추가합니다.is()는 내부적으로 equalTo()와 같은 것으로 가독성을 증진시키기 위해 사용하는 메서드입니다.\nimport static org.hamcrest.Matchers.is;\n\n아래의 테스트 메서드를 추가해주세요.\n@Test\npublic void helloDto가_리턴된다() throws  Exception &#123;\n    String name = \"hello\";\n    int amount = 1000;\n\n    mvc.perform(get(\"/hello/dto\")\n                .param(\"name\", name)\n                .param(\"amount\", String.valueOf(amount))\n    )\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.name\", is(name)))\n            .andExpect(jsonPath(\"$.amount\", is(amount)));\n&#125;\n\n\n\n\n\n\n\n\n\n\n\nparam(): API 테스트할 떄 사용될 요청 파라미터를 설정합니다. 단, 값은 String만 허용됩니다.\njsonPath(): JSON 응답값을 필드별로 검증할 수 있는 메소드입니다. $를 기준으로 필드명을 명시합니다.\n\n이제 추가된 API의 테스트를 실행해봅시다.\n[그림5-3] helloDto 테스트 메서드 추가\n테스트가 문제없이 통과되는 것을 확인하실 수 있습니다.\n\n기존 코드를 롬복을 사용해 리팩토링 해보았습니다. DTO의 코드가 짧은걸 느낄 수 있으신가요?원래라면 DTO에 Getter, Constructor, toString 같은 요소를 전부 적어주어야 합니다.하지만, 롬복을 통해 어노테이션 두 개와 속성 두 개로 DTO의 코드가 해결되었습니다.앞으로의 코드는 이 유용한 라이브러리인 롬복을 이용해서 코드를 작성하도록 하겠습니다.\n","slug":"springboot-web-6","date":"2021-06-16T14:03:34.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,Java,Lombok","author_index":"Latte"},{"id":"4f4324f9c57576ee9b59f6532264f460","title":"4. 프로젝트 설정 확인과 롬복(Lombok)","content":"이 포스트에서는 롬복을 소개하고 프로젝트에 롬복을 추가하여 사용해보도록 하겠습니다.\n롬복(Lombok)자바 개발자들의 필수 라이브러리 롬복(Lombok)은 어노테이션 기반으로 코드를 자동완성 해주는 라이브러리입니다.롬복을 이용하면 생성자 및 Getter와 Setter 등의 코드를 자동완성 시킬 수 있습니다.이런 자동완성을 통해 사용자는 클래스 내에 직접 코드를 작성하지 않아도 해당 메소드를 사용할 수 있게 됩니다.때문에 코드가 단순해지고 가독성이 좋아지는데 이러한 단순화를 코드 다이어트라고 부르기도 합니다.\n그럼, 프로젝트에 롬복을 추가하고 롬복을 기반으로 리팩토링하여 롬복의 코드 자동완성이 어떤 의미인지 살펴보도록 합시다.(리팩토링은 다음 포스트에서 진행됩니다.)\n4-1 롬복 추가그럼 프로젝트에 롬복을 추가해봅시다.추가 방법은 build.gradle의 dependencies에 다음의 코드를 추가하는 것입니다.\ndependencies &#123;\n    compileOnly group: &#39;org.projectlombok&#39;, name: &#39;lombok&#39;, version: &#39;1.18.20&#39;\n&#125;\n[그림4-1] Lombok 의존성 추가\nbuild.gradle에 롬복 의존성을 추가하였으니, gradle을 빌드하여 롬복을 프로젝트에 내려받도록 합니다!\n4-2 롬복 플러그인 추가gradle을 통해 롬복 라이브러리의 임포트가 완료되었다면, 이번엔 롬복 플러그인을 설치합니다.인텔리제이에서 플러그인 설치는 plugins에서 가능하며 윈도우는 [Ctrl + Shift + A], 맥은 [Command + Shift + A] 를 누른 후, plugins를 검색하여 이동이 가능합니다.  \n[그림4-2] intellij plugins로 이동\nPlugins의 MarketPlace 탭으로 이동하여 Lombok을 검색하고 설치한 후 인텔리제이를 재시동해줍니다.\n[그림4-3] Lombok plugin 설치\n(저는 이미 플러그인을 설치한 상태라 installed에 표시됩니다. 처음 설치하시는 분은 Marketplace에 표시될겁니다.)\n4-3 Lombok Annotation Processing 셋팅이번에는 Lombok Annotation Processing을 설정하도록 하겠습니다.롬복을 추가하고, 플러그인까지 설치했는데 빌드를 하면You aren&#39;t using a compiler supported by lombok, so lombok will not work and has been disabled.라는 에러 메시지가 뜨면서 빌드에 실패하게 될겁니다.이런 문제를 해결하기 위해서는 annotation processing을 체크하여 인텔리제이가 롬복을 사용할 수 있게 설정해주어야 합니다.\n먼저, 인텔리 제이의 Preferences로 이동하여 Annotation Processor를 검색하여 해당 메뉴로 이동합니다.해당 메뉴에서 “Enable annotation processing”을 체크하면 설정 완료 입니다.\n[그림4-4] Lombok Annotation Processing 설정\n\n\n\n\n\n\nTIP\n롬복의 플러그인 설치는 한 번이면 끝나지만, Enable Annotation Processing은 프로젝트마다 설정해주어야 합니다.새로운 프로젝트를 만들게된다면 잊지말고 설정해주세요!\n\n\n이제, 롬복의 셋팅이 완료되었습니다!다음 포스트에서는 기존 코드를 롬복을 이용해 리팩토링 하는 시간을 갖겠습니다.\n","slug":"springboot-web-5","date":"2021-06-14T03:18:58.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,java,Lombok","author_index":"Latte"},{"id":"4db30505bd3613ad654d9a53e43df5c4","title":"2. 탐욕 알고리즘(Greedy Algorithm)","content":"이번 포스트에서는 탐욕 알고리즘(Greedy Algorithm)에 대해서 정리하겠습니다.사실 코딩 테스트에서 탐욕 알고리즘은 출제 빈도가 낮은 편에 속합니다.(프로그래머스 기준)그럼에도 탐욕 알고리즘을 정리하는 이유는 이를 공부하다보면 알고리즘 문제의 원리를 깨닫는 능력을 향상시키는 데에 도움이 될 것이라 생각했기 때문입니다.즉, 탐욕 알고리즘의 정리를 통해 문제가 요구하는 최소한의 원리를 떠올릴 수 있는 능력을 키워보려 합니다.\n탐욕 알고리즘 (Greedy Algorithm)1. 정의탐욕 알고리즘(Greedy Algorithm)은 매 순간 가장 좋아보이는 최적의 선택을 하는 방법으로 진행하여 최종적인 해답에 도달하는 방식입니다.Greedy라는 단어는 “탐욕”이라는 뜻을 가지므로 국내에서는 탐욕 알고리즘으로 불립니다. (이하 탐욕 알고리즘)\n그리디 알고리즘은 가장 좋아보이는 것이라는 기준이 존재하므로 문제에서 “가장 큰 순서대로”, “가장 작은 순서대로”와 같은 기준을 알게 모르게 제시해줍니다.때문에 그리디 알고리즘은 정렬 알고리즘과 짝을 이뤄 출제되는 경우가 많습니다.\n2. 문제탐욕 알고리즘의 가장 유명한 예시는 동전 문제 입니다.거스름 돈 문제를 예를 들어 탐욕 알고리즘을 설명하겠습니다.(아래의 문제는 나동빈님의 저서 「이것이 취직을 위한 코딩 테스트다 with 파이썬」에서 발췌한 문제입니다)\n\n\n\n\n\n\n거스름 돈\n당신은 계산을 도와주는 점원입니다.카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재합니다.손님에게 거슬러주어야할 돈이 N원일 때, 거슬러 줘야 할 동전의 최소 개수는 몇 개인가요?단, 거슬러 줘야할 돈 N은 항상 10의 배수입니다.\n\n동전의 개수를 최소화 하는 것이 이 알고리즘의 목적입니다.그럼 동전의 개수를 최소화 하기 위해서는 어떻게 해야할까요?생각을 잘 정리해봅시다. 저는 아래와 같이 생각이 흘러갔습니다.\n\n\n\n\n\n\n\n\n\n\n동전의 종류를 살펴보면, 500원은 100원을 5개 모아야하고, 50원은 10원을 5개 모아야 한다.  \n동전이 여러 개 모이면 큰 금액의 동전이 된다.  \n동전의 개수를 줄이기 위해서는 큰 금액의 동전을 먼저 사용하는 것이 유리하다.\n\n저는 이런식으로 “가장 큰 화폐 단위부터 돈을 거슬러주어야 동전의 개수가 최소화된다” 라는 생각을 유추해냈습니다.그럼 이 생각을 코드로 짜기위해서 어떻게 해야할지 고민해보겠습니다. (자바 기준 서술)\n\n\n\n\n\n\n\n\n\n\n동전 종류를 담는 배열에 동전의 금액이 큰 것부터 내림차순으로 선언한다.\n동전의 개수를 셀 변수를 선언한다.\n동전의 종류를 돌면서 거슬러줄 수 있는 만큼 거슬러주고, 그만큼을 동전의 개수에 추가한다.\n거슬러준 금액을 원래의 금액에서 차감한다.\n\n이것이 제가 생각한 알고리즘의 흐름이고, 이것을 자바로 표현하면 아래와 같습니다.\npublic static void main(String[] args) &#123;\n        int n = 1260;\n        int [] coins = &#123;500, 100, 50, 10&#125;;\n        int coin_count = 0;\n\n        for (int i = 0; i &lt; coins.length; i++) &#123;\n            int coin = n / coins[i];\n            coin_count += coin;\n            n -= (coin * coins[i]);\n        &#125;\n        System.out.println(coin_count);\n&#125;\n\n3. 주의점-1 : 탐욕 알고리즘이 아닐 가능성탐욕 알고리즘은 탐욕적으로 문제에 접근했을 때, 정확한 답을 찾을 수 있다는 보장이 있을 때에는 매우 효과적이고 직관적입니다.위의 문제를 그리디 알고리즘으로 해결할 수 있는 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문입니다.즉, 큰 단위가 작은 단위의 배수 형태이기에 큰 동전부터 거슬러주고, 작은 동전을 거슬러준다는 말이 성립되는 겁니다. \n예를 들어 만들어야 하는 금액이 800원이고, 화폐의 단위가 100원, 400원, 500원이라면 그리디 알고리즘은 500원 1개과 100원 3개의 조합을 생각해낼 것입니다.그러나 가장 효과적인 조합은 400원짜리 2개입니다.때문에 화폐의 배열이 무작위인 경우, 그리디 알고리즘으로는 해결할 수 없으니 주의할 필요가 있습니다.\n4. 주의점-2 : 탐욕 알고리즘은 결과가 전체적으로 최적이 아닐 가능성탐욕 알고리즘은 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않습니다.때문에 선택의 순간마다 하는 선택은 최적이지만, 이것이 전체적으로 최적이라는 보장은 없습니다. \n그러나 어떤 특별한 구조가 있는 문제에 대해서는 탐욕 알고리즘이 언제나 최적해를 찾아낼 수 있는데 이 구조를 매트로이드라고 합니다.\n\n지금까지 탐욕 알고리즘의 정의와 기본 원리에 대해서 알아보았습니다.탐욕 알고리즘에서 중요한 것은 아래의 두 가지 입니다.\n\n\n\n\n\n\n\n\n\n\n문제가 요구하는 최소한의 원리를 알아낼 수 있는가\n이것이 탐욕 알고리즘이라는 확신이 있는가\n\n이 두 가지를 가슴에 새기고, 다양한 문제를 풀어보며 감을 익혀가도록 합시다.탐욕 알고리즘에 관해서는 여기까지 적도록 하겠습니다.\n","slug":"algorithm-greedy","date":"2021-06-13T01:27:11.000Z","categories_index":"알고리즘","tags_index":"algorithm,Greedy","author_index":"Latte"},{"id":"d6a03e07ef9853873ef42e3c7ea6ee4a","title":"1. 알고리즘의 복잡도","content":"프로그래밍 공부를 하는 사람이라면 “복잡도(Complexity)”라는 단어를 한 번 쯤은 들어봤을겁니다.그런데 이게 대~충은 알 것 같은데 막상 누군가에게 복잡도에 대해서 설명하려고 하면 설명하기 어려운 경우가 많습니다.때문에 이 포스트에서는 알고리즘과 관련된 개념을 정리하는 시간을 가져보려고 합니다.\n1. 복잡도(Complexity)복잡도는 알고리즘의 성능을 나타내는 척도로 문제를 해결하는 데에 알고리즘이 얼마나 복잡하게 문제를 해결하는 지를 나타냅니다. 복잡도는 크게 시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)로 구분됩니다.\n\n시간 복잡도 : 알고리즘이 어떤 문제를 해결하는 데에 걸리는 시간\n공간 복잡도 : 알고리즘이 어떤 문제를 해결하는 데에 차지하는 메모리\n\n즉, 시간 복잡도는 알고리즘의 수행시간을, 공간 복잡도는 알고리즘의 메모리 사용량을 나타냅니다.  \n동일한 기능을 수행하는 알고리즘이 있다면 일반적으로 복잡도가 낮을수록 좋은 알고리즘입니다.복잡도를 표현할 때에는 빅오(Big-O)표기법을 사용하는데 이에 대한 자세한 내용은 아래에서 다루도록 하겠습니다.\n1-1 시간 복잡도(Time Complexity)시간 복잡도는 알고리즘이 문제를 해결하기 위한 연산의 횟수를 말합니다.프로그램이 비효율적으로 작성되어 연산 횟수가 증가하는 경우, 시간 복잡도도 증가하게 됩니다.알고리즘 문제에서 단순히 복잡도라고 하면, 보통 이 시간 복잡도를 의미합니다.  \n\n\n\n\n\n\n\n\n\n보통 시간 복잡도에서의 “연산”은 프로그래밍 언어에서 지원하는 사칙 연산, 비교 연산 등과 같은 기본 연산을 의미합니다.\n1-2 공간 복잡도(Space Complexity)공간 복잡도는 알고리즘의 동작을 위해 필요한 메모리의 양을 의미합니다.최근에는 주기억장치인 RAM의 용량이 커져서 중요도가 낮아졌지만, 임베디드나 펌웨어 환경 등 하드웨어 환경이 매우 한정되어 있는 분야에서는 중요하게 고려되어야 합니다.\n시간 복잡도와 공간 복잡도는 반비례하는 경향이 있습니다.최근에는 공간 복잡도보다 시간 복잡도를 더 중요하게 생각하므로 메모리를 더 많이 사용해서 실행 시간을 비약적으로 줄이기도 하는데 이러한 기법을 메모이제이션(memoization)이라고 합니다.\n\n\n\n\n\n\n메모이제이션(memoization)\n컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술로, 동적 계획법의 핵심이 되는 기술입니다. (출처 : 위키피디아 - 메모이제이션)\n\n2. 빅오 표기법(Big-O)빅오 표기법은 점근 표기법 중 하나로 최악의 경우를 우선적으로 고려하는 방식입니다.\n\n\n\n\n\n\n점근 표기법(asymptotic notation)\n어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법으로 알고리즘의 복잡도를 단순화할 때나 무한급수의 뒷부분을 간소화할 때 사용됩니다. (출처 : 위키피디아 - 점근 표기법)\n\n2-1 시간 복잡도의 빅오 표기법시간 복잡도의 빅오 표기법은 다음과 같습니다. 위에서 아래로 내려갈 수록 시간 복잡도가 증가합니다.  \n\n\n\n빅오 표기법\n명칭\n특징\n\n\n\nO(1)\n상수 시간(Constant time)\n주어진 입력 자료에 관계 없이 일정한  연산 시간\n\n\nO(logN)\n로그 시간(Logt ime)\n이진트리나 이진탐색에서 찾아 볼 수 있는 연산 시간. 시간이 지날수록 작업을 수행하는 단계가 반 씩 줄어드는 특징을 지님\n\n\nO(N)\n선형 시간(Linear time)\n수행시간이 입력 크기에 따라 선형적으로 증가함을 의미\n\n\nO(NlogN)\n선형 로그 시간(Linearithmic time)\nn log n 수행시간은 간단히 Θ(log n) 연산의 n 배 수행시간의 결과 가짐\n\n\nO(N²)\n이차 시간\n작업을 수행하는데 걸리는 단계의 수가 n의 제곱\n\n\nO(N³)\n삼차 시간\n작업을 수행하는데 걸리는 단계의 수가 n의 세제곱\n\n\nO(2N)\n지수 시간\n작업을 수행하는 데 걸리는 단계의 수가 n의 크기에 따라 일정함\n\n\n(출처 : 위키피디아 - 시간 복잡도)(출처 : [알고리즘] 시간 복잡도, 공간 복잡도, 빅오(Big O))\n2-2 공간 복잡도의 빅오 표기법시간 복잡도를 이해하셨다면 공간 복잡도의 빅오 표기를 이해하는 데에 어려움이 없을 겁니다.예를들어, 크기가 n인 배열을 만들고 싶다면 O(n)의 공간이 필요하고, 크기가 n인 2차원 배열을 만들고싶다면 O(n²)의 공간이 필요합니다.\n공간 복잡도의 경우 메모리 사용량의 기준은 MB로 표시됩니다. 보통 코딩테스트에서는 메모리 사용량을 128~512MB로 제한합니다.이는 데이터의 개수가 1,000만 단위가 넘어가지 않게 설계해야한다는 의미입니다.\n\n여기까지, 간단하게 복잡도에 대해서 알아보았습니다.사실, 좀 더 깊이 들어가면 수학적 계산도 필요하고 알아볼 내용이 더 많습니다.하지만, 이번 포스트의 목표가 복잡도의 개념을 설명할 수 있게 되는 것이기에 여기까지만 정리하도록 하겠습니다.다음에는 기초적인 알고리즘에 대해 정리해보도록 하겠습니다.\n","slug":"algorithm-complexity","date":"2021-06-12T12:42:51.000Z","categories_index":"알고리즘","tags_index":"algorithm,complexity","author_index":"Latte"},{"id":"1bc1fccedcb28371ce507abc90a2b06f","title":"3. 프로젝트 설정 확인","content":"이 포스트에서는 이전까지 작성한 프로젝트가 제대로 동작하는지 테스트하도록 하겠습니다.테스트코드를 작성하기 전에 기능테스트를 위한 간단한 API를 작성해보겠습니다.\n“hello”를 반환하는 GET method API 만들기3-1 패키지 생성프로젝트에서 경로 src &gt; main &gt; java 디렉토리 에 패키지를 생성합니다.일반적으로 패키지명은 웹 사이트 주소의 역순으로 작성합니다. 저는 com.dev.latte.springboot로 작성했습니다.\n[그림3-1] 패키지 생성\n3-2 Application 클래스 생성방금 작성한 패키지에 Application이라는 이름으로 자바 클래스파일을 추가해줍니다.여기서 주의할 것은 경로가 다르면 안된다는 것과 클래스의 맨 첫글자가 대문자라는 것입니다.이는 자바의 명명규칙으로 자바의 클래스 이름의 첫 글자는 항상 대문자로 작성되어야 합니다.자바 명명규약(Naming Rule)은 기회가 된다면 다루어보도록 하겠습니다.\n[그림3-2] Application 클래스 생성\n3-3 클래스 내용 작성Application 클래스에 아래의 코드를 작성합니다.지금 작성하는 Application.class는 프로젝트의 메인클래스가 됩니다!\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(Application.class, args);\n    &#125;\n&#125;\n\n\n\n\n\n\nimport가 자동으로 추가되지 않는다면?\n    import가 자동으로 추가되지 않는다면, 추가되지 않아 붉게 변한 코드로 이동한 후 윈도우는 [alt + enter], 맥은 [option + enter]를 눌러 직접 import해주세요.\n\n\n\n\n\n\n\n\n\n\n\n@SpringBootApplication: 스프링 부트의 자동 설정, 스프링 bean읽기와 생성을 모두 자동으로 설정하기 위한 어노테이션입니다. 프로젝트는 이 어노테이션이 있는 지점부터 설정을 읽어가기 때문에 @SpringBootApplication이 붙어있는 클래스는 항상 프로젝트 최상단에 위치해야합니다.\nSpringApplication.run 메서드: 이 메서드는 내부 WAS를 실행합니다. 때문에 톰캣이 필요 없다는 장점이 있으며 스프링 부트에서도 내장 WAS를 사용하는 것을 권장하고 있습니다.\n\n3-4 테스트를 위한 Controller의 패키지 생성현재 패키지(com.dev.latte.springboot)의 하위에 web 패키지를 만들어보겠습니다.앞으로 컨트롤러와 관련된 클래스들은 모두 이 패키지에 담겠습니다.\n3-5 Controller 생성 및 코드 작성web 패키지 아래에 테스트를 시행할 컨트롤러를 만들어 보겠습니다.클래스이름은 HelloController이며 내부 코드는 다음과 같습니다.\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController &#123;\n    @GetMapping(\"/hello\")\n    public String hello()&#123;\n        return \"hello\";\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n@RestController: 컨트롤러를 JSON객체를 반환하는 컨트롤러로 만들어줍니다.  \n@GetMapping: GET요청을 받는 API를 만들어줍니다.\n\n기능 테스트3-6 Controller의 기능 테스트를 위한 클래스 생성작성한 코드가 제대로 작동하는지 테스트하겠습니다.방금 생성한 HelloController의 클래스 이름 위에 커서를 두고, 윈도우는 [alt + enter], 맥은 [option + enter]를 누른 후, create test를 선택하여 그대로 테스트 클래스를 생성해주세요.\n[그림3-3] 테스트 클래스 생성\n생성된 테스트 클래스의 내부 코드를 아래와 같이 작성해주세요.\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n\n@WebMvcTest(controllers = HelloController.class)\nclass HelloControllerTest &#123;\n    @Autowired\n    private MockMvc mvc;\n\n    @Test\n    public void hello가_리턴된다() throws Exception &#123;\n        String hello = \"hello\";\n        mvc.perform(get(\"/hello\"))\n                .andExpect(status().isOk())\n                .andExpect(content().string(hello));\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n@WebMvcTest: MVC Controoler를 위한 테스트로 동작이 예상한대로 동작하는지 확인하는 데에 사용한다.\n@Autowired: 해당 변수 및 메서드에 스프링이 관리하는 Bean을 자동으로 매핑해준다. (스프링 의존성 주입)\n@Test: 테스트를 수행하는 메소드를 선언한다.\n\n책에서는 @WebMvcTest() 어노테이션 위에 @RunWith(SpringRunner.class) 어노테이션이 작성되어 있지만, 이 코드에서는 적지 않습니다.그 이유는 JUnit의 버전이 책과 다르기 때문입니다. [그림3-3]을 보면 이 테스트 클래스는 JUnit5버전입니다. @RunWith() 어노테이션은 JUnit4버전에 존재하는 어노테이션으로 JUnit5버전으로 올라오면서 @ExtendWith()로 대체되었습니다. 때문에 @RunWith() 대신에 @ExtendWith()을 사용해야 합니다.(출처 : @RunWith no longer exists; superseded by @ExtendWith)  \n하지만 이미 스프링 부트가 제공하는 모든 테스트용 어노테이션에는 @ExtendWith()가 메타 어노테이션으로 적용되어 있기 때문에 @ExtendWith(SpringExtension.class)를 생략할 수 있습니다.(출처 : Junit 5 with Spring Boot: When to use @ExtendWith Spring or Mockito?)\n3-7 테스트 코드 실행그럼 작성한 메소드를 테스트해봅시다. 왼쪽에 있는 초록색 삼각형을 눌러서 테스트를 실행해주세요!\n[그림3-4] 테스트 코드 실행\n테스트가 실행되고, 코드에 문제가 없다면 아래와 같이 Tests passed가 표시됩니다.  \n[그림3-5] 테스트 결과화면\n3-8 프로젝트 동작 확인마지막으로 프로젝트가 실제로 잘 동작하는지 확인해보겠습니다.Application.class로 돌아가 메인 메소드를 실행(Run ‘Application’)해주세요.\n[그림3-6] 어플리케이션 실행\n프로젝트가 문제없이 실행되었다면 콘솔 탭에 아래와 같이 표시됩니다.\n[그림3-6] 어플리케이션 실행\n브라우저에서 localhost:8080/hello로 접속해주세요.접속했을 때, 다음과 같이 문자열 hello가 잘 노출된다면 프로젝트가 제대로 동작하고 있는겁니다!\n[그림3-7] API 실행 결과\n\n이제, 웹 서비스를 위한 가장 기초적인 설정을 끝냈습니다.  \n\n스프링 부트 프로젝트 설정  \nAPI 코드 작성 및 테스트방법  \n\n다음 포스트에서는 생산성을 높여주는 라이브러리 롬복에 대해 설명하겠습니다.\n","slug":"springboot-web-4","date":"2021-06-11T02:24:43.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,java,TDD","author_index":"Latte"},{"id":"18c39e99fd033dd5083bccdf6728bd02","title":"2. Gradle을 스프링 부트 프로젝트로 변경","content":"이번 포스트에서는 작성한 프로젝트를 스프링 부트 프로젝트로 변경하는 방법을 설명합니다.의존성 주입을 통해 gradle을 스프링 부트 프로젝트로 변경하도록 하겠습니다.\nGradle을 스프링 부트 프로젝트로 변경2-1 “build.gradle”의 프로젝트의 플러그인 의존성 관리를 위한 설정 코드를 작성우선 프로젝트 내에 위치한 build.gradle의 최상단에 의존성 관리를 위한 설정코드를 작성합니다.코드를 작성하기 전에, 이 포스트에서는 책의 내용과 다른 방식으로 설정 코드를 작성 것을 미리 알려둡니다.그럼 어떻게 다른지 살펴볼까요? 우선, 책에서는 아래와 같이 코드를 작성하고 있습니다.\nbuildscript &#123;\n    ext &#123;\n        springBootVersion &#x3D; &#39;2.1.9.RELEASE&#39;\n    &#125;\n    repositories &#123;\n        mavenCentral()\n        jcenter()\n    &#125;\n    dependencies &#123;\n        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;)\n    &#125;\n&#125;\n\napply plugin: &#39;java&#39;\napply plugin: &#39;eclipse&#39;\napply plugin: &#39;org.springframework.boot&#39;\napply plugin: &#39;io.spring.dependency-management&#39;\n\n위와 같이 작성하던 도중, gradle.build에 자동으로 생성되어있던 plugins &#123; id &quot;java&quot;&#125;가 눈에 들어왔습니다.\n[그림2-1] 신경쓰이는 존재, plugins { id “java”}\n위에서 작성한 코드에서 apply plugin과 닮은 모습에 혹시 apply plugin을 모아서 사용할 수 있는 건 아닐까 하는 의심이 들었고, 자세한 사항을 알기 위해 검색하게 되었습니다. 검색해보니 plugins &#123;&#125; 은 gradle이 업데이트 되면서 변경된 사항으로 “plugins block”라 불리며, 플러그인을 추가하고, 선택적인 매개변수를 사용하여 적용 시기를 제어할 수 있다는 특징을 지닌다고 합니다.(출처)\n이 업데이트로 위의 코드의 buildscript&#123;&#125;과 apply plugins는 아래와 같이  합쳐서 적는 것이 가능해졌습니다.\nplugins &#123;\n    id &quot;java&quot;\n    id &quot;eclipse&quot;\n    id &quot;org.springframework.boot&quot; version &quot;2.1.9.RELEASE&quot;\n    id &quot;io.spring.dependency-management&quot; version &quot;1.0.11.RELEASE&quot;\n&#125;\n\n\n\n\n\n\n\n\n\n플러그인 정보는 이곳에서 확인 가능합니다.\n훨씬 간편하고 보기 좋아졌습니다.이 4개의 플러그인은 자바와 스프링 부트를 사용하기 위해 반드시 추가해야함을 잊지 말아주세요!그럼, gradle을 마저 추가해봅시다.\n2-2 dependencies에 개발에 필요한 의존성들을 선언dependencies에 개발에 필요한 의존성들을 선언합니다.책에서는 compile을 사용하였으나, 여기서는 implementation을 사용합니다.implementation을 사용하는 이유가 몇 가지 있습니다만, 가장 큰 이유는 compile이 gradle7+ 버전에서 삭제되었다는 것입니다.그 외에도 이유는 많지만, 이 포스트는 프로젝트 생성을 위한 자리이니 자세한건 다음에 다루어보겠습니다.혹시, 이 사항에 관심있으신 분을 위해 아래의 포스트 주소를 남기니 확인해보시길 바랍니다.\n\n\n\n\n\n\n\n\n\nGradle implementation vs. compile dependencies\n그럼, build.gradle의 dependencies에 다음의 의존성을 추가해봅시다.\ndependencies &#123;\n    implementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-web&#39;, version: &#39;2.4.5&#39;\n    testImplementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-test&#39;, version: &#39;2.4.5&#39;\n&#125;\n\n2-3 자바의 버전을 1.8로 설정해줍니다.이제 자바 소스 코드의 버전을 1.8로 설정해보겠습니다. 참고로, 제 컴퓨터에 설치되어있는 JDK는 13입니다.그럼에도 불구하고 1.8로 설정하는 이유는 책과의 환경 차이에서 생기는 오류를 줄이기 위함입니다.책에서는 스프링 부트 2.1.9.RELEASE 버전을 사용하며 gradle은 4.8~4.10 버전을 사용하고 있습니다.JDK 13은 스프링 부트 2.2.x 버전 이상, gradle은 6버전 이상만이 지원하기 때문에 스프링 부트의 버전업이 불가피합니다.스프링 부트의 버전업으로 인해 어떤 오류가 생길지 모르니 초반에는 JDK 1.8로 프로젝트를 진행하고, 후에 기회가 된다면 스프링 부트 업그레이드 후 13으로 변경하여 작업해보도록 하겠습니다.그럼, version아래에 다음과 같은 코드를 추가해주세요.\nsourceCompatibility &#x3D; 1.8\n이 코드는 자바 소스 코드의 버전을 의미합니다.\n2-4 build.gradle작성이 완료된 build.gradle의 전체 코드는 아래와 같습니다.\nplugins &#123;\n    id &quot;java&quot;\n    id &quot;eclipse&quot;\n    id &quot;org.springframework.boot&quot; version &quot;2.1.9.RELEASE&quot;\n    id &quot;io.spring.dependency-management&quot; version &quot;1.0.11.RELEASE&quot;\n&#125;\n\ngroup &#39;com.dev.latte&#39;\nversion &#39;1.0-SNAPSHOT&#39;\nsourceCompatibility &#x3D; 1.8\n\nrepositories &#123;\n    mavenCentral()\n&#125;\n\ndependencies &#123;\n    implementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-web&#39;, version: &#39;2.4.5&#39;\n    testImplementation group: &#39;org.springframework.boot&#39;, name: &#39;spring-boot-starter-test&#39;, version: &#39;2.4.5&#39;\n&#125;\n\ntest &#123;\n    useJUnitPlatform()\n&#125;\n\n2-5 Gradle 반영하기그레이들 작성이 완료되었다면, 인텔리제이 상단에 있는 Reload 버튼(순환마크)을 클릭하여 그레이들을 반영합니다.\n[그림2-2] gradle import\n버튼을 클릭하면, 인텔리제이 하단에 그레이들의 반영 상황이 표시되고, 반영이 끝나면 Gradle sync finished가 표시됩니다.\n\n이제 스프링 부트 프로젝트의 기본 셋팅이 완료되었습니다!다음 포스트에서는 프로젝트의 설정이 제대로 되었는지 확인해보도록 하겠습니다.\n","slug":"springboot-web-3","date":"2021-06-10T00:46:49.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,Java,gradle","author_index":"Latte"},{"id":"a01df8c8fb60fb63504058a17ab9f187","title":"1. IntelliJ 프로젝트 생성","content":"이 포스트에서 IntelliJ의 설치는 다루고 있지 않습니다. IntelliJ의 설치는 다른 분의 블로그나 웹을 참고해주세요.  \n\n\n\n\n\n\nIntelliJ IDEA\n    - IntelliJ는 기본적으로 유료툴이지만 community버전은 무료로 이용 가능합니다.    - 학생이시라면 1년 간 Ultimate버전 제품을 무료로 사용 가능합니다.\n\nIntelliJ 프로젝트 생성프로젝트 생성 전에, 이 포스트에서는 프로젝트 생성시 Spring Initializer를 사용하지 않습니다.왜 이 방식을 사용하는지 설명하겠습니다.  일단, 스프링 프로젝트를 생성하는 방법은 두 가지가 있습니다.  \n\nSpring Initializer를 이용하는 방법  \n프로젝트 생성 후, 의존성을 추가하는 방법\n\n첫 번째 방법은 간단하지만, 의존성 주입이나 build.gradle 등을 이해하지 않은 상태로 사용할 경우 오히려 혼란스러울 수 있습니다.때문에 이 포스트는 Spring Initializer를 사용하지 않고 간단한 프로젝트를 생성 후, 필요할 때마다 의존성을 추가합니다.\n이제 프로젝트를 생성해봅시다. \n1-1 프로젝트 생성“Create new Project” 혹은 “New Project” 버튼을 클릭합니다.\n[그림1-1] 프로젝트 생성\n1-2 프로젝트 Gradle 설정아래와 같은 창이 뜨면 이하와 같이 설정합니다.  \n[그림1-2] 프로젝트 Gradle 셋팅(JDK 버전은 신경쓰지 않으셔도 괜찮습니다. 나중에 build.gradle에서 1.8로 제어할 예정입니다.)\n설정이 끝났다면, Next를 클릭하여 다음으로 이동해주세요.\n1-3 GroupId와 ArtifactId 등록GroupId와 ArtifactId를 등록합니다.\n[그림1-3] 프로젝트 GroupId &amp; ArtifactId 등록  \n여기서 ArtifactId는 프로젝트의 이름이 됩니다.\n1-4 finish를 클릭하면 프로젝트 빌드가 시작됩니다.\n\n\n\n\n\n\n\n\n위의 과정 중간에 프로젝트의 경로를 정하는 창이 뜰 수도 있습니다. 당황하지 마시고 프로젝트가 저장될 위치를 저장해주세요.\n\n이제 Gradle기반의 자바 프로젝트가 완성되었습니다!다음 포스트에서는 이 프로젝트를 스프링 프로젝트로 변경해보도록 하겠습니다.\n","slug":"springboot-web-2","date":"2021-06-09T12:36:23.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,Java,gradle","author_index":"Latte"},{"id":"681e8e55f24e67b1822965c116da3835","title":"0. 개요","content":"이 카테고리는 이동욱님의 저서 「스프링 부트와 AWS로 혼자 구현하는 웹 서비스」를 기반으로 혼자 연습하며 문제를 해결해가는 카테고리입니다.기본적으로 책을 따라 진행하며, 프로젝트 전반의 흐름 및 진행하면서 생기는 버그의 해결문제를 기록합니다.또한 이 포스트에서 진행하는 프로젝트 환경은 책과 다른 점이 존재하니, 이런 부분을 확인하면서 포스트를 봐주시기 바랍니다.  \n\n\n\n\n\n\n환경\n    - 블로그 : intelliJ IDEA / Java8(JDK 1.8) / Gradle 6.8    - 책 : intelliJ IDEA / Java8(JDK1.8) / Gradle 4.8 ~ Gradle 4.10.2\n\n개인적으로 상냥하게 설명된 책이니 구매하셔서 보시는 것도 추천드립니다. (책 이름에 yes24 링크가 걸려있습니다)\n또한 기본적인 버그는 이동욱님의 공식 깃허브에서 논의되고 있으니 이쪽도 확인해보세요.  \n궁극적인 목표는 “서비스를 처음부터 끝까지 혼자 만드는 것!” 이지만 공부를 하기 위함도 있습니다.때문에 프로그램이나 프레임워크가 왜 그렇게 동작하는지를 알기 위해 삼천포로 빠지는 경우가 많을 것 같습니다.글이 길어질 것 같은 경우, 다른 게시글에 정리할 예정이니 관심있으신 분은 링크를 타고 이동해주세요.\n그럼, 시작하겠습니다 :D\n","slug":"springboot-web-1","date":"2021-06-08T12:36:23.000Z","categories_index":"스프링 부트와 AWS로 혼자 구현하는 웹 서비스","tags_index":"springBoot,Java,gradle","author_index":"Latte"},{"id":"3b9e4a33c5246d01da88767642ae37d5","title":"markdown page","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-06-07T12:36:23.000Z","categories_index":"","tags_index":"hexo,aurora","author_index":"Latte"}]